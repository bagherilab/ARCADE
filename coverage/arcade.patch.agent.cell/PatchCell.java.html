<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PatchCell.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">arcade</a> &gt; <a href="index.source.html" class="el_package">arcade.patch.agent.cell</a> &gt; <span class="el_source">PatchCell.java</span></div><h1>PatchCell.java</h1><pre class="source lang-java linenums">package arcade.patch.agent.cell;

import java.util.HashMap;
import java.util.Map;
import sim.engine.Schedule;
import sim.engine.Stoppable;
import sim.util.Bag;
import ec.util.MersenneTwisterFast;
import arcade.core.agent.cell.Cell;
import arcade.core.agent.cell.CellContainer;
import arcade.core.agent.cell.CellState;
import arcade.core.agent.module.Module;
import arcade.core.agent.process.Process;
import arcade.core.agent.process.ProcessDomain;
import arcade.core.env.location.Location;
import arcade.core.sim.Simulation;
import arcade.core.util.GrabBag;
import arcade.core.util.MiniBox;
import arcade.core.util.Parameters;
import arcade.patch.agent.module.PatchModuleApoptosis;
import arcade.patch.agent.module.PatchModuleMigration;
import arcade.patch.agent.module.PatchModuleNecrosis;
import arcade.patch.agent.module.PatchModuleProliferation;
import arcade.patch.agent.module.PatchModuleQuiescence;
import arcade.patch.agent.module.PatchModuleSenescence;
import arcade.patch.agent.process.PatchProcessInflammation;
import arcade.patch.agent.process.PatchProcessMetabolism;
import arcade.patch.agent.process.PatchProcessSignaling;
import arcade.patch.env.grid.PatchGrid;
import arcade.patch.env.location.PatchLocation;
import arcade.patch.util.PatchEnums;
import static arcade.patch.util.PatchEnums.Domain;
import static arcade.patch.util.PatchEnums.Flag;
import static arcade.patch.util.PatchEnums.Ordering;
import static arcade.patch.util.PatchEnums.State;

/**
 * Implementation of {@link Cell} for generic cell agent.
 *
 * &lt;p&gt;Cells that become necrotic or senescent have a change to become apoptotic instead ({@code
 * NECROTIC_FRACTION} and {@code SENESCENT_FRACTION}, respectively).
 *
 * &lt;p&gt;Cell parameters are tracked using a map between the parameter name and value. Daughter cell
 * parameter values are drawn from a distribution centered on the parent cell parameter with the
 * specified amount of heterogeneity ({@code HETEROGENEITY}).
 */
public abstract class PatchCell implements Cell {
    /** Stopper used to stop this agent from being stepped in the schedule. */
    Stoppable stopper;

    /** Cell {@link Location} object. */
    final PatchLocation location;

    /** Unique cell ID. */
    final int id;

    /** Cell parent ID. */
    final int parent;

    /** Cell population index. */
    final int pop;

    /** Maximum number of cells from its population allowed in a {@link Location}. */
    final int maxDensity;

    /** Cell state. */
    CellState state;

    /** Cell age [min]. */
    int age;

    /** Cell energy [fmol ATP]. */
    protected double energy;

    /** Number of divisions. */
    int divisions;

    /** Maximum number of divisions. */
    protected final int divisionPotential;

    /** Cell volume [um&lt;sup&gt;3&lt;/sup&gt;]. */
    double volume;

    /** Cell height [um]. */
    double height;

    /** Death age due to apoptosis [min]. */
    double apoptosisAge;

    /** Critical volume for cell [um&lt;sup&gt;3&lt;/sup&gt;]. */
    final double criticalVolume;

    /** Critical height for cell [um]. */
    final double criticalHeight;

    /** Cell state change flag. */
    protected Flag flag;

    /** Fraction of necrotic cells that become apoptotic. */
    protected final double necroticFraction;

    /** Fraction of senescent cells that become apoptotic. */
    protected final double senescentFraction;

    /** Maximum energy deficit before necrosis. */
    protected final double energyThreshold;

    /** Accuracy in detecting concentration when selecting best location. */
    private final double accuracy;

    /** Affinity to prefer locations towards the center of simulation. */
    private final double affinity;

    /** Cell state module. */
    protected Module module;

    /** Map of process domains and {@link Process} instance. */
    protected final Map&lt;ProcessDomain, Process&gt; processes;

    /** Cell parameters. */
    final Parameters parameters;

    /** Cell population links. */
    final GrabBag links;

    /** List of cell cycle lengths (in minutes). */
<span class="fc" id="L127">    private final Bag cycles = new Bag();</span>

    /** If cell is stopped in the simulation. */
    private boolean isStopped;

    /** Cell binding flag. */
    protected PatchEnums.AntigenFlag bindingFlag;

    /**
     * Creates a {@code PatchCell} agent.
     *
     * &lt;p&gt;Loaded parameters include:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;{@code NECROTIC_FRACTION} = fraction of necrotic cells that become apoptotic
     *   &lt;li&gt;{@code SENESCENT_FRACTION} = fraction of senescent cells that become apoptotic
     *   &lt;li&gt;{@code ENERGY_THRESHOLD} = maximum energy deficit before necrosis
     * &lt;/ul&gt;
     *
     * @param container the cell container
     * @param location the {@link Location} of the cell
     * @param parameters the cell parameters
     * @param links the map of population links
     */
    public PatchCell(
<span class="fc" id="L152">            PatchCellContainer container, Location location, Parameters parameters, GrabBag links) {</span>
<span class="fc" id="L153">        this.id = container.id;</span>
<span class="fc" id="L154">        this.parent = container.parent;</span>
<span class="fc" id="L155">        this.pop = container.pop;</span>
<span class="fc" id="L156">        this.age = container.age;</span>
<span class="fc" id="L157">        this.energy = 0;</span>
<span class="fc" id="L158">        this.divisions = container.divisions;</span>
<span class="fc" id="L159">        this.location = (PatchLocation) location;</span>
<span class="fc" id="L160">        this.volume = container.volume;</span>
<span class="fc" id="L161">        this.height = container.height;</span>
<span class="fc" id="L162">        this.criticalVolume = container.criticalVolume;</span>
<span class="fc" id="L163">        this.criticalHeight = container.criticalHeight;</span>
<span class="fc" id="L164">        this.flag = Flag.UNDEFINED;</span>
<span class="fc" id="L165">        this.parameters = parameters;</span>
<span class="fc" id="L166">        this.isStopped = false;</span>
<span class="fc" id="L167">        this.bindingFlag = PatchEnums.AntigenFlag.UNDEFINED;</span>
<span class="fc" id="L168">        this.links = links;</span>

<span class="fc" id="L170">        setState(container.state);</span>

        // Set loaded parameters.
<span class="fc" id="L173">        necroticFraction = parameters.getDouble(&quot;NECROTIC_FRACTION&quot;);</span>
<span class="fc" id="L174">        senescentFraction = parameters.getDouble(&quot;SENESCENT_FRACTION&quot;);</span>
<span class="fc" id="L175">        energyThreshold = -parameters.getDouble(&quot;ENERGY_THRESHOLD&quot;);</span>
<span class="fc" id="L176">        apoptosisAge = parameters.getDouble(&quot;APOPTOSIS_AGE&quot;);</span>
<span class="fc" id="L177">        accuracy = parameters.getDouble(&quot;ACCURACY&quot;);</span>
<span class="fc" id="L178">        affinity = parameters.getDouble(&quot;AFFINITY&quot;);</span>
<span class="fc" id="L179">        divisionPotential = parameters.getInt(&quot;DIVISION_POTENTIAL&quot;);</span>
<span class="fc" id="L180">        int densityInput = parameters.getInt(&quot;MAX_DENSITY&quot;);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">        maxDensity = (densityInput &gt;= 0 ? densityInput : Integer.MAX_VALUE);</span>

        // Add cell processes.
<span class="fc" id="L184">        processes = new HashMap&lt;&gt;();</span>
<span class="fc" id="L185">        MiniBox processBox = parameters.filter(&quot;(PROCESS)&quot;);</span>

<span class="pc bpc" id="L187" title="1 of 2 branches missed.">        for (String processKey : processBox.getKeys()) {</span>
<span class="nc" id="L188">            ProcessDomain domain = Domain.valueOf(processKey);</span>
<span class="nc" id="L189">            String version = processBox.get(processKey);</span>
<span class="nc" id="L190">            Process process = makeProcess(domain, version);</span>
<span class="nc" id="L191">            processes.put(domain, process);</span>
<span class="nc" id="L192">        }</span>
<span class="fc" id="L193">    }</span>

    @Override
    public int getID() {
<span class="nc" id="L197">        return id;</span>
    }

    @Override
    public int getParent() {
<span class="nc" id="L202">        return parent;</span>
    }

    @Override
    public int getPop() {
<span class="fc" id="L207">        return pop;</span>
    }

    @Override
    public CellState getState() {
<span class="fc" id="L212">        return state;</span>
    }

    @Override
    public int getAge() {
<span class="nc" id="L217">        return age;</span>
    }

    @Override
    public int getDivisions() {
<span class="nc" id="L222">        return divisions;</span>
    }

    @Override
    public Location getLocation() {
<span class="fc" id="L227">        return location;</span>
    }

    @Override
    public Module getModule() {
<span class="nc" id="L232">        return module;</span>
    }

    @Override
    public Process getProcess(ProcessDomain domain) {
<span class="nc" id="L237">        return processes.get(domain);</span>
    }

    @Override
    public Parameters getParameters() {
<span class="fc" id="L242">        return parameters;</span>
    }

    @Override
    public double getVolume() {
<span class="fc" id="L247">        return volume;</span>
    }

    @Override
    public double getHeight() {
<span class="nc" id="L252">        return height;</span>
    }

    @Override
    public double getCriticalVolume() {
<span class="fc" id="L257">        return criticalVolume;</span>
    }

    @Override
    public double getCriticalHeight() {
<span class="fc" id="L262">        return criticalHeight;</span>
    }

    /**
     * Gets the cell energy level.
     *
     * @return the energy level
     */
    public double getEnergy() {
<span class="fc" id="L271">        return energy;</span>
    }

    /**
     * Sets the cell flag.
     *
     * @param flag the target cell flag
     */
    public void setFlag(Flag flag) {
<span class="fc" id="L280">        this.flag = flag;</span>
<span class="fc" id="L281">    }</span>

    /**
     * Sets the cell volume.
     *
     * @param volume the target cell volume
     */
    public void setVolume(double volume) {
<span class="fc" id="L289">        this.volume = volume;</span>
<span class="fc" id="L290">    }</span>

    /**
     * Sets the cell energy level.
     *
     * @param energy the target energy level
     */
    public void setEnergy(double energy) {
<span class="fc" id="L298">        this.energy = energy;</span>
<span class="fc" id="L299">    }</span>

    /**
     * Adds a completed cell cycle length [min] to the list of lengths.
     *
     * @param val the cell cycle length
     */
    public void addCycle(int val) {
<span class="fc" id="L307">        cycles.add(val);</span>
<span class="fc" id="L308">    }</span>

    /**
     * Gets the list of cell cycle lengths.
     *
     * @return the list of cell cycle lengths
     */
    public Bag getCycles() {
<span class="fc" id="L316">        return cycles;</span>
    }

    @Override
    public void stop() {
<span class="nc" id="L321">        stopper.stop();</span>
<span class="nc" id="L322">        isStopped = true;</span>
<span class="nc" id="L323">    }</span>

    /**
     * Gets stopping status of the cell.
     *
     * @return if the cell has been stopped in the simulation
     */
    public boolean isStopped() {
<span class="nc" id="L331">        return isStopped;</span>
    }

    @Override
    public void setState(CellState state) {
<span class="fc" id="L336">        this.state = state;</span>
<span class="fc" id="L337">        this.flag = Flag.UNDEFINED;</span>

<span class="pc bpc" id="L339" title="2 of 9 branches missed.">        switch ((State) state) {</span>
            case PROLIFERATIVE:
<span class="fc" id="L341">                module = new PatchModuleProliferation(this);</span>
<span class="fc" id="L342">                break;</span>
            case MIGRATORY:
<span class="fc" id="L344">                module = new PatchModuleMigration(this);</span>
<span class="fc" id="L345">                break;</span>
            case APOPTOTIC:
<span class="fc" id="L347">                module = new PatchModuleApoptosis(this);</span>
<span class="fc" id="L348">                break;</span>
            case NECROTIC:
<span class="fc" id="L350">                module = new PatchModuleNecrosis(this);</span>
<span class="fc" id="L351">                break;</span>
            case QUIESCENT:
<span class="fc" id="L353">                module = new PatchModuleQuiescence(this);</span>
<span class="fc" id="L354">                break;</span>
            case SENESCENT:
<span class="fc" id="L356">                module = new PatchModuleSenescence(this);</span>
<span class="fc" id="L357">                break;</span>
            case CYTOTOXIC:
<span class="nc" id="L359">                throw new UnsupportedOperationException();</span>
            case STIMULATORY:
<span class="nc" id="L361">                throw new UnsupportedOperationException();</span>
            default:
<span class="fc" id="L363">                module = null;</span>
                break;
        }
<span class="fc" id="L366">    }</span>

    /**
     * Makes the specified {@link Process} object.
     *
     * @param domain the process domain
     * @param version the process version
     * @return the process instance
     */
    public Process makeProcess(ProcessDomain domain, String version) {
<span class="nc bnc" id="L376" title="All 4 branches missed.">        switch ((Domain) domain) {</span>
            case METABOLISM:
<span class="nc" id="L378">                return PatchProcessMetabolism.make(this, version);</span>
            case SIGNALING:
<span class="nc" id="L380">                return PatchProcessSignaling.make(this, version);</span>
            case INFLAMMATION:
<span class="nc" id="L382">                return PatchProcessInflammation.make(this, version);</span>
            case UNDEFINED:
            default:
<span class="nc" id="L385">                return null;</span>
        }
    }

    @Override
    public void schedule(Schedule schedule) {
<span class="fc" id="L391">        stopper = schedule.scheduleRepeating(this, Ordering.CELLS.ordinal(), 1);</span>
<span class="fc" id="L392">    }</span>

    @Override
    public CellContainer convert() {
<span class="nc" id="L396">        return new PatchCellContainer(</span>
                id,
                parent,
                pop,
                age,
                divisions,
                state,
                volume,
                height,
                criticalVolume,
                criticalHeight);
    }

    /**
     * Calculates the total volume of {@code Cell} objects in a {@code Bag}.
     *
     * @param bag the {@code Bag} containing cell objects
     * @return the total volume
     */
    public static double calculateTotalVolume(Bag bag) {
<span class="fc" id="L416">        double totalVolume = 0;</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">        for (Object obj : bag) {</span>
<span class="fc" id="L418">            totalVolume += ((Cell) obj).getVolume();</span>
<span class="fc" id="L419">        }</span>
<span class="fc" id="L420">        return totalVolume;</span>
    }

    /**
     * Selects best location for a cell to be added or move into.
     *
     * &lt;p&gt;Each free location is scored based on glucose availability and distance from the center of
     * the simulation.
     *
     * @param sim the simulation instance
     * @param random the random number generator
     * @return the best location or null if no valid locations
     */
    public PatchLocation selectBestLocation(Simulation sim, MersenneTwisterFast random) {
<span class="fc" id="L434">        Bag locs = findFreeLocations(sim);</span>
<span class="fc" id="L435">        double maxGlucose =</span>
<span class="fc" id="L436">                sim.getLattice(&quot;GLUCOSE&quot;).getParameters().getDouble(&quot;generator/CONCENTRATION&quot;);</span>
<span class="fc" id="L437">        int currZ = location.getPlanarIndex();</span>
<span class="fc" id="L438">        double currR = location.getPlanarDistance();</span>
<span class="fc" id="L439">        int[] inds = new int[3];</span>
<span class="fc" id="L440">        double[] scores = new double[3];</span>

        // Check each free location for glucose and track the location with the
        // highest glucose concentration.
<span class="fc bfc" id="L444" title="All 2 branches covered.">        if (locs.size() &gt; 0) {</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">            for (int i = 0; i &lt; locs.numObjs; i++) {</span>
<span class="fc" id="L446">                PatchLocation loc = (PatchLocation) (locs.get(i));</span>
                // Calculate score by introducing error to the location check
                // and adding affinity to move toward center.
<span class="fc" id="L449">                double normConc = sim.getLattice(&quot;GLUCOSE&quot;).getAverageValue(location) / maxGlucose;</span>
<span class="fc" id="L450">                double gluc = (accuracy * normConc + (1 - accuracy) * random.nextDouble());</span>
<span class="fc" id="L451">                double dist = ((currR - loc.getPlanarDistance()) + 1) / 2.0;</span>
<span class="fc" id="L452">                double score = affinity * dist + (1 - affinity) * gluc;</span>

                // Determine index for z position of location.
                // 0: same z, 1: z + 1, 2: z - 1
                int k =
<span class="fc bfc" id="L457" title="All 2 branches covered.">                        loc.getPlanarIndex() == currZ</span>
<span class="fc" id="L458">                                ? 0</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">                                : loc.getPlanarIndex() == currZ + 1 ? 1 : 2;</span>

                // Check if location is more desirable than current best location in z plane.
<span class="fc bfc" id="L462" title="All 2 branches covered.">                if (score &gt; scores[k]) {</span>
<span class="fc" id="L463">                    scores[k] = score;</span>
<span class="fc" id="L464">                    inds[k] = i;</span>
                }
            }

<span class="fc" id="L468">            GrabBag options = new GrabBag();</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">            for (int i = 0; i &lt; 3; i++) {</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">                if (scores[i] != 0) {</span>
<span class="fc" id="L471">                    options.add(inds[i], 1);</span>
                }
            }
<span class="fc bfc" id="L474" title="All 2 branches covered.">            if (!options.isEmpty()) {</span>
<span class="fc" id="L475">                return (PatchLocation) locs.get(options.next(random));</span>
            }
        }

<span class="fc" id="L479">        return null;</span>
    }

    /**
     * Find free locations in the neighborhood of the cell.
     *
     * @param sim the simulation instance
     * @return a {@code Bag} of free locations
     */
    public Bag findFreeLocations(Simulation sim) {
<span class="fc" id="L489">        Bag freeLocations = new Bag();</span>
<span class="fc" id="L490">        PatchLocation currentLocation = this.location;</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">        double targetVolume = (state == State.PROLIFERATIVE) ? volume * 0.5 : volume;</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">        int densityAdjustment = (state == State.PROLIFERATIVE) ? 1 : 0;</span>

<span class="fc bfc" id="L494" title="All 2 branches covered.">        if (checkLocation(</span>
                sim, currentLocation, 0, criticalHeight, pop, maxDensity - densityAdjustment)) {
<span class="fc" id="L496">            freeLocations.add(currentLocation.getClone());</span>
        }

<span class="fc bfc" id="L499" title="All 2 branches covered.">        for (Location neighborLocation : currentLocation.getNeighbors()) {</span>
<span class="fc" id="L500">            PatchLocation neighbor = (PatchLocation) neighborLocation;</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">            if (checkLocation(sim, neighbor, targetVolume, criticalHeight, pop, maxDensity)) {</span>
<span class="fc" id="L502">                freeLocations.add(neighborLocation);</span>
            }
<span class="fc" id="L504">        }</span>
<span class="fc" id="L505">        return freeLocations;</span>
    }

    /**
     * Determine if a patch location is free.
     *
     * &lt;p&gt;A location is free if the proposed cell volume can fit in the location without exceeding
     * the max volume of a location, exceeding constituents' critical heights, and exceeding the
     * population density is below the maximum.
     *
     * @param sim the simulation instance
     * @param loc the location
     * @param addedVolume the volume added to the location
     * @param maxHeight the maximum height tolerance
     * @param population the population index
     * @param maxDensity the maximum density of population in the location
     * @return if the location is available for the cell
     */
    static boolean checkLocation(
            Simulation sim,
            PatchLocation loc,
            double addedVolume,
            double maxHeight,
            int population,
            int maxDensity) {
<span class="fc" id="L530">        double locationVolume = loc.getVolume();</span>
<span class="fc" id="L531">        double locationArea = loc.getArea();</span>
<span class="fc" id="L532">        PatchGrid grid = (PatchGrid) sim.getGrid();</span>

<span class="fc" id="L534">        Bag bag = new Bag(grid.getObjectsAtLocation(loc));</span>

<span class="fc bfc" id="L536" title="All 2 branches covered.">        if (bag.numObjs != 0) {</span>
<span class="fc" id="L537">            double proposedVolume = calculateTotalVolume(bag) + addedVolume;</span>
<span class="fc" id="L538">            double proposedHeight = proposedVolume / locationArea;</span>

<span class="fc bfc" id="L540" title="All 4 branches covered.">            if (proposedVolume &gt; locationVolume || proposedHeight &gt; maxHeight) {</span>
<span class="fc" id="L541">                return false;</span>
            }

<span class="fc" id="L544">            int count = 0;</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">            for (Object obj : bag) {</span>
<span class="fc" id="L546">                PatchCell cell = (PatchCell) obj;</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">                if (proposedHeight &gt; cell.getCriticalHeight()) {</span>
<span class="fc" id="L548">                    return false;</span>
                }
<span class="fc bfc" id="L550" title="All 2 branches covered.">                if (cell.getPop() == population) {</span>
<span class="fc" id="L551">                    count++;</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">                    if (count &gt;= maxDensity) {</span>
<span class="fc" id="L553">                        return false;</span>
                    }
                }
<span class="fc" id="L556">            }</span>
        }
<span class="fc" id="L558">        return true;</span>
    }

    /**
     * Sets the cell binding flag.
     *
     * @param newBindingFlag the target cell antigen binding state
     */
    public void setBindingFlag(PatchEnums.AntigenFlag newBindingFlag) {
<span class="fc" id="L567">        this.bindingFlag = newBindingFlag;</span>
<span class="fc" id="L568">    }</span>

    /**
     * Returns the cell binding flag.
     *
     * @return the cell antigen binding state
     */
    public PatchEnums.AntigenFlag getBindingFlag() {
<span class="fc" id="L576">        return this.bindingFlag;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>