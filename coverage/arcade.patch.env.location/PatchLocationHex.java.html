<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PatchLocationHex.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">arcade</a> &gt; <a href="index.source.html" class="el_package">arcade.patch.env.location</a> &gt; <span class="el_source">PatchLocationHex.java</span></div><h1>PatchLocationHex.java</h1><pre class="source lang-java linenums">package arcade.patch.env.location;

import java.util.ArrayList;
import arcade.core.env.location.Location;
import arcade.core.env.location.LocationContainer;
import arcade.patch.sim.PatchSeries;

/**
 * Concrete implementation of {@link PatchLocation} for hexagonal {@link arcade.core.env.grid.Grid}
 * to a triangular {@link arcade.core.env.lattice.Lattice}.
 *
 * &lt;p&gt;{@link arcade.core.env.grid.Grid} coordinates are in terms of (u, v, w) and the {@link
 * arcade.core.env.lattice.Lattice} coordinates are in (x, y). Hexagons are flat side up. Triangular
 * {@link arcade.core.env.lattice.Lattice} subcoordinates are ordered 0 - 5, with 0 at the top
 * center and going clockwise around.
 *
 * &lt;pre&gt;
 *      -------
 *     / \ 0 / \
 *    / 5 \ / 1 \
 *    -----------
 *    \ 4 / \ 2 /
 *     \ / 3 \ /
 *      -------
 * &lt;/pre&gt;
 *
 * In (u, v, w) coordinates, only coordinates where u + v + w = 0 are valid. For simulations with
 * {@code DEPTH} &amp;#62; 0 (3D simulations), each the hexagonal grid is offset in one of two
 * directions relative to the triangular lattice. Therefore, each cell in a location has six
 * neighboring locations in the same layer, three neighboring locations in the layer above, and
 * three neighboring locations in the layer below. Simulations with {@code DEPTH} &amp;#62; 1 must have
 * a {@code MARGIN} &amp;#62; 0, otherwise the offset location coordinates will be associated with
 * lattice coordinates that are out of bounds of the array.
 */
public final class PatchLocationHex extends PatchLocation {
    /** Size of hexagon patch from side to side [um]. */
    private static final double HEX_SIZE = 30.0;

    /** Size of the hexagon patch side [um]. */
<span class="fc" id="L40">    private static final double HEX_SIDE = HEX_SIZE / Math.sqrt(3.0);</span>

    /** Height of hexagon patch [um]. */
    private static final double HEX_DEPTH = 8.7;

    /** Perimeter of hexagon patch [um]. */
<span class="fc" id="L46">    private static final double HEX_PERIMETER = 6 * HEX_SIDE;</span>

    /** Area of hexagon patch [um&lt;sup&gt;2&lt;/sup&gt;]. */
<span class="fc" id="L49">    private static final double HEX_AREA = 3.0 / 2.0 / Math.sqrt(3.0) * HEX_SIZE * HEX_SIZE;</span>

    /** Surface area of hexagon patch [um&lt;sup&gt;2&lt;/sup&gt;]. */
<span class="fc" id="L52">    private static final double HEX_SURFACE = 2 * HEX_AREA + HEX_DEPTH * HEX_PERIMETER;</span>

    /** Volume of hexagon patch [um&lt;sup&gt;3&lt;/sup&gt;]. */
<span class="fc" id="L55">    private static final double HEX_VOLUME = HEX_AREA * HEX_DEPTH;</span>

    /** Ratio of hexagon location height to size. */
    private static final double HEX_RATIO = HEX_DEPTH / HEX_SIZE;

    /** Size of the triangle position [um]. */
<span class="fc" id="L61">    private static final double TRI_SIZE = HEX_SIDE;</span>

    /** Number of triangular subcoordinates. */
    private static final int NUM_SUBCOORDINATES = 6;

    /** Relative triangular subcoordinate offsets in the x direction. */
<span class="fc" id="L67">    private static final byte[] X_OFF = new byte[] {0, 1, 1, 0, -1, -1};</span>

    /** Relative triangular subcoordinate offsets in the y direction. */
<span class="fc" id="L70">    private static final byte[] Y_OFF = new byte[] {0, 0, 1, 1, 1, 0};</span>

    /** List of relative hexagonal neighbor locations. */
<span class="fc" id="L73">    private static final byte[] MOVES =</span>
            new byte[] {
<span class="fc" id="L75">                (byte) Integer.parseInt(&quot;00100100&quot;, 2), // up</span>
<span class="fc" id="L76">                (byte) Integer.parseInt(&quot;00011000&quot;, 2), // down</span>
<span class="fc" id="L77">                (byte) Integer.parseInt(&quot;01100000&quot;, 2), // up left</span>
<span class="fc" id="L78">                (byte) Integer.parseInt(&quot;10010000&quot;, 2), // down right</span>
<span class="fc" id="L79">                (byte) Integer.parseInt(&quot;01001000&quot;, 2), // down left</span>
<span class="fc" id="L80">                (byte) Integer.parseInt(&quot;10000100&quot;, 2), // up right</span>
<span class="fc" id="L81">                (byte) Integer.parseInt(&quot;00000010&quot;, 2), // vert up</span>
<span class="fc" id="L82">                (byte) Integer.parseInt(&quot;00000001&quot;, 2), // vert down</span>
<span class="fc" id="L83">                (byte) Integer.parseInt(&quot;10000110&quot;, 2), // vert up cw 1</span>
<span class="fc" id="L84">                (byte) Integer.parseInt(&quot;00100110&quot;, 2), // vert up cw 2</span>
<span class="fc" id="L85">                (byte) Integer.parseInt(&quot;01100001&quot;, 2), // vert down ccw 1</span>
<span class="fc" id="L86">                (byte) Integer.parseInt(&quot;00100101&quot;, 2), // vert down ccw 2</span>
            };

    /**
     * Creates a {@code PatchLocationHex} object for given coordinates.
     *
     * @param u the coordinate in u direction
     * @param v the coordinate in v direction
     * @param w the coordinate in w direction
     * @param z the coordinate in z direction
     */
    public PatchLocationHex(int u, int v, int w, int z) {
<span class="nc" id="L98">        this(new CoordinateUVWZ(u, v, w, z));</span>
<span class="nc" id="L99">    }</span>

    /**
     * Creates a {@code PatchLocationHex} object at given coordinate.
     *
     * @param coordinate the patch coordinate
     */
    public PatchLocationHex(CoordinateUVWZ coordinate) {
<span class="fc" id="L107">        super(coordinate, NUM_SUBCOORDINATES);</span>
<span class="fc" id="L108">    }</span>

    @Override
    public double getVolume() {
<span class="fc" id="L112">        return HEX_VOLUME;</span>
    }

    @Override
    public double getSurface() {
<span class="nc" id="L117">        return HEX_SURFACE;</span>
    }

    @Override
    public double getHeight() {
<span class="fc" id="L122">        return HEX_DEPTH;</span>
    }

    @Override
    public double getArea() {
<span class="fc" id="L127">        return HEX_AREA;</span>
    }

    @Override
    public double getCoordinateSize() {
<span class="nc" id="L132">        return HEX_SIZE;</span>
    }

    @Override
    public double getSubcoordinateSize() {
<span class="fc" id="L137">        return TRI_SIZE;</span>
    }

    @Override
    public double getRatio() {
<span class="nc" id="L142">        return HEX_RATIO;</span>
    }

    @Override
    public int getMaximum() {
<span class="fc" id="L147">        return NUM_SUBCOORDINATES;</span>
    }

    /**
     * Updates static configuration variables.
     *
     * &lt;p&gt;Environment sizes are not set until the simulation series is created. Calculations for
     * coordinates depend on these sizes, so the {@code Location} needs to be updated based on the
     * series configuration.
     *
     * @param series the current simulation series
     */
    public static void updateConfigs(PatchSeries series) {
<span class="fc" id="L160">        radius = series.radius;</span>
<span class="fc" id="L161">        depth = series.depth;</span>
<span class="fc" id="L162">        radiusBounds = series.radiusBounds;</span>
<span class="fc" id="L163">        depthBounds = series.depthBounds;</span>
<span class="fc" id="L164">        heightOffset = series.height % 3 - series.height;</span>
<span class="fc" id="L165">    }</span>

    @Override
    void calculateOffset() {
<span class="fc" id="L169">        offset = (byte) ((Math.abs(heightOffset + coordinate.z)) % 3);</span>
<span class="fc" id="L170">    }</span>

    @Override
    void calculateSubcoordinates() {
<span class="fc" id="L174">        CoordinateUVWZ hex = (CoordinateUVWZ) coordinate;</span>

        // Calculate coordinate of top center triangle.
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">        int x = 3 * (hex.u + radiusBounds) - 2 + (offset == 2 ? -1 : offset);</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">        int y = (hex.w - hex.v) + 2 * radiusBounds - 2 + (offset == 0 ? 0 : 1);</span>
<span class="fc" id="L179">        int z = depthBounds + hex.z - 1;</span>

        // Set coordinates of triangles clockwise from top center.
<span class="fc bfc" id="L182" title="All 2 branches covered.">        for (int i = 0; i &lt; NUM_SUBCOORDINATES; i++) {</span>
<span class="fc" id="L183">            subcoordinates.add(i, new CoordinateXYZ(x + X_OFF[i], y + Y_OFF[i], z));</span>
        }
<span class="fc" id="L185">    }</span>

    /**
     * {@inheritDoc}
     *
     * &lt;p&gt;Each direction of movement ({@code +u, -u, +v, -v, +w, -w, +z, -z}) is tracked by each bit
     * within a byte.
     */
    @Override
    void calculateChecks() {
<span class="fc" id="L195">        CoordinateUVWZ hex = (CoordinateUVWZ) coordinate;</span>
<span class="fc" id="L196">        check =</span>
                (byte)
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">                        ((hex.u == radius - 1 ? 0 : 1 &lt;&lt; 7)</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">                                + (hex.u == 1 - radius ? 0 : 1 &lt;&lt; 6)</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">                                + (hex.v == radius - 1 ? 0 : 1 &lt;&lt; 5)</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">                                + (hex.v == 1 - radius ? 0 : 1 &lt;&lt; 4)</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">                                + (hex.w == radius - 1 ? 0 : 1 &lt;&lt; 3)</span>
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">                                + (hex.w == 1 - radius ? 0 : 1 &lt;&lt; 2)</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">                                + (hex.z == depth - 1 ? 0 : 1 &lt;&lt; 1)</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">                                + (hex.z == 1 - depth ? 0 : 1 &lt;&lt; 0));</span>
<span class="fc" id="L206">    }</span>

    /**
     * {@inheritDoc}
     *
     * &lt;p&gt;Estimates the perimeter of cell occupying the hexagonal location. Volume fraction used to
     * take fraction of the perimeter of the hexagon. If fraction is not 1 (i.e. at least two cells
     * in the location), then two additional inner segments are added.
     */
    @Override
    public double getPerimeter(double f) {
<span class="nc bnc" id="L217" title="All 2 branches missed.">        return f * HEX_PERIMETER + (f == 1 ? 0 : 2 * HEX_SIDE);</span>
    }

    /**
     * {@inheritDoc}
     *
     * &lt;p&gt;We check if a neighbor location is valid by comparing the movement checks byte with the
     * neighbor location byte. Neighbor list includes the current location.
     */
    @Override
    public ArrayList&lt;Location&gt; getNeighbors() {
<span class="nc" id="L228">        CoordinateUVWZ hex = (CoordinateUVWZ) coordinate;</span>
<span class="nc" id="L229">        ArrayList&lt;Location&gt; neighbors = new ArrayList&lt;&gt;(MOVES.length + 1);</span>
        byte b;

        // Add neighbor locations.
<span class="nc bnc" id="L233" title="All 2 branches missed.">        for (int i = 0; i &lt; MOVES.length; i++) {</span>
            // Adjust byte for vertical offset.
<span class="nc bnc" id="L235" title="All 2 branches missed.">            if (i &gt; 7) {</span>
<span class="nc" id="L236">                b = offsetByte(MOVES[i], 2 * offset);</span>
            } else {
<span class="nc" id="L238">                b = MOVES[i];</span>
            }

            // Add location if possible to move there.
<span class="nc bnc" id="L242" title="All 2 branches missed.">            if ((b &amp; check ^ b) == 0) {</span>
<span class="nc" id="L243">                neighbors.add(</span>
                        new PatchLocationHex(
                                hex.u + (b &gt;&gt; 7 &amp; 1) - (b &gt;&gt; 6 &amp; 1),
                                hex.v + (b &gt;&gt; 5 &amp; 1) - (b &gt;&gt; 4 &amp; 1),
                                hex.w + (b &gt;&gt; 3 &amp; 1) - (b &gt;&gt; 2 &amp; 1),
                                hex.z + (b &gt;&gt; 1 &amp; 1) - (b &gt;&gt; 0 &amp; 1)));
            }
        }

        // Add current location.
<span class="nc" id="L253">        neighbors.add(new PatchLocationHex(hex));</span>

<span class="nc" id="L255">        return neighbors;</span>
    }

    @Override
    public LocationContainer convert(int id) {
<span class="nc" id="L260">        return new PatchLocationContainer(id, coordinate);</span>
    }

    /**
     * Converts triangular {@link arcade.core.env.lattice.Lattice} coordinates into a hexagonal
     * {@link arcade.core.env.grid.Grid} coordinate.
     *
     * @param coordinate the triangular coordinate
     * @return the corresponding hexagonal coordinate
     */
    public static CoordinateUVWZ translate(CoordinateXYZ coordinate) {
<span class="nc" id="L271">        int z = coordinate.z - depthBounds + 1;</span>
<span class="nc" id="L272">        int zo = (byte) ((Math.abs(heightOffset + z)) % 3);</span>

        // Calculate u coordinate.
<span class="nc bnc" id="L275" title="All 2 branches missed.">        double uu = (coordinate.x - (zo == 2 ? -1 : zo) + 2) / 3.0 - radiusBounds;</span>
<span class="nc" id="L276">        int u = Math.round(Math.round(uu));</span>

        // Calculate v and w coordinates based on u.
<span class="nc bnc" id="L279" title="All 2 branches missed.">        int vw = coordinate.y - 2 * radiusBounds + 2 - (zo == 0 ? 0 : 1);</span>
<span class="nc" id="L280">        int v = -(int) Math.floor((vw + u) / 2.0);</span>
<span class="nc" id="L281">        int w = -(u + v);</span>

        // Check if out of bounds.
<span class="nc bnc" id="L284" title="All 4 branches missed.">        if (Math.abs(v) &gt;= radius || Math.abs(w) &gt;= radius) {</span>
<span class="nc" id="L285">            return null;</span>
        }
<span class="nc" id="L287">        return new CoordinateUVWZ(u, v, w, z);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>