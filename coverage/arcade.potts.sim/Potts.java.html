<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Potts.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">arcade</a> &gt; <a href="index.source.html" class="el_package">arcade.potts.sim</a> &gt; <span class="el_source">Potts.java</span></div><h1>Potts.java</h1><pre class="source lang-java linenums">package arcade.potts.sim;

import java.util.ArrayList;
import java.util.HashSet;
import sim.engine.SimState;
import sim.engine.Steppable;
import ec.util.MersenneTwisterFast;
import arcade.core.env.grid.Grid;
import arcade.potts.agent.cell.PottsCell;
import arcade.potts.env.location.PottsLocation;
import arcade.potts.sim.hamiltonian.Hamiltonian;
import static arcade.potts.util.PottsEnums.Region;
import static arcade.potts.util.PottsEnums.Term;

/**
 * Cellular Potts Model (CPM) implementation.
 *
 * &lt;p&gt;The potts layer tracks cells in an array of ids that define the morphology of each cell
 * (alongside non-cell areas). The corresponding array of regions further defines regions within a
 * given cell.
 *
 * &lt;p&gt;The Hamiltonian, which decides which positions in the arrays are flipped, consists of a series
 * of terms including:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Cell to cell and cell to non-cell adhesion
 *   &lt;li&gt;Volume constraint between actual and target volume
 *   &lt;li&gt;Surface constraint between actual and target surface
 * &lt;/ul&gt;
 */
public abstract class Potts implements Steppable {
    /** Length (x direction) of potts array. */
    public final int length;

    /** Width (y direction) of potts array. */
    public final int width;

    /** Depth (z direction) of potts array. */
    public final int height;

    /** Number of steps in Monte Carlo Step. */
    final int steps;

    /** Effective cell temperature. */
    final double temperature;

    /** {@code true} if potts is single layer, {@code false} otherwise. */
    final boolean isSingle;

    /** {@code true} if cells have regions, {@code false} otherwise. */
    final boolean hasRegions;

    /** Potts array for ids. */
    public int[][][] ids;

    /** Potts array for regions. */
    public int[][][] regions;

    /** Grid holding cells. */
    Grid grid;

    /** List of Hamiltonian terms. */
    ArrayList&lt;Hamiltonian&gt; hamiltonian;

    /**
     * Creates a cellular {@code Potts} model.
     *
     * @param series the simulation series
     */
<span class="fc" id="L70">    public Potts(PottsSeries series) {</span>
        // Creates potts arrays.
<span class="fc" id="L72">        ids = new int[series.height][series.length][series.width];</span>
<span class="fc" id="L73">        regions = new int[series.height][series.length][series.width];</span>

        // Ensure a 1 voxel border around to avoid boundary checks.
<span class="fc" id="L76">        length = series.length - 2;</span>
<span class="fc" id="L77">        width = series.width - 2;</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">        height = (series.height == 1 ? 1 : series.height - 2);</span>

        // Number of Monte Carlo steps
<span class="fc" id="L81">        double mcs = series.potts.getDouble(&quot;MCS&quot;);</span>
<span class="fc" id="L82">        steps = (int) (mcs * length * width * height);</span>

        // Get temperature.
<span class="fc" id="L85">        temperature = series.potts.getDouble(&quot;TEMPERATURE&quot;);</span>

        // Check if potts is a single layer.
<span class="fc bfc" id="L88" title="All 2 branches covered.">        isSingle = series.height == 1;</span>

        // Check if there are regions.
<span class="fc" id="L91">        hasRegions =</span>
<span class="fc" id="L92">                series.populations.values().stream()</span>
<span class="fc" id="L93">                        .map(e -&gt; e.filter(&quot;(REGION)&quot;).getKeys().size())</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">                        .anyMatch(e -&gt; e &gt; 0);</span>

        // Initialize hamiltonian list.
<span class="fc" id="L97">        hamiltonian = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">        if (series.terms != null) {</span>
<span class="fc" id="L99">            series.terms.stream()</span>
<span class="fc" id="L100">                    .map(term -&gt; getHamiltonian(term, series))</span>
<span class="fc" id="L101">                    .forEach(h -&gt; hamiltonian.add(h));</span>
        }
<span class="fc" id="L103">    }</span>

    /**
     * Registers the cell to all Hamiltonian term instances.
     *
     * @param cell the cell instance
     */
    public void register(PottsCell cell) {
<span class="fc bfc" id="L111" title="All 2 branches covered.">        for (Hamiltonian h : hamiltonian) {</span>
<span class="fc" id="L112">            h.register(cell);</span>
<span class="fc" id="L113">        }</span>
<span class="fc" id="L114">    }</span>

    /**
     * Deregisters the cell from all Hamiltonian term instances.
     *
     * @param cell the cell instance
     */
    public void deregister(PottsCell cell) {
<span class="fc bfc" id="L122" title="All 2 branches covered.">        for (Hamiltonian h : hamiltonian) {</span>
<span class="fc" id="L123">            h.deregister(cell);</span>
<span class="fc" id="L124">        }</span>
<span class="fc" id="L125">    }</span>

    /**
     * Gets instance of selected Hamiltonian term.
     *
     * @param term the Hamiltonian term
     * @param series the simulation series
     * @return the Hamiltonian instance
     */
    abstract Hamiltonian getHamiltonian(Term term, PottsSeries series);

    /**
     * Steps through array updates for Monte Carlo step.
     *
     * @param simstate the MASON simulation state
     */
    @Override
    public void step(SimState simstate) {
<span class="fc" id="L143">        MersenneTwisterFast random = simstate.random;</span>
        double r;
        int x;
        int y;
        int z;

<span class="fc bfc" id="L149" title="All 2 branches covered.">        for (int step = 0; step &lt; steps; step++) {</span>
            // Get random coordinate for candidate.
<span class="fc" id="L151">            x = random.nextInt(length) + 1;</span>
<span class="fc" id="L152">            y = random.nextInt(width) + 1;</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">            z = (random.nextInt(height) + 1) * (isSingle ? 0 : 1);</span>
<span class="fc" id="L154">            r = random.nextDouble();</span>

            // Check if cell has regions.
<span class="fc bfc" id="L157" title="All 4 branches covered.">            boolean hasRegionsCell = (ids[z][x][y] != 0 &amp;&amp; getCell(ids[z][x][y]).hasRegions());</span>

            // Get unique targets.
<span class="fc" id="L160">            HashSet&lt;Integer&gt; uniqueIDTargets = getUniqueIDs(x, y, z);</span>
<span class="fc" id="L161">            HashSet&lt;Integer&gt; uniqueRegionTargets = getUniqueRegions(x, y, z);</span>

            // Check if there are valid unique targets.
<span class="fc bfc" id="L164" title="All 2 branches covered.">            boolean hasIDTargets = uniqueIDTargets.size() &gt; 0;</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">            boolean hasRegionTargets = uniqueRegionTargets.size() &gt; 0;</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">            boolean check = simstate.random.nextDouble() &lt; 0.5;</span>

            // Select unique ID or unique region (if they exist). If there is
            // a unique ID and unique region target, then randomly select. If
            // there are neither, then skip.
<span class="pc bpc" id="L171" title="3 of 8 branches missed.">            if (hasIDTargets &amp;&amp; (!hasRegionsCell || !hasRegionTargets || check)) {</span>
<span class="fc" id="L172">                int i = simstate.random.nextInt(uniqueIDTargets.size());</span>
<span class="fc" id="L173">                int targetID = (int) uniqueIDTargets.toArray()[i];</span>
<span class="fc" id="L174">                flip(ids[z][x][y], targetID, x, y, z, r);</span>
<span class="pc bpc" id="L175" title="1 of 4 branches missed.">            } else if (hasRegionsCell &amp;&amp; hasRegionTargets) {</span>
<span class="fc" id="L176">                int i = simstate.random.nextInt(uniqueRegionTargets.size());</span>
<span class="fc" id="L177">                int targetRegion = (int) uniqueRegionTargets.toArray()[i];</span>
<span class="fc" id="L178">                flip(ids[z][x][y], regions[z][x][y], targetRegion, x, y, z, r);</span>
            }
        }
<span class="fc" id="L181">    }</span>

    /**
     * Flips connected voxel from source to target id based on Boltzmann probability.
     *
     * @param sourceID the id of the source voxel
     * @param targetID the id of the target voxel
     * @param x the x coordinate
     * @param y the y coordinate
     * @param z the z coordinate
     * @param r a random number
     */
    void flip(int sourceID, int targetID, int x, int y, int z, double r) {
<span class="fc bfc" id="L194" title="All 2 branches covered.">        boolean zero = ids[z][x][y] == 0;</span>

        // Check connectivity of source.
<span class="fc bfc" id="L197" title="All 2 branches covered.">        if (sourceID &gt; 0) {</span>
<span class="fc" id="L198">            boolean[][][] neighborhood = getNeighborhood(sourceID, x, y, z);</span>
<span class="fc" id="L199">            boolean candidateConnected = getConnectivity(neighborhood, zero);</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">            if (!candidateConnected) {</span>
<span class="fc" id="L201">                return;</span>
            }

            // Check connectivity of regions.
<span class="fc bfc" id="L205" title="All 2 branches covered.">            if (regions[z][x][y] &gt; Region.DEFAULT.ordinal()) {</span>
<span class="fc" id="L206">                boolean[][][] rNeighborhood = getNeighborhood(sourceID, regions[z][x][y], x, y, z);</span>
<span class="fc" id="L207">                boolean candidateRegionConnected = getConnectivity(rNeighborhood, false);</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">                if (!candidateRegionConnected) {</span>
<span class="fc" id="L209">                    return;</span>
                }
            }
        }

        // Check connectivity of target.
<span class="fc bfc" id="L215" title="All 2 branches covered.">        if (targetID &gt; 0) {</span>
<span class="fc" id="L216">            boolean[][][] neighborhood = getNeighborhood(targetID, x, y, z);</span>
<span class="fc" id="L217">            boolean targetConnected = getConnectivity(neighborhood, zero);</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">            if (!targetConnected) {</span>
<span class="fc" id="L219">                return;</span>
            }

            // Check connectivity of regions.
<span class="fc bfc" id="L223" title="All 2 branches covered.">            if (regions[z][x][y] &gt; Region.DEFAULT.ordinal()) {</span>
<span class="fc" id="L224">                boolean[][][] rNeighborhood = getNeighborhood(targetID, regions[z][x][y], x, y, z);</span>
<span class="fc" id="L225">                boolean candidateRegionConnected = getConnectivity(rNeighborhood, false);</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">                if (!candidateRegionConnected) {</span>
<span class="fc" id="L227">                    return;</span>
                }
            }
        }

        // Change the voxel.
<span class="fc" id="L233">        change(sourceID, targetID, x, y, z, r);</span>
<span class="fc" id="L234">    }</span>

    /**
     * Calculates energy change to decide if a voxel is flipped.
     *
     * @param sourceID the id of the source voxel
     * @param targetID the id of the target voxel
     * @param x the x coordinate
     * @param y the y coordinate
     * @param z the z coordinate
     * @param r a random number
     */
    void change(int sourceID, int targetID, int x, int y, int z, double r) {
        // Calculate energy change.
<span class="fc" id="L248">        double dH = 0;</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">        for (Hamiltonian h : hamiltonian) {</span>
<span class="fc" id="L250">            dH += h.getDelta(sourceID, targetID, x, y, z);</span>
<span class="fc" id="L251">        }</span>

        // Calculate probability.
        double p;
<span class="fc bfc" id="L255" title="All 2 branches covered.">        if (dH &lt; 0) {</span>
<span class="fc" id="L256">            p = 1;</span>
        } else {
<span class="fc" id="L258">            p = Math.exp(-dH / temperature);</span>
        }

<span class="fc bfc" id="L261" title="All 2 branches covered.">        if (r &lt; p) {</span>
<span class="fc" id="L262">            ids[z][x][y] = targetID;</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">            if (hasRegions) {</span>
<span class="fc" id="L264">                regions[z][x][y] =</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">                        (targetID == 0 ? Region.UNDEFINED.ordinal() : Region.DEFAULT.ordinal());</span>
            }

<span class="fc bfc" id="L268" title="All 2 branches covered.">            if (sourceID &gt; 0) {</span>
<span class="fc" id="L269">                ((PottsLocation) getCell(sourceID).getLocation()).remove(x, y, z);</span>
            }
<span class="fc bfc" id="L271" title="All 2 branches covered.">            if (targetID &gt; 0) {</span>
<span class="fc" id="L272">                ((PottsLocation) getCell(targetID).getLocation()).add(x, y, z);</span>
            }
        }
<span class="fc" id="L275">    }</span>

    /**
     * Flips connected voxel from source to target region based on Boltzmann probability.
     *
     * @param id the voxel id
     * @param sourceRegion the region of the source voxel
     * @param targetRegion the region of the target voxel
     * @param x the x coordinate
     * @param y the y coordinate
     * @param z the z coordinate
     * @param r a random number
     */
    void flip(int id, int sourceRegion, int targetRegion, int x, int y, int z, double r) {
<span class="fc bfc" id="L289" title="All 2 branches covered.">        boolean zero = regions[z][x][y] == Region.DEFAULT.ordinal();</span>

        // Check connectivity of source.
<span class="fc bfc" id="L292" title="All 2 branches covered.">        if (sourceRegion &gt; Region.DEFAULT.ordinal()) {</span>
<span class="fc" id="L293">            boolean[][][] neighborhood = getNeighborhood(id, sourceRegion, x, y, z);</span>
<span class="fc" id="L294">            boolean candidateConnected = getConnectivity(neighborhood, zero);</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">            if (!candidateConnected) {</span>
<span class="fc" id="L296">                return;</span>
            }
        }

        // Check connectivity of target.
<span class="fc bfc" id="L301" title="All 2 branches covered.">        if (targetRegion &gt; Region.DEFAULT.ordinal()) {</span>
<span class="fc" id="L302">            boolean[][][] neighborhood = getNeighborhood(id, targetRegion, x, y, z);</span>
<span class="fc" id="L303">            boolean targetConnected = getConnectivity(neighborhood, zero);</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">            if (!targetConnected) {</span>
<span class="fc" id="L305">                return;</span>
            }
        }

        // Change the voxel region.
<span class="fc" id="L310">        change(id, sourceRegion, targetRegion, x, y, z, r);</span>
<span class="fc" id="L311">    }</span>

    /**
     * Calculates energy change to decide if a voxel region is flipped.
     *
     * @param id the voxel id
     * @param sourceRegion the region of the source voxel
     * @param targetRegion the region of the target voxel
     * @param x the x coordinate
     * @param y the y coordinate
     * @param z the z coordinate
     * @param r a random number
     */
    void change(int id, int sourceRegion, int targetRegion, int x, int y, int z, double r) {
        // Calculate energy change.
<span class="fc" id="L326">        double dH = 0;</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">        for (Hamiltonian h : hamiltonian) {</span>
<span class="fc" id="L328">            dH += h.getDelta(id, sourceRegion, targetRegion, x, y, z);</span>
<span class="fc" id="L329">        }</span>

        // Calculate probability.
        double p;
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (dH &lt; 0) {</span>
<span class="fc" id="L334">            p = 1;</span>
        } else {
<span class="fc" id="L336">            p = Math.exp(-dH / temperature);</span>
        }

<span class="fc bfc" id="L339" title="All 2 branches covered.">        if (r &lt; p) {</span>
<span class="fc" id="L340">            regions[z][x][y] = targetRegion;</span>
<span class="fc" id="L341">            PottsCell c = getCell(id);</span>
<span class="fc" id="L342">            ((PottsLocation) c.getLocation()).remove(Region.values()[sourceRegion], x, y, z);</span>
<span class="fc" id="L343">            ((PottsLocation) c.getLocation()).add(Region.values()[targetRegion], x, y, z);</span>
        }
<span class="fc" id="L345">    }</span>

    /**
     * Gets the {@link PottsCell} object for the given id.
     *
     * @param id the cell id
     * @return the {@link PottsCell} object, {@code null} if id is zero
     */
    public PottsCell getCell(int id) {
<span class="fc bfc" id="L354" title="All 2 branches covered.">        if (id &gt; 0) {</span>
<span class="fc" id="L355">            return (PottsCell) grid.getObjectAt(id);</span>
        } else {
<span class="fc" id="L357">            return null;</span>
        }
    }

    /**
     * Gets neighborhood for the given voxel.
     *
     * @param id the voxel id
     * @param x the x coordinate
     * @param y the y coordinate
     * @param z the z coordinate
     * @return {@code true} if simply connected, {@code false} otherwise
     */
    abstract boolean[][][] getNeighborhood(int id, int x, int y, int z);

    /**
     * Gets neighborhood for the given voxel region.
     *
     * @param id the voxel id
     * @param region the voxel region
     * @param x the x coordinate
     * @param y the y coordinate
     * @param z the z coordinate
     * @return {@code true} if simply connected, {@code false} otherwise
     */
    abstract boolean[][][] getNeighborhood(int id, int region, int x, int y, int z);

    /**
     * Determines connectivity of given neighborhood.
     *
     * @param array the array of neighbors
     * @param zero {@code true} if location has zero id, {@code false} otherwise
     * @return {@code true} if simply connected, {@code false} otherwise
     */
    abstract boolean getConnectivity(boolean[][][] array, boolean zero);

    /**
     * Gets unique IDs adjacent to given voxel.
     *
     * @param x the x coordinate
     * @param y the y coordinate
     * @param z the z coordinate
     * @return the list of unique IDs
     */
    abstract HashSet&lt;Integer&gt; getUniqueIDs(int x, int y, int z);

    /**
     * Gets unique regions adjacent to given voxel.
     *
     * @param x the x coordinate
     * @param y the y coordinate
     * @param z the z coordinate
     * @return the list of unique regions
     */
    abstract HashSet&lt;Integer&gt; getUniqueRegions(int x, int y, int z);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>