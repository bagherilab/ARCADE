<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PottsLocation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">arcade</a> &gt; <a href="index.source.html" class="el_package">arcade.potts.env.location</a> &gt; <span class="el_source">PottsLocation.java</span></div><h1>PottsLocation.java</h1><pre class="source lang-java linenums">package arcade.potts.env.location;

import java.util.ArrayList;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.LinkedHashSet;
import sim.util.Double3D;
import ec.util.MersenneTwisterFast;
import arcade.core.env.location.Location;
import arcade.core.env.location.LocationContainer;
import arcade.core.util.Plane;
import arcade.core.util.Utilities;
import arcade.core.util.Vector;
import arcade.potts.util.PottsEnums.Direction;
import arcade.potts.util.PottsEnums.Region;
import static arcade.potts.util.PottsEnums.Direction;
import static arcade.potts.util.PottsEnums.Region;

/**
 * Abstract implementation of {@link Location} for potts models.
 *
 * &lt;p&gt;{@code PottsLocation} objects manage the a list of associated {@link Voxel} objects that
 * comprise the location. These voxels are represented as an array in the {@link
 * arcade.potts.sim.Potts} layer and the two representations are kept in sync.
 *
 * &lt;p&gt;Concrete implementations of {@code PottsLocation} manage the dimensionality of the voxels.
 *
 * &lt;p&gt;{@code PottsLocation} also provides several general static methods for manipulating voxel
 * lists:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;strong&gt;Split&lt;/strong&gt; voxel list along a given direction
 *   &lt;li&gt;&lt;strong&gt;Connect&lt;/strong&gt; voxels to ensure that each list contains connected voxels
 *   &lt;li&gt;&lt;strong&gt;Balance&lt;/strong&gt; voxels between two lists to ensure they have a similar number of
 *       voxels
 *   &lt;li&gt;&lt;strong&gt;Check&lt;/strong&gt; voxels for connectedness
 * &lt;/ul&gt;
 */
public abstract class PottsLocation implements Location {
    /** Relative difference between split voxel numbers. */
    private static final double BALANCE_DIFFERENCE = 0.05;

    /** Relative padding for selecting maximum diameter. */
    private static final double DIAMETER_RATIO = 0.9;

    /** Default probability first voxel list is kept in split function. */
    private static final double DEFAULT_SPLIT_SELECTION_PROBABILITY = 0.5;

    /** List of voxels for the location. */
    final ArrayList&lt;Voxel&gt; voxels;

    /** Location volume. */
    int volume;

    /** Location surface. */
    int surface;

    /** Location height. */
    int height;

    /** X position of center. */
    double cx;

    /** Y position of center. */
    double cy;

    /** Z position of center. */
    double cz;

    /**
     * Creates a {@code PottsLocation} for a list of voxels.
     *
     * @param voxels the list of voxels
     */
<span class="fc" id="L75">    public PottsLocation(ArrayList&lt;Voxel&gt; voxels) {</span>
<span class="fc" id="L76">        this.voxels = new ArrayList&lt;&gt;(voxels);</span>
<span class="fc" id="L77">        setAttributes();</span>
<span class="fc" id="L78">    }</span>

    /** Sets the {@code PottsLocation} attributes. */
    public void setAttributes() {
<span class="fc" id="L82">        this.volume = voxels.size();</span>
<span class="fc" id="L83">        this.surface = calculateSurface();</span>
<span class="fc" id="L84">        this.height = calculateHeight();</span>
<span class="fc" id="L85">        calculateCenter();</span>
<span class="fc" id="L86">    }</span>

    /**
     * Gets all voxels.
     *
     * @return the list of voxels
     */
    public ArrayList&lt;Voxel&gt; getVoxels() {
<span class="fc" id="L94">        return new ArrayList&lt;&gt;(voxels);</span>
    }

    /**
     * Gets all voxels for a region.
     *
     * @param region the region
     * @return the list of reqion voxels
     */
    public ArrayList&lt;Voxel&gt; getVoxels(Region region) {
<span class="fc" id="L104">        return new ArrayList&lt;&gt;();</span>
    }

    /**
     * Gets a set of regions.
     *
     * @return the set of regions
     */
    public EnumSet&lt;Region&gt; getRegions() {
<span class="fc" id="L113">        return null;</span>
    }

    @Override
    public final double getVolume() {
<span class="fc" id="L118">        return volume;</span>
    }

    /**
     * Gets the volume of the location for a given region.
     *
     * @param region the region
     * @return the location region volume
     */
    public double getVolume(Region region) {
<span class="fc" id="L128">        return getVolume();</span>
    }

    @Override
    public final double getSurface() {
<span class="fc" id="L133">        return surface;</span>
    }

    /**
     * Gets the surface area of the location for a given region.
     *
     * @param region the region
     * @return the location region surface area
     */
    public double getSurface(Region region) {
<span class="fc" id="L143">        return getSurface();</span>
    }

    @Override
    public final double getHeight() {
<span class="fc" id="L148">        return height;</span>
    }

    /**
     * Gets the height of the location for a given region.
     *
     * @param region the region
     * @return the location height
     */
    public double getHeight(Region region) {
<span class="fc" id="L158">        return getHeight();</span>
    }

    /**
     * Adds a voxel at the given coordinates.
     *
     * @param x the x coordinate
     * @param y the y coordinate
     * @param z the z coordinate
     */
    public void add(int x, int y, int z) {
<span class="fc" id="L169">        Voxel voxel = new Voxel(x, y, z);</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">        if (!voxels.contains(voxel)) {</span>
<span class="fc" id="L171">            voxels.add(voxel);</span>
<span class="fc" id="L172">            volume++;</span>
<span class="fc" id="L173">            surface += updateSurface(voxel);</span>
<span class="fc" id="L174">            height += updateHeight(voxel);</span>
<span class="fc" id="L175">            updateCenter(x, y, z, 1);</span>
        }
<span class="fc" id="L177">    }</span>

    /**
     * Adds a voxel at the given coordinates for given region.
     *
     * @param region the voxel region
     * @param x the x coordinate
     * @param y the y coordinate
     * @param z the z coordinate
     */
    public void add(Region region, int x, int y, int z) {
<span class="fc" id="L188">        add(x, y, z);</span>
<span class="fc" id="L189">    }</span>

    /**
     * Removes the voxel at the given coordinates.
     *
     * @param x the x coordinate
     * @param y the y coordinate
     * @param z the z coordinate
     */
    public void remove(int x, int y, int z) {
<span class="fc" id="L199">        Voxel voxel = new Voxel(x, y, z);</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">        if (voxels.contains(voxel)) {</span>
<span class="fc" id="L201">            voxels.remove(voxel);</span>
<span class="fc" id="L202">            volume--;</span>
<span class="fc" id="L203">            surface -= updateSurface(voxel);</span>
<span class="fc" id="L204">            height -= updateHeight(voxel);</span>
<span class="fc" id="L205">            updateCenter(x, y, z, -1);</span>
        }
<span class="fc" id="L207">    }</span>

    /**
     * Removes the voxel at the given coordinates for given region.
     *
     * @param region the voxel region
     * @param x the x coordinate
     * @param y the y coordinate
     * @param z the z coordinate
     */
    public void remove(Region region, int x, int y, int z) {
<span class="fc" id="L218">        remove(x, y, z);</span>
<span class="fc" id="L219">    }</span>

    /**
     * Assigns the voxel at the given coordinates to the given region.
     *
     * @param region the voxel region
     * @param voxel the voxel to assign
     */
<span class="fc" id="L227">    public void assign(Region region, Voxel voxel) {}</span>

    /**
     * Assigns target number of voxels to given region.
     *
     * @param region the region to assign
     * @param target the target number of voxels to assign
     * @param random the seeded random number generator
     */
<span class="fc" id="L236">    public void distribute(Region region, int target, MersenneTwisterFast random) {}</span>

    /**
     * Finds the closest voxel that exists in the location.
     *
     * @param voxel the starting voxel
     * @return the closest voxel or the starting voxel if it exists
     */
    public Voxel adjust(Voxel voxel) {
<span class="fc bfc" id="L245" title="All 2 branches covered.">        if (voxels.contains(voxel)) {</span>
<span class="fc" id="L246">            return voxel;</span>
        }

<span class="fc" id="L249">        int x = voxel.x;</span>
<span class="fc" id="L250">        int y = voxel.y;</span>
<span class="fc" id="L251">        int z = voxel.z;</span>

<span class="fc" id="L253">        double minimumDistance = Double.MAX_VALUE;</span>

<span class="fc bfc" id="L255" title="All 2 branches covered.">        for (Voxel v : voxels) {</span>
<span class="fc" id="L256">            double distance =</span>
<span class="fc" id="L257">                    Math.sqrt(Math.pow(v.x - x, 2) + Math.pow(v.y - y, 2) + Math.pow(v.z - z, 2));</span>

<span class="fc bfc" id="L259" title="All 2 branches covered.">            if (distance &lt; minimumDistance) {</span>
<span class="fc" id="L260">                minimumDistance = distance;</span>
<span class="fc" id="L261">                voxel = v;</span>
            }
<span class="fc" id="L263">        }</span>

<span class="fc" id="L265">        return voxel;</span>
    }

    /**
     * Clears all voxel lists and arrays.
     *
     * @param ids the potts array for ids
     * @param regions the potts array for regions
     */
    public void clear(int[][][] ids, int[][][] regions) {
<span class="fc" id="L275">        voxels.forEach(voxel -&gt; ids[voxel.z][voxel.x][voxel.y] = 0);</span>
<span class="fc" id="L276">        voxels.clear();</span>
<span class="fc" id="L277">    }</span>

    /**
     * Updates the array for the location.
     *
     * @param id the location id
     * @param ids the potts array for ids
     * @param regions the potts array for regions
     */
    public void update(int id, int[][][] ids, int[][][] regions) {
<span class="fc" id="L287">        voxels.forEach(voxel -&gt; ids[voxel.z][voxel.x][voxel.y] = id);</span>
<span class="fc" id="L288">    }</span>

    /**
     * Splits location voxels into two approximately equal lists.
     *
     * &lt;p&gt;The location is split along the direction with the shortest diameter. The lists of
     * locations are guaranteed to be connected, and generally will be balanced in size. One of the
     * splits is assigned to the current location and the other is returned.
     *
     * @param random the seeded random number generator
     * @return a location with the split voxels
     */
    public Location split(MersenneTwisterFast random) {
<span class="fc" id="L301">        Voxel centerVoxel = getCenter();</span>
<span class="fc" id="L302">        Plane divisionPlane =</span>
                new Plane(
                        new Double3D(centerVoxel.x, centerVoxel.y, centerVoxel.z),
<span class="fc" id="L305">                        getDirection(random).vector);</span>
<span class="fc" id="L306">        return split(random, divisionPlane, DEFAULT_SPLIT_SELECTION_PROBABILITY);</span>
    }

    /**
     * Splits location voxels into two lists with given offset.
     *
     * &lt;p&gt;The location is split at the point specified by offsets along the direction with the
     * shortest diameter. The lists of locations are guaranteed to be connected. One of the splits
     * is assigned to the current location and the other is returned.
     *
     * @param random the seeded random number generator
     * @param offsets the percentage offset in each direction for split point
     * @return a location with the split voxels
     */
    public Location split(MersenneTwisterFast random, ArrayList&lt;Integer&gt; offsets) {
<span class="fc" id="L321">        Voxel offsetVoxel = getOffset(offsets);</span>
<span class="fc" id="L322">        Plane divisionPlane =</span>
                new Plane(
                        new Double3D(offsetVoxel.x, offsetVoxel.y, offsetVoxel.z),
<span class="fc" id="L325">                        getDirection(random).vector);</span>
<span class="fc" id="L326">        return split(random, divisionPlane, DEFAULT_SPLIT_SELECTION_PROBABILITY);</span>
    }

    /**
     * Splits location voxels into two lists with given offset, direction, and probability.
     *
     * &lt;p&gt;The location is split at the point specified by offsets along the given direction. The
     * lists of locations are guaranteed to be connected. One of the splits is assigned to the
     * current location and the other is returned.
     *
     * @param random the seeded random number generator
     * @param offsets the percentage offset in each direction for split point
     * @param direction the direction of the split
     * @param probability the probability to decide which split to return
     * @return a location with the split voxels
     */
    public Location split(
            MersenneTwisterFast random,
            ArrayList&lt;Integer&gt; offsets,
            Direction direction,
            Double probability) {
<span class="fc" id="L347">        Voxel offVoxel = getOffset(offsets);</span>
<span class="fc" id="L348">        Plane divisionPlane =</span>
                new Plane(new Double3D(offVoxel.x, offVoxel.y, offVoxel.z), direction.vector);
<span class="fc" id="L350">        return split(random, divisionPlane, probability);</span>
    }

    /**
     * Splits location voxels into two lists.
     *
     * &lt;p&gt;The location is split along the provided plane. One of the splits is assigned to the
     * current location and the other is returned with the default split probability.
     *
     * @param random the seeded random number generator
     * @param plane the plane of the split
     * @return a location with the split voxels
     */
    public Location split(MersenneTwisterFast random, Plane plane) {
<span class="fc" id="L364">        return split(random, plane, DEFAULT_SPLIT_SELECTION_PROBABILITY);</span>
    }

    /**
     * Splits location voxels into two lists.
     *
     * &lt;p&gt;The location is split along the provided plane. One of the splits is assigned to the
     * current location and the other is returned with the given probability.
     *
     * &lt;p&gt;If the plane of division is through the center of the location, the resulting lists are
     * guaranteed to be connected, and generally will be balanced in size. If the plane of division
     * is not through the center of the location, the resulting lists are guaranteed to be connected
     * but will not necessarily be balanced in size.
     *
     * @param random the seeded random number generator
     * @param plane the plane of the split
     * @param probability the probability to decide which split to return
     * @return a location with the split voxels
     */
    public Location split(MersenneTwisterFast random, Plane plane, Double probability) {
        // Initialize lists of split voxels
<span class="fc" id="L385">        ArrayList&lt;Voxel&gt; voxelsA = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L386">        ArrayList&lt;Voxel&gt; voxelsB = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L388">        splitVoxels(plane, voxels, voxelsA, voxelsB, random);</span>
<span class="fc" id="L389">        connectVoxels(voxelsA, voxelsB, this, random);</span>

<span class="fc" id="L391">        Voxel locCenter = getCenter();</span>
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">        if (plane.getReferencePoint().equals(locCenter)) {</span>
<span class="nc" id="L393">            balanceVoxels(voxelsA, voxelsB, this, random);</span>
        }

        // Use the user-specified or default probability to determine the split
<span class="fc bfc" id="L397" title="All 2 branches covered.">        return random.nextDouble() &lt; probability</span>
<span class="fc" id="L398">                ? separateVoxels(voxelsA, voxelsB, random)</span>
<span class="fc" id="L399">                : separateVoxels(voxelsB, voxelsA, random);</span>
    }

    /**
     * Gets the voxel at the center of the location.
     *
     * &lt;p&gt;The center voxel is not guaranteed to exist in the location. If the center voxel must
     * exist, use {@code adjust()} to get the closest voxel that exists.
     *
     * @return the center voxel, returns {@code null} if there are no voxels
     */
    public Voxel getCenter() {
<span class="fc bfc" id="L411" title="All 2 branches covered.">        if (voxels.size() == 0) {</span>
<span class="fc" id="L412">            return null;</span>
        }

<span class="fc" id="L415">        int x = (int) Math.round(cx);</span>
<span class="fc" id="L416">        int y = (int) Math.round(cy);</span>
<span class="fc" id="L417">        int z = (int) Math.round(cz);</span>

<span class="fc" id="L419">        return new Voxel(x, y, z);</span>
    }

    /**
     * Calculates the voxel at specified offsets from location bounds.
     *
     * &lt;p&gt;The voxel position is calculated as percentage offsets using the minimum and maximum
     * bounds of the current location in the X, Y, and Z dimensions. Offsets should be passed as
     * percentages in the range [0, 100]. Offsets may be given as one percentage N1 (interpreted as
     * [x = N, y = N, z = N]), two percentages N1 and N2 (interpreted as [x = N1, y = N2, z = 0]),
     * or three percentages N1, N2, and N3 (interpreted as [x = N1, y = N2, z = N3]).
     *
     * &lt;p&gt;For example, offsets of [50, 50, 50] will return the voxel located 50% between the minimum
     * and maximum in each direction. Note that [50, 50, 50] is not necessarily equivalent to the
     * center of the location, which is calculated as the arithmetic mean in each direction. To get
     * the center, use {@code getCenter()} instead.
     *
     * &lt;p&gt;The voxel is not guaranteed to exist in the location. If the voxel must exist, use {@code
     * adjust()} to get the closest voxel that exists.
     *
     * @param offsets the percentage offset in each direction for split point
     * @return the offset voxel, returns {@code null} if there are no voxels
     */
    public Voxel getOffset(ArrayList&lt;Integer&gt; offsets) {
<span class="fc bfc" id="L443" title="All 2 branches covered.">        if (voxels.size() == 0) {</span>
<span class="fc" id="L444">            return null;</span>
        }

<span class="fc bfc" id="L447" title="All 6 branches covered.">        if (offsets == null || offsets.size() == 0 || offsets.size() &gt; 3) {</span>
<span class="fc" id="L448">            throw new IllegalArgumentException(</span>
                    &quot;Offsets must be an ArrayList containing exactly 1, 2 or 3 integers.&quot;);
        }

<span class="fc bfc" id="L452" title="All 2 branches covered.">        if (offsets.size() == 1) {</span>
<span class="fc" id="L453">            offsets.add(offsets.get(0));</span>
<span class="fc" id="L454">            offsets.add(offsets.get(1));</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">        } else if (offsets.size() == 2) {</span>
<span class="fc" id="L456">            offsets.add(0);</span>
        }

<span class="fc" id="L459">        int minX = voxels.stream().mapToInt(voxel -&gt; voxel.x).min().getAsInt();</span>
<span class="fc" id="L460">        int maxX = voxels.stream().mapToInt(voxel -&gt; voxel.x).max().getAsInt();</span>
<span class="fc" id="L461">        int minY = voxels.stream().mapToInt(voxel -&gt; voxel.y).min().getAsInt();</span>
<span class="fc" id="L462">        int maxY = voxels.stream().mapToInt(voxel -&gt; voxel.y).max().getAsInt();</span>
<span class="fc" id="L463">        int minZ = voxels.stream().mapToInt(voxel -&gt; voxel.z).min().getAsInt();</span>
<span class="fc" id="L464">        int maxZ = voxels.stream().mapToInt(voxel -&gt; voxel.z).max().getAsInt();</span>

<span class="fc" id="L466">        int offsetX = (int) Math.round(minX + (maxX - minX) * (offsets.get(0) / 100.0));</span>
<span class="fc" id="L467">        int offsetY = (int) Math.round(minY + (maxY - minY) * (offsets.get(1) / 100.0));</span>
<span class="fc" id="L468">        int offsetZ = (int) Math.round(minZ + (maxZ - minZ) * (offsets.get(2) / 100.0));</span>

<span class="fc" id="L470">        return new Voxel(offsetX, offsetY, offsetZ);</span>
    }

    /**
     * Gets the centroid of the location.
     *
     * &lt;p&gt;Note that centroid positions may not be integer values. If a specific center voxel is
     * needed, use {@code getCenter()} instead.
     *
     * @return the location centroid
     */
    public double[] getCentroid() {
<span class="fc" id="L482">        return new double[] {cx, cy, cz};</span>
    }

    /**
     * Gets the centroid of the location for the region.
     *
     * &lt;p&gt;Note that centroid positions may not be integer values. If a specific center voxel is
     * needed, use {@code getCenter()} instead.
     *
     * @param region the voxel region
     * @return the location centroid
     */
    public double[] getCentroid(Region region) {
<span class="fc" id="L495">        return getCentroid();</span>
    }

    /** Calculates the exact center of the location. */
    void calculateCenter() {
<span class="fc bfc" id="L500" title="All 2 branches covered.">        if (voxels.size() == 0) {</span>
<span class="fc" id="L501">            cx = 0;</span>
<span class="fc" id="L502">            cy = 0;</span>
<span class="fc" id="L503">            cx = 0;</span>
        } else {
<span class="fc" id="L505">            cx = voxels.stream().mapToDouble(voxel -&gt; voxel.x).sum() / voxels.size();</span>
<span class="fc" id="L506">            cy = voxels.stream().mapToDouble(voxel -&gt; voxel.y).sum() / voxels.size();</span>
<span class="fc" id="L507">            cz = voxels.stream().mapToDouble(voxel -&gt; voxel.z).sum() / voxels.size();</span>
        }
<span class="fc" id="L509">    }</span>

    /**
     * Updates the centroid of the location.
     *
     * @param x the x position of the changed voxel
     * @param y the y position of the changed voxel
     * @param z the z position of the changed voxel
     * @param change the direction of change (add = +1, remove = -1)
     */
    void updateCenter(int x, int y, int z, int change) {
<span class="fc bfc" id="L520" title="All 2 branches covered.">        if (voxels.size() == 0) {</span>
<span class="fc" id="L521">            cx = 0;</span>
<span class="fc" id="L522">            cy = 0;</span>
<span class="fc" id="L523">            cz = 0;</span>
        } else {
<span class="fc" id="L525">            cx = (cx * (volume - change) + change * x) / volume;</span>
<span class="fc" id="L526">            cy = (cy * (volume - change) + change * y) / volume;</span>
<span class="fc" id="L527">            cz = (cz * (volume - change) + change * z) / volume;</span>
        }
<span class="fc" id="L529">    }</span>

    /**
     * Makes a new {@code PottsLocation} with the given voxels.
     *
     * @param voxels the list of voxels
     * @return a new {@code PottsLocation}
     */
    abstract PottsLocation makeLocation(ArrayList&lt;Voxel&gt; voxels);

    /**
     * Converts volume and height to surface area.
     *
     * @param volume the volume
     * @param height the height
     * @return the surface area
     */
    public abstract double convertSurface(double volume, double height);

    /**
     * Calculates surface of location.
     *
     * @return the surface
     */
    abstract int calculateSurface();

    /**
     * Calculates the local change in surface of the location.
     *
     * @param voxel the voxel the update is centered in
     * @return the change in surface
     */
    abstract int updateSurface(Voxel voxel);

    /**
     * Calculates height of location.
     *
     * @return the height
     */
    abstract int calculateHeight();

    /**
     * Calculates the local change in height of the location.
     *
     * @param voxel the voxel the update is centered in
     * @return the change in height
     */
    abstract int updateHeight(Voxel voxel);

    /**
     * Gets list of neighbors of a given voxel.
     *
     * @param focus the focus voxel
     * @return the list of neighbor voxels
     */
    abstract ArrayList&lt;Voxel&gt; getNeighbors(Voxel focus);

    /**
     * Calculates diameters in each direction.
     *
     * @return the map of direction to diameter
     */
    abstract HashMap&lt;Direction, Integer&gt; getDiameters();

    /**
     * Selects the slice direction for a given maximum diameter direction.
     *
     * @param direction the direction of the minimum diameter
     * @param diameters the list of diameters
     * @return the slice direction
     */
    abstract Direction getSlice(Direction direction, HashMap&lt;Direction, Integer&gt; diameters);

    /**
     * Selects specified number of voxels from a focus voxel.
     *
     * @param focus the focus voxel
     * @param n the number of voxels to select
     * @return the list of selected voxels
     */
    abstract ArrayList&lt;Voxel&gt; getSelected(Voxel focus, double n);

    /**
     * Gets the voxel at specified percentage offsets along the location's axes with the provided
     * ApicalAxis considered to be pointing up the Y axis.
     *
     * @param offsets the percent offsets along the location's axes
     * @param apicalAxis the axis considered to be pointing up along the Y axis
     * @return the voxel at the specified offset in the frame of the apical axis
     */
    abstract Voxel getOffsetInApicalFrame(ArrayList&lt;Integer&gt; offsets, Vector apicalAxis);

    /**
     * Gets the direction of the slice orthagonal to the direction with the smallest diameter.
     *
     * @param random the seeded random number generator
     * @return the direction of the slice
     */
    Direction getDirection(MersenneTwisterFast random) {
<span class="fc" id="L628">        HashMap&lt;Direction, Integer&gt; diameters = getDiameters();</span>
<span class="fc" id="L629">        ArrayList&lt;Direction&gt; directions = new ArrayList&lt;&gt;();</span>

        // Determine maximum diameter.
        int diameter;
<span class="fc" id="L633">        int maximumDiameter = 0;</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">        for (Direction direction : Direction.values()) {</span>
<span class="fc" id="L635">            diameter = diameters.getOrDefault(direction, 0);</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">            if (diameter &gt; maximumDiameter) {</span>
<span class="fc" id="L637">                maximumDiameter = diameter;</span>
            }
        }

        // Find all directions with the maximum diameter.
<span class="fc bfc" id="L642" title="All 2 branches covered.">        for (Direction direction : Direction.values()) {</span>
<span class="fc" id="L643">            diameter = diameters.getOrDefault(direction, 0);</span>
<span class="fc bfc" id="L644" title="All 2 branches covered.">            if (diameter &gt;= DIAMETER_RATIO * maximumDiameter) {</span>
<span class="fc" id="L645">                directions.add(direction);</span>
            }
        }

        // Randomly select one direction with the minimum diameter.
<span class="fc" id="L650">        Direction d = directions.get(random.nextInt(directions.size()));</span>

        // Convert diameter direction to slice direction.
<span class="fc bfc" id="L653" title="All 2 branches covered.">        return (d == Direction.UNDEFINED ? Direction.random(random) : getSlice(d, diameters));</span>
    }

    @Override
    public LocationContainer convert(int id) {
<span class="fc" id="L658">        return new PottsLocationContainer(id, getCenter(), voxels);</span>
    }

    /**
     * Separates the voxels in the list between this location and a new location.
     *
     * @param voxelsA the list of voxels for this location
     * @param voxelsB the list of voxels for the split location
     * @param random the seeded random number generator
     * @return a {@link arcade.core.env.location.Location} object with split voxels
     */
    Location separateVoxels(
            ArrayList&lt;Voxel&gt; voxelsA, ArrayList&lt;Voxel&gt; voxelsB, MersenneTwisterFast random) {
<span class="fc" id="L671">        voxels.clear();</span>
<span class="fc" id="L672">        voxels.addAll(voxelsA);</span>
<span class="fc" id="L673">        volume = voxels.size();</span>
<span class="fc" id="L674">        surface = calculateSurface();</span>
<span class="fc" id="L675">        height = calculateHeight();</span>
<span class="fc" id="L676">        calculateCenter();</span>
<span class="fc" id="L677">        return makeLocation(voxelsB);</span>
    }

    /**
     * Swaps the voxels in two locations and updates each location's size, surface, height, and
     * center attributes.
     *
     * @param location1 one location to swap
     * @param location2 the other location to swap
     */
    public static void swapVoxels(PottsLocation location1, PottsLocation location2) {
<span class="fc" id="L688">        ArrayList&lt;Voxel&gt; tempVoxelList = new ArrayList&lt;Voxel&gt;();</span>
<span class="fc" id="L689">        tempVoxelList.addAll(location1.voxels);</span>
<span class="fc" id="L690">        location1.voxels.clear();</span>
<span class="fc" id="L691">        location1.voxels.addAll(location2.voxels);</span>
<span class="fc" id="L692">        location2.voxels.clear();</span>
<span class="fc" id="L693">        location2.voxels.addAll(tempVoxelList);</span>
<span class="fc" id="L694">        location1.setAttributes();</span>
<span class="fc" id="L695">        location2.setAttributes();</span>
<span class="fc" id="L696">    }</span>

    /**
     * Splits the voxels in the location into two lists along a given plane.
     *
     * &lt;p&gt;The voxels are split into two lists based on their position relative to the plane. Voxels
     * on the plane are randomly assigned to one of the lists.
     *
     * @param plane the plane to split the voxels along
     * @param voxels the list of voxels to split
     * @param voxelsA list of voxels on side of plane the opposite the normal
     * @param voxelsB list of voxels on side of plane the same as the normal
     * @param random the seeded random number generator
     */
    static void splitVoxels(
            Plane plane,
            ArrayList&lt;Voxel&gt; voxels,
            ArrayList&lt;Voxel&gt; voxelsA,
            ArrayList&lt;Voxel&gt; voxelsB,
            MersenneTwisterFast random) {
<span class="fc bfc" id="L716" title="All 2 branches covered.">        for (Voxel voxel : voxels) {</span>
<span class="fc" id="L717">            double distance = plane.signedDistanceToPlane(new Double3D(voxel.x, voxel.y, voxel.z));</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">            if (distance &lt; 0) {</span>
<span class="fc" id="L719">                voxelsA.add(voxel);</span>
<span class="fc bfc" id="L720" title="All 2 branches covered.">            } else if (distance &gt; 0) {</span>
<span class="fc" id="L721">                voxelsB.add(voxel);</span>
            } else {
<span class="fc bfc" id="L723" title="All 2 branches covered.">                if (random.nextDouble() &gt; 0.5) {</span>
<span class="fc" id="L724">                    voxelsA.add(voxel);</span>
                } else {
<span class="fc" id="L726">                    voxelsB.add(voxel);</span>
                }
            }
<span class="fc" id="L729">        }</span>
<span class="fc" id="L730">    }</span>

    /**
     * Connects voxels in the splits.
     *
     * &lt;p&gt;Checks that the voxels in each split are connected. If not, then move the unconnected
     * voxels into the other split.
     *
     * @param voxelsA the list for the first half of the split
     * @param voxelsB the list for the second half of the split
     * @param location the location instance
     * @param random the seeded random number generator
     */
    static void connectVoxels(
            ArrayList&lt;Voxel&gt; voxelsA,
            ArrayList&lt;Voxel&gt; voxelsB,
            PottsLocation location,
            MersenneTwisterFast random) {
        // Check that both coordinate lists are simply connected.
<span class="fc" id="L749">        ArrayList&lt;Voxel&gt; unconnectedA = checkVoxels(voxelsA, location, random, true);</span>
<span class="fc" id="L750">        ArrayList&lt;Voxel&gt; unconnectedB = checkVoxels(voxelsB, location, random, true);</span>

        // If either coordinate list is not connected, attempt to connect them
        // by adding in the unconnected coordinates of the other list.
<span class="fc bfc" id="L754" title="All 4 branches covered.">        while (unconnectedA != null || unconnectedB != null) {</span>
            ArrayList&lt;Voxel&gt; unconnectedAB;
            ArrayList&lt;Voxel&gt; unconnectedBA;

<span class="fc bfc" id="L758" title="All 2 branches covered.">            if (unconnectedA != null) {</span>
<span class="fc" id="L759">                voxelsB.addAll(unconnectedA);</span>
            }
<span class="fc" id="L761">            unconnectedBA = checkVoxels(voxelsB, location, random, true);</span>

<span class="fc bfc" id="L763" title="All 2 branches covered.">            if (unconnectedB != null) {</span>
<span class="fc" id="L764">                voxelsA.addAll(unconnectedB);</span>
            }
<span class="fc" id="L766">            unconnectedAB = checkVoxels(voxelsA, location, random, true);</span>

<span class="fc" id="L768">            unconnectedA = unconnectedAB;</span>
<span class="fc" id="L769">            unconnectedB = unconnectedBA;</span>
<span class="fc" id="L770">        }</span>
<span class="fc" id="L771">    }</span>

    /**
     * Balances voxels in the splits.
     *
     * &lt;p&gt;Checks that the number of voxels in each split are within a certain difference. If not,
     * then add voxels from the larger split into the smaller split such that both splits are still
     * connected. For small split sizes, there may not be a valid split that is both connected and
     * within the difference; in these cases, connectedness is prioritized and the splits are
     * returned not balanced.
     *
     * @param voxelsA the list for the first half of the split
     * @param voxelsB the list for the second half of the split
     * @param location the location instance
     * @param random the seeded random number generator
     */
    static void balanceVoxels(
            ArrayList&lt;Voxel&gt; voxelsA,
            ArrayList&lt;Voxel&gt; voxelsB,
            PottsLocation location,
            MersenneTwisterFast random) {
<span class="fc" id="L792">        int nA = voxelsA.size();</span>
<span class="fc" id="L793">        int nB = voxelsB.size();</span>

<span class="fc bfc" id="L795" title="All 2 branches covered.">        while (Math.abs(nA - nB) &gt; Math.ceil((nA + nB) * BALANCE_DIFFERENCE)) {</span>
            ArrayList&lt;Voxel&gt; fromVoxels;
            ArrayList&lt;Voxel&gt; toVoxels;

<span class="fc bfc" id="L799" title="All 2 branches covered.">            if (nA &gt; nB) {</span>
<span class="fc" id="L800">                fromVoxels = voxelsA;</span>
<span class="fc" id="L801">                toVoxels = voxelsB;</span>
            } else {
<span class="fc" id="L803">                fromVoxels = voxelsB;</span>
<span class="fc" id="L804">                toVoxels = voxelsA;</span>
            }

            // Get all valid neighbor voxels.
<span class="fc" id="L808">            LinkedHashSet&lt;Voxel&gt; neighborSet = new LinkedHashSet&lt;&gt;();</span>
<span class="fc bfc" id="L809" title="All 2 branches covered.">            for (Voxel voxel : toVoxels) {</span>
<span class="fc" id="L810">                ArrayList&lt;Voxel&gt; neighbors = location.getNeighbors(voxel);</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">                for (Voxel neighbor : neighbors) {</span>
<span class="fc bfc" id="L812" title="All 2 branches covered.">                    if (!toVoxels.contains(neighbor)) {</span>
<span class="fc" id="L813">                        neighborSet.add(neighbor);</span>
                    }
<span class="fc" id="L815">                }</span>
<span class="fc" id="L816">            }</span>

            // If one list is empty, add all voxels in other list as neighbors.
<span class="fc bfc" id="L819" title="All 2 branches covered.">            if (toVoxels.size() == 0) {</span>
<span class="fc" id="L820">                neighborSet.addAll(fromVoxels);</span>
            }

<span class="fc" id="L823">            ArrayList&lt;Voxel&gt; neighborList = new ArrayList&lt;&gt;(neighborSet);</span>
<span class="fc" id="L824">            Utilities.shuffleList(neighborList, random);</span>

            // Select a neighbor to move from one list to the other.
<span class="fc" id="L827">            boolean added = false;</span>
<span class="fc" id="L828">            ArrayList&lt;Voxel&gt; invalidCoords = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">            for (Voxel voxel : neighborList) {</span>
<span class="fc bfc" id="L830" title="All 2 branches covered.">                if (fromVoxels.contains(voxel)) {</span>
<span class="fc" id="L831">                    toVoxels.add(voxel);</span>
<span class="fc" id="L832">                    fromVoxels.remove(voxel);</span>

                    // Check that removal of coordinate does not cause the list
                    // to become unconnected.
<span class="fc" id="L836">                    ArrayList&lt;Voxel&gt; unconnected = checkVoxels(fromVoxels, location, random, false);</span>
<span class="fc bfc" id="L837" title="All 2 branches covered.">                    if (unconnected == null) {</span>
<span class="fc" id="L838">                        added = true;</span>
<span class="fc" id="L839">                        break;</span>
                    } else {
<span class="fc" id="L841">                        fromVoxels.add(voxel);</span>
<span class="fc" id="L842">                        toVoxels.remove(voxel);</span>
<span class="fc" id="L843">                        invalidCoords.add(voxel);</span>
                    }
                }
<span class="fc" id="L846">            }</span>

<span class="fc bfc" id="L848" title="All 2 branches covered.">            if (!added) {</span>
<span class="fc" id="L849">                toVoxels.addAll(invalidCoords);</span>
<span class="fc" id="L850">                fromVoxels.removeAll(invalidCoords);</span>
<span class="fc" id="L851">                connectVoxels(voxelsA, voxelsB, location, random);</span>
<span class="fc" id="L852">                break;</span>
            }

<span class="fc" id="L855">            nA = voxelsA.size();</span>
<span class="fc" id="L856">            nB = voxelsB.size();</span>
<span class="fc" id="L857">        }</span>
<span class="fc" id="L858">    }</span>

    /**
     * Checks voxels in the list for connectedness.
     *
     * &lt;p&gt;All the connected voxels from a random starting voxel are found and marked as visited. If
     * there are no remaining unvisited voxels, then the list is fully connected. If there are, then
     * the smaller of the visited or unvisited lists is returned.
     *
     * &lt;p&gt;Some voxel lists may have more than one unconnected section.
     *
     * @param voxels the list of voxels
     * @param location the location instance
     * @param random the seeded random number generator
     * @param update {@code true} if list should be updated, {@code false} otherwise
     * @return a list of unconnected voxels, {@code null} if list is connected
     */
    static ArrayList&lt;Voxel&gt; checkVoxels(
            ArrayList&lt;Voxel&gt; voxels,
            PottsLocation location,
            MersenneTwisterFast random,
            boolean update) {
<span class="fc bfc" id="L880" title="All 2 branches covered.">        if (voxels.size() == 0) {</span>
<span class="fc" id="L881">            return null;</span>
        }

<span class="fc" id="L884">        ArrayList&lt;Voxel&gt; unvisited = new ArrayList&lt;&gt;(voxels);</span>
<span class="fc" id="L885">        ArrayList&lt;Voxel&gt; visited = new ArrayList&lt;&gt;();</span>
        ArrayList&lt;Voxel&gt; nextList;
        LinkedHashSet&lt;Voxel&gt; nextSet;
<span class="fc" id="L888">        LinkedHashSet&lt;Voxel&gt; currSet = new LinkedHashSet&lt;&gt;();</span>

<span class="fc" id="L890">        currSet.add(unvisited.get(random.nextInt(unvisited.size())));</span>
<span class="fc" id="L891">        int currSize = currSet.size();</span>

<span class="fc bfc" id="L893" title="All 2 branches covered.">        while (currSize &gt; 0) {</span>
<span class="fc" id="L894">            nextSet = new LinkedHashSet&lt;&gt;();</span>

            // Iterate through each coordinate in current coordinate set.
<span class="fc bfc" id="L897" title="All 2 branches covered.">            for (Voxel voxel : currSet) {</span>
<span class="fc" id="L898">                nextList = new ArrayList&lt;&gt;();</span>

                // Iterate through each connected direction from current voxel
                // and add to neighbor list if it exists.
<span class="fc" id="L902">                ArrayList&lt;Voxel&gt; neighbors = location.getNeighbors(voxel);</span>
<span class="fc bfc" id="L903" title="All 2 branches covered.">                for (Voxel neighbor : neighbors) {</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">                    if (unvisited.contains(neighbor)) {</span>
<span class="fc" id="L905">                        nextList.add(neighbor);</span>
                    }
<span class="fc" id="L907">                }</span>

                // Updated next voxel set with list of neighbors.
<span class="fc" id="L910">                nextSet.addAll(nextList);</span>
<span class="fc" id="L911">                visited.add(voxel);</span>
<span class="fc" id="L912">                unvisited.remove(voxel);</span>
<span class="fc" id="L913">            }</span>

<span class="fc" id="L915">            currSet = nextSet;</span>
<span class="fc" id="L916">            currSize = currSet.size();</span>
        }

        // If not all coordinates have been visited, then the list of
        // coordinates is not connected.
<span class="fc bfc" id="L921" title="All 2 branches covered.">        if (unvisited.size() != 0) {</span>
<span class="fc bfc" id="L922" title="All 2 branches covered.">            if (unvisited.size() &gt; visited.size()) {</span>
<span class="fc bfc" id="L923" title="All 2 branches covered.">                if (update) {</span>
<span class="fc" id="L924">                    voxels.removeAll(visited);</span>
                }
<span class="fc" id="L926">                return visited;</span>
            } else {
<span class="fc bfc" id="L928" title="All 2 branches covered.">                if (update) {</span>
<span class="fc" id="L929">                    voxels.removeAll(unvisited);</span>
                }
<span class="fc" id="L931">                return unvisited;</span>
            }
        } else {
<span class="fc" id="L934">            return null;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>