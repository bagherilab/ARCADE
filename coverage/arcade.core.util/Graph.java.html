<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Graph.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">arcade</a> &gt; <a href="index.source.html" class="el_package">arcade.core.util</a> &gt; <span class="el_source">Graph.java</span></div><h1>Graph.java</h1><pre class="source lang-java linenums">package arcade.core.util;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import sim.util.Bag;

/**
 * Container class for directed graph using nodes as hashes.
 *
 * &lt;p&gt;{@code Edge} objects represent edges in the graph and {@code Node} objects represent nodes in
 * the graph. Nodes may have more than one edge in or out.
 */
public final class Graph {

    /** Calculation strategies. */
<span class="fc" id="L23">    public enum Strategy {</span>
        /** Code for upstream calculation strategy. */
<span class="fc" id="L25">        UPSTREAM,</span>

        /** Code for downstream direction strategy. */
<span class="fc" id="L28">        DOWNSTREAM</span>
    }

    /** Collection of all {@code Edge} objects in a graph. */
    private final Bag allEdges;

    /** Map of {@code Node} OUT to bag of {@code Edge} objects. */
    private final Map&lt;Node, Bag&gt; nodeToOutBag;

    /** Map of {@code Node} IN to bag of {@code Edge} objects. */
    private final Map&lt;Node, Bag&gt; nodeToInBag;

    /** Creates an empty {@code Graph}. */
<span class="fc" id="L41">    public Graph() {</span>
<span class="fc" id="L42">        allEdges = new Bag();</span>
<span class="fc" id="L43">        nodeToOutBag = new HashMap&lt;&gt;();</span>
<span class="fc" id="L44">        nodeToInBag = new HashMap&lt;&gt;();</span>
<span class="fc" id="L45">    }</span>

    /**
     * Updates edges and nodes with contents of given graph.
     *
     * @param graph the graph object
     */
    public void update(Graph graph) {
<span class="fc" id="L53">        allEdges.addAll(graph.allEdges);</span>
<span class="fc" id="L54">        nodeToOutBag.putAll(graph.nodeToOutBag);</span>
<span class="fc" id="L55">        nodeToInBag.putAll(graph.nodeToInBag);</span>
<span class="fc" id="L56">    }</span>

    /** Clear edges and nodes from graph. */
    public void clear() {
<span class="fc" id="L60">        allEdges.clear();</span>
<span class="fc" id="L61">        nodeToOutBag.clear();</span>
<span class="fc" id="L62">        nodeToInBag.clear();</span>
<span class="fc" id="L63">    }</span>

    /**
     * Gets all nodes in the graph.
     *
     * @return a set containing the nodes
     */
    public Set&lt;Node&gt; getAllNodes() {
<span class="fc" id="L71">        return retrieveNodes();</span>
    }

    /**
     * Check to see if a graph contains a node.
     *
     * @param node the node to add
     * @return {@code true} if node exists in graph, {@code false} otherwise
     */
    public boolean contains(Node node) {
<span class="fc" id="L81">        return getAllNodes().contains(node);</span>
    }

    /**
     * Check to see if a graph contains an edge.
     *
     * @param edge the edge to add
     * @return {@code true} if edge exists in graph, {@code false} otherwise
     */
    public boolean contains(Edge edge) {
<span class="fc" id="L91">        return checkEdge(edge);</span>
    }

    /**
     * Gets all edges in the graph.
     *
     * @return a bag containing the edges
     */
    public Bag getAllEdges() {
<span class="fc" id="L100">        return allEdges;</span>
    }

    /**
     * Gets all edges in the graph based on the given node and category.
     *
     * @param node the node to get edges from
     * @param strategy the category of edges to get
     * @return a bag containing the edges
     */
    public Bag getEdges(Node node, Strategy strategy) {
<span class="fc bfc" id="L111" title="All 2 branches covered.">        return (strategy == Strategy.UPSTREAM) ? nodeToInBag.get(node) : nodeToOutBag.get(node);</span>
    }

    /**
     * Gets edges out of the given node.
     *
     * @param node the node that edges are from
     * @return a bag containing the edges
     */
    public Bag getEdgesOut(Node node) {
<span class="fc" id="L121">        return getEdges(node, Strategy.DOWNSTREAM);</span>
    }

    /**
     * Gets edges into the given node.
     *
     * @param node the node that edges are to
     * @return a bag containing the edges
     */
    public Bag getEdgesIn(Node node) {
<span class="fc" id="L131">        return getEdges(node, Strategy.UPSTREAM);</span>
    }

    /**
     * Gets the in degree at the given node.
     *
     * @param node the node
     * @return the in degree
     */
    public int getInDegree(Node node) {
<span class="fc bfc" id="L141" title="All 2 branches covered.">        return nodeToInBag.containsKey(node) ? nodeToInBag.get(node).numObjs : 0;</span>
    }

    /**
     * Gets the out degree at the given node.
     *
     * @param node the node
     * @return the out degree
     */
    public int getOutDegree(Node node) {
<span class="fc bfc" id="L151" title="All 2 branches covered.">        return nodeToOutBag.containsKey(node) ? nodeToOutBag.get(node).numObjs : 0;</span>
    }

    /**
     * Gets the total degree (in degree + out degree) at the given node.
     *
     * @param node the node
     * @return the degree
     */
    public int getDegree(Node node) {
<span class="fc" id="L161">        return getInDegree(node) + getOutDegree(node);</span>
    }

    /**
     * Checks if the graph has an edge between the given nodes.
     *
     * @param from the node the edge points from
     * @param to the node the edge points to
     * @return {@code true} if edge exists, {@code false} otherwise
     */
    public boolean hasEdge(Node from, Node to) {
<span class="fc" id="L172">        Edge e = new Edge(from, to);</span>
<span class="fc" id="L173">        return checkEdge(e);</span>
    }

    /**
     * Checks if the graph has an edge.
     *
     * @param edge the edge
     * @return {@code true} if edge exists, {@code false} otherwise
     */
    private boolean checkEdge(Edge edge) {
<span class="fc" id="L183">        return allEdges.contains(edge);</span>
    }

    /** Defines a filter for edges in a graph. */
    public interface GraphFilter {
        /**
         * Applies filter to an {link Edge} object.
         *
         * @param edge the edge
         * @return {@code true} if edge passes filter, {@code false} otherwise
         */
        boolean filter(Edge edge);
    }

    /**
     * Filters this graph for edges and copies them to the given graph object.
     *
     * &lt;p&gt;Notes that the links in the subgraph are not correct.
     *
     * @param g the graph to add filtered edges to
     * @param f the edge filter
     */
    public void getSubgraph(Graph g, GraphFilter f) {
<span class="fc bfc" id="L206" title="All 2 branches covered.">        for (Object obj : allEdges) {</span>
<span class="fc" id="L207">            Edge edge = (Edge) obj;</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">            if (f.filter(edge)) {</span>
<span class="fc" id="L209">                g.allEdges.add(edge);</span>
<span class="fc" id="L210">                g.setOutMap(edge.getFrom(), edge);</span>
<span class="fc" id="L211">                g.setInMap(edge.getTo(), edge);</span>
            }
<span class="fc" id="L213">        }</span>
<span class="fc" id="L214">    }</span>

    /**
     * Retrieves all nodes in the graph.
     *
     * @return a set containing the nodes
     */
    private Set&lt;Node&gt; retrieveNodes() {
<span class="fc" id="L222">        Set&lt;Node&gt; sOut = nodeToOutBag.keySet();</span>
<span class="fc" id="L223">        Set&lt;Node&gt; sIn = nodeToInBag.keySet();</span>
<span class="fc" id="L224">        Set&lt;Node&gt; set =</span>
<span class="fc" id="L225">                new LinkedHashSet&lt;Node&gt;() {</span>
                    {
<span class="fc" id="L227">                        addAll(sOut);</span>
<span class="fc" id="L228">                        addAll(sIn);</span>
<span class="fc" id="L229">                    }</span>
                };

<span class="fc" id="L232">        return set;</span>
    }

    /** Sets the TO and FROM nodes for edges to be the same object. */
    public void mergeNodes() {
<span class="fc" id="L237">        Set&lt;Node&gt; set = retrieveNodes();</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">        for (Node obj : set) {</span>
<span class="fc" id="L239">            Node join = obj.duplicate();</span>
<span class="fc" id="L240">            Bag out = getEdgesOut(obj);</span>
<span class="fc" id="L241">            Bag in = getEdgesIn(obj);</span>

            // Iterate through all edges OUT of node.
<span class="fc bfc" id="L244" title="All 2 branches covered.">            if (out != null) {</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">                for (Object x : out) {</span>
<span class="fc" id="L246">                    Edge e = (Edge) x;</span>
<span class="fc" id="L247">                    e.setFrom(join);</span>
<span class="fc" id="L248">                }</span>
            }

            // Iterate through all edges IN to node.
<span class="fc bfc" id="L252" title="All 2 branches covered.">            if (in != null) {</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">                for (Object x : in) {</span>
<span class="fc" id="L254">                    Edge e = (Edge) x;</span>
<span class="fc" id="L255">                    e.setTo(join);</span>
<span class="fc" id="L256">                }</span>
            }
<span class="fc" id="L258">        }</span>
<span class="fc" id="L259">    }</span>

    /**
     * Adds edge to graph based on nodes.
     *
     * @param from the node to add as the from node.
     * @param to the node to add as the to node.
     */
    public void addEdge(Node from, Node to) {
<span class="fc" id="L268">        addEdge(new Edge(from, to));</span>
<span class="fc" id="L269">    }</span>

    /**
     * Adds edge to graph.
     *
     * @param edge the edge to add
     */
    public void addEdge(Edge edge) {
<span class="fc" id="L277">        allEdges.add(edge);</span>
<span class="fc" id="L278">        setOutMap(edge.getFrom(), edge);</span>
<span class="fc" id="L279">        setInMap(edge.getTo(), edge);</span>
<span class="fc" id="L280">        setLinks(edge);</span>
<span class="fc" id="L281">    }</span>

    /**
     * Adds the edge to the bag for the mapping of OUT node to edge.
     *
     * @param node the node hash
     * @param edge the edge
     */
    private void setOutMap(Node node, Edge edge) {
<span class="fc" id="L290">        Bag objs = nodeToOutBag.get(node);</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">        if (objs == null) {</span>
<span class="fc" id="L292">            objs = new Bag(10);</span>
<span class="fc" id="L293">            nodeToOutBag.put(node.duplicate(), objs);</span>
        }
<span class="fc" id="L295">        objs.add(edge);</span>
<span class="fc" id="L296">    }</span>

    /**
     * Adds the edge to the bag for the mapping of IN node to edge.
     *
     * @param node the node hash
     * @param edge the edge
     */
    private void setInMap(Node node, Edge edge) {
<span class="fc" id="L305">        Bag objs = nodeToInBag.get(node);</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">        if (objs == null) {</span>
<span class="fc" id="L307">            objs = new Bag(10);</span>
<span class="fc" id="L308">            nodeToInBag.put(node.duplicate(), objs);</span>
        }
<span class="fc" id="L310">        objs.add(edge);</span>
<span class="fc" id="L311">    }</span>

    /**
     * Adds links between edges in and out of the nodes for a given edge.
     *
     * @param edge the edge
     */
    private void setLinks(Edge edge) {
<span class="fc" id="L319">        Bag outTo = getEdgesOut(edge.getTo());</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">        if (outTo != null) {</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">            for (Object obj : outTo) {</span>
<span class="fc" id="L322">                Edge e = (Edge) obj;</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">                if (!e.edgesIn.contains(edge)) {</span>
<span class="fc" id="L324">                    e.edgesIn.add(edge);</span>
                }
<span class="fc bfc" id="L326" title="All 2 branches covered.">                if (!edge.edgesOut.contains(e)) {</span>
<span class="fc" id="L327">                    edge.edgesOut.add(e);</span>
                }
<span class="fc" id="L329">            }</span>
        }

<span class="fc" id="L332">        Bag inFrom = getEdgesIn(edge.getFrom());</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (inFrom != null) {</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">            for (Object obj : inFrom) {</span>
<span class="fc" id="L335">                Edge e = (Edge) obj;</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">                if (!e.edgesOut.contains(edge)) {</span>
<span class="fc" id="L337">                    e.edgesOut.add(edge);</span>
                }
<span class="fc bfc" id="L339" title="All 2 branches covered.">                if (!edge.edgesIn.contains(e)) {</span>
<span class="fc" id="L340">                    edge.edgesIn.add(e);</span>
                }
<span class="fc" id="L342">            }</span>
        }
<span class="fc" id="L344">    }</span>

    /**
     * Removes edge from graph.
     *
     * @param edge the edge to remove
     */
    public void removeEdge(Edge edge) {
<span class="fc" id="L352">        allEdges.remove(edge);</span>
<span class="fc" id="L353">        unsetOutMap(edge.getFrom(), edge);</span>
<span class="fc" id="L354">        unsetInMap(edge.getTo(), edge);</span>
<span class="fc" id="L355">        unsetLinks(edge);</span>
<span class="fc" id="L356">    }</span>

    /**
     * Removes the edge from the bag for the mapping of OUT node to edge.
     *
     * @param node the node hash
     * @param edge the edge
     */
    private void unsetOutMap(Node node, Edge edge) {
<span class="fc" id="L365">        Bag objs = nodeToOutBag.get(node);</span>
<span class="fc" id="L366">        objs.remove(edge);</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">        if (objs.numObjs == 0) {</span>
<span class="fc" id="L368">            nodeToOutBag.remove(node);</span>
        }
<span class="fc" id="L370">    }</span>

    /**
     * Removes the edge from the bag for the mapping of IN node to edge.
     *
     * @param node the node hash
     * @param edge the edge
     */
    private void unsetInMap(Node node, Edge edge) {
<span class="fc" id="L379">        Bag objs = nodeToInBag.get(node);</span>
<span class="fc" id="L380">        objs.remove(edge);</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">        if (objs.numObjs == 0) {</span>
<span class="fc" id="L382">            nodeToInBag.remove(node);</span>
        }
<span class="fc" id="L384">    }</span>

    /**
     * Removes links between edges in and out of the nodes for a given edge.
     *
     * @param edge the edge
     */
    private void unsetLinks(Edge edge) {
<span class="fc" id="L392">        Bag outTo = getEdgesOut(edge.getTo());</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">        if (outTo != null) {</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">            for (Object obj : outTo) {</span>
<span class="fc" id="L395">                Edge e = (Edge) obj;</span>
<span class="fc" id="L396">                e.edgesIn.remove(edge);</span>
<span class="fc" id="L397">                edge.edgesOut.remove(e);</span>
<span class="fc" id="L398">            }</span>
        }

<span class="fc" id="L401">        Bag inFrom = getEdgesIn(edge.getFrom());</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">        if (inFrom != null) {</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">            for (Object obj : inFrom) {</span>
<span class="fc" id="L404">                Edge e = (Edge) obj;</span>
<span class="fc" id="L405">                e.edgesOut.remove(edge);</span>
<span class="fc" id="L406">                edge.edgesIn.remove(e);</span>
<span class="fc" id="L407">            }</span>
        }
<span class="fc" id="L409">    }</span>

    /**
     * Clear an edge's links to other edges.
     *
     * @param edge the edge
     */
    public void clearEdge(Edge edge) {
<span class="fc" id="L417">        edge.clear();</span>
<span class="fc" id="L418">    }</span>

    /**
     * Find the first downstream node where two edges intersect.
     *
     * @param edge1 first edge to start from
     * @param edge2 second edge to start from
     * @return the intersection node or null if no intersection
     */
    public Node findDownstreamIntersection(Edge edge1, Edge edge2) {
<span class="fc" id="L428">        return findIntersection(edge1, edge2, Strategy.DOWNSTREAM);</span>
    }

    /**
     * Find the first upstream node where two edges intersect.
     *
     * @param edge1 first edge to start from
     * @param edge2 second edge to start from
     * @return the intersection node or null if no intersection
     */
    public Node findUpstreamIntersection(Edge edge1, Edge edge2) {
<span class="fc" id="L439">        return findIntersection(edge1, edge2, Strategy.UPSTREAM);</span>
    }

    /**
     * Find the first node where two edges intersect based on a calulcation strategy (upstream or
     * downstream).
     *
     * @param edge1 first edge to start from
     * @param edge2 second edge to start from
     * @param strategy the direction to search
     * @return the intersection node or null if no intersection
     */
    private Node findIntersection(Edge edge1, Edge edge2, Strategy strategy) {
<span class="fc bfc" id="L452" title="All 2 branches covered.">        if (edge1.getNode(strategy).equals(edge2.getNode(strategy))) {</span>
<span class="fc" id="L453">            return edge1.getNode(strategy);</span>
        }
<span class="fc" id="L455">        Bag allConnected = getConnectedNodes(edge1.getNode(strategy), strategy);</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">        if (allConnected == null) {</span>
<span class="fc" id="L457">            return null;</span>
        }
<span class="fc" id="L459">        Node intersection = breadthFirstSearch(edge2.getNode(strategy), allConnected, strategy);</span>
<span class="fc" id="L460">        return intersection;</span>
    }

    /**
     * Get all nodes connected to the given node based on a calculation strategy (e.g. upstream or
     * downstream).
     *
     * @param node the node to start from
     * @param strategy the direction to search
     * @return a bag of connected nodes
     */
    private Bag getConnectedNodes(Node node, Strategy strategy) {
<span class="fc" id="L472">        Bag first = getEdges(node, strategy);</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">        if (first == null) {</span>
<span class="fc" id="L474">            return null;</span>
        }
<span class="fc" id="L476">        Bag visited = new Bag();</span>
<span class="fc" id="L477">        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L478" title="All 2 branches covered.">        for (Object e : first) {</span>
<span class="fc" id="L479">            Edge edge = (Edge) e;</span>
<span class="fc" id="L480">            queue.add(edge.getNode(strategy));</span>
<span class="fc" id="L481">        }</span>

<span class="fc bfc" id="L483" title="All 2 branches covered.">        while (!queue.isEmpty()) {</span>
<span class="fc" id="L484">            Node active = queue.poll();</span>
<span class="fc" id="L485">            visited.add(active);</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">            if (getEdges(active, strategy) == null) {</span>
<span class="fc" id="L487">                continue;</span>
            }
<span class="fc bfc" id="L489" title="All 2 branches covered.">            for (Object next : getEdges(active, strategy)) {</span>
<span class="fc" id="L490">                Edge edge = (Edge) next;</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">                if (!visited.contains(edge.getNode(strategy))) {</span>
<span class="fc" id="L492">                    queue.add(edge.getNode(strategy));</span>
                }
<span class="fc" id="L494">            }</span>
<span class="fc" id="L495">        }</span>
<span class="fc" id="L496">        return visited;</span>
    }

    /**
     * Breadth first search from node according to strategy for a subset of target nodes.
     *
     * @param node the node to start from
     * @param targetNodes the bag of potential intersection nodes
     * @param strategy the direction to search
     * @return the target node or null if not found
     */
    private Node breadthFirstSearch(Node node, Bag targetNodes, Strategy strategy) {
<span class="fc" id="L508">        Bag first = getEdges(node, strategy);</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">        if (first == null) {</span>
<span class="fc" id="L510">            return null;</span>
        }
<span class="fc" id="L512">        Bag visited = new Bag();</span>
<span class="fc" id="L513">        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">        for (Object e : first) {</span>
<span class="fc" id="L515">            Edge edge = (Edge) e;</span>
<span class="fc" id="L516">            queue.add(edge.getNode(strategy));</span>
<span class="fc" id="L517">        }</span>

<span class="fc bfc" id="L519" title="All 2 branches covered.">        while (!queue.isEmpty()) {</span>
<span class="fc" id="L520">            Node active = queue.poll();</span>
<span class="fc" id="L521">            visited.add(active);</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">            if (targetNodes.contains(active)) {</span>
<span class="fc" id="L523">                return active;</span>
            }
<span class="fc bfc" id="L525" title="All 2 branches covered.">            if (getEdges(active, strategy) == null) {</span>
<span class="fc" id="L526">                continue;</span>
            }
<span class="fc bfc" id="L528" title="All 2 branches covered.">            for (Object next : getEdges(active, strategy)) {</span>
<span class="fc" id="L529">                Edge edge = (Edge) next;</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">                if (!visited.contains(edge.getNode(strategy))) {</span>
<span class="fc" id="L531">                    queue.add(edge.getNode(strategy));</span>
                }
<span class="fc" id="L533">            }</span>
<span class="fc" id="L534">        }</span>
<span class="fc" id="L535">        return null;</span>
    }

    /**
     * Removes the given edge and adds the reversed edge.
     *
     * @param edge the edge to reverse
     */
    public void reverseEdge(Edge edge) {
<span class="fc" id="L544">        removeEdge(edge);</span>
<span class="fc" id="L545">        addEdge(edge.reverse());</span>
<span class="fc" id="L546">    }</span>

    /**
     * Displays the graph as a list of edges and nodes.
     *
     * @return the string representation of the graph
     */
    public String toString() {
<span class="fc" id="L554">        String s = &quot;&quot;;</span>

<span class="fc" id="L556">        s += &quot;\nEDGES OUT\n\n&quot;;</span>
<span class="fc" id="L557">        Set&lt;Node&gt; setFrom = nodeToOutBag.keySet();</span>
<span class="fc" id="L558">        List&lt;Node&gt; sortedFrom = new ArrayList&lt;&gt;(setFrom);</span>
<span class="fc" id="L559">        Collections.sort(sortedFrom);</span>

<span class="fc bfc" id="L561" title="All 2 branches covered.">        for (Object obj : sortedFrom) {</span>
<span class="fc" id="L562">            Bag b = nodeToOutBag.get(obj);</span>
<span class="fc" id="L563">            s += obj.toString() + &quot; : &quot;;</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">            for (int i = 0; i &lt; b.numObjs; i++) {</span>
<span class="fc" id="L565">                s += b.get(i) + &quot; &quot;;</span>
            }
<span class="fc" id="L567">            s += &quot;\n&quot;;</span>
<span class="fc" id="L568">        }</span>

<span class="fc" id="L570">        s += &quot;\nEDGES IN\n\n&quot;;</span>
<span class="fc" id="L571">        Set&lt;Node&gt; setTo = nodeToInBag.keySet();</span>
<span class="fc" id="L572">        List&lt;Node&gt; sortedTo = new ArrayList&lt;&gt;(setTo);</span>
<span class="fc" id="L573">        Collections.sort(sortedTo);</span>

<span class="fc bfc" id="L575" title="All 2 branches covered.">        for (Object obj : sortedTo) {</span>
<span class="fc" id="L576">            Bag b = nodeToInBag.get(obj);</span>
<span class="fc" id="L577">            s += obj.toString() + &quot; : &quot;;</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">            for (int i = 0; i &lt; b.numObjs; i++) {</span>
<span class="fc" id="L579">                s += b.get(i) + &quot; &quot;;</span>
            }
<span class="fc" id="L581">            s += &quot;\n&quot;;</span>
<span class="fc" id="L582">        }</span>

<span class="fc" id="L584">        return s;</span>
    }

    /**
     * Nested class representing a graph node.
     *
     * &lt;p&gt;The node tracks its corresponding position in the lattice.
     */
    public static class Node implements Comparable&lt;Node&gt; {
        /** Coordinate in x direction. */
        protected int x;

        /** Coordinate in y direction. */
        protected int y;

        /** Coordinate in z direction. */
        protected int z;

        /**
         * Creates a {@code Node} at the given coordinates.
         *
         * @param x the x coordinate
         * @param y the y coordinate
         * @param z the z coordinate
         */
<span class="fc" id="L609">        public Node(int x, int y, int z) {</span>
<span class="fc" id="L610">            this.x = x;</span>
<span class="fc" id="L611">            this.y = y;</span>
<span class="fc" id="L612">            this.z = z;</span>
<span class="fc" id="L613">        }</span>

        /**
         * Gets the x coordinate of the node.
         *
         * @return the x coordinate
         */
        public int getX() {
<span class="fc" id="L621">            return x;</span>
        }

        /**
         * Gets the y coordinate of the node.
         *
         * @return the y coordinate
         */
        public int getY() {
<span class="fc" id="L630">            return y;</span>
        }

        /**
         * Gets the z coordinate of the node.
         *
         * @return the z coordinate
         */
        public int getZ() {
<span class="fc" id="L639">            return z;</span>
        }

        /**
         * Compares a node to this node.
         *
         * @param node the node to compare
         * @return zero if the x and y coordinates are equal, otherwise the result of integer
         *     comparison for x and y
         */
        public int compareTo(Node node) {
<span class="fc" id="L650">            int xComp = Integer.compare(x, node.getX());</span>
<span class="fc" id="L651">            int yComp = Integer.compare(y, node.getY());</span>

<span class="fc bfc" id="L653" title="All 2 branches covered.">            if (xComp == 0) {</span>
<span class="fc" id="L654">                return yComp;</span>
            } else {
<span class="fc" id="L656">                return xComp;</span>
            }
        }

        /**
         * Creates a duplicate node with the same coordinates.
         *
         * @return a {@code Node} copy
         */
        public Node duplicate() {
<span class="fc" id="L666">            return new Node(x, y, z);</span>
        }

        /**
         * Updates the position of this {@code Node} with coordinate from given {@code Node}.
         *
         * @param node the {@code Node} with coordinates to update with
         */
        public void update(Node node) {
<span class="fc" id="L675">            this.x = node.x;</span>
<span class="fc" id="L676">            this.y = node.y;</span>
<span class="fc" id="L677">            this.z = node.z;</span>
<span class="fc" id="L678">        }</span>

        /**
         * Specifies object hashing based on coordinates.
         *
         * @return a hash based on coordinates
         */
        public final int hashCode() {
<span class="fc" id="L686">            return x + (y &lt;&lt; 8) + (z &lt;&lt; 16);</span>
        }

        /**
         * Checks if two nodes are equal based on coordinates.
         *
         * @param obj the object to check
         * @return {@code true} if coordinates match, {@code false} otherwise
         */
        public final boolean equals(Object obj) {
<span class="fc bfc" id="L696" title="All 2 branches covered.">            if (obj instanceof Node) {</span>
<span class="fc" id="L697">                Node node = (Node) obj;</span>
<span class="fc bfc" id="L698" title="All 6 branches covered.">                return node.x == x &amp;&amp; node.y == y &amp;&amp; node.z == z;</span>
            }
<span class="fc" id="L700">            return false;</span>
        }

        /**
         * Formats node as a string.
         *
         * @return a string representation of the node
         */
        public String toString() {
<span class="fc" id="L709">            return &quot;(&quot; + x + &quot;,&quot; + y + &quot;,&quot; + z + &quot;)&quot;;</span>
        }
    }

    /**
     * Nested class representing a graph edge.
     *
     * &lt;p&gt;The edge tracks its corresponding nodes as well as the edges into the FROM node and out of
     * the TO node.
     */
    public static class Edge {
        /** Node this edge points to. */
        protected Node to;

        /** Node this edge points from. */
        protected Node from;

        /** List of edges that point into the node this edge points from. */
        private final ArrayList&lt;Edge&gt; edgesIn;

        /** List of edges that point out of the node this edge points to. */
        private final ArrayList&lt;Edge&gt; edgesOut;

        /**
         * Creates an {@code Edge} between two {@link Node} objects.
         *
         * @param from the node the edge is from
         * @param to the node the edge is to
         */
<span class="fc" id="L738">        public Edge(Node from, Node to) {</span>
<span class="fc" id="L739">            this.from = from.duplicate();</span>
<span class="fc" id="L740">            this.to = to.duplicate();</span>
<span class="fc" id="L741">            edgesIn = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L742">            edgesOut = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L743">        }</span>

        /**
         * Gets the node the edge points to based on the calculation strategy (e.g. upstream or
         * downstream).
         *
         * @param strategy the calculation strategy
         * @return the node the edge points to
         */
        public Node getNode(Strategy strategy) {
<span class="fc bfc" id="L753" title="All 2 branches covered.">            return (strategy == Strategy.UPSTREAM) ? from : to;</span>
        }

        /**
         * Gets the node the edge points from.
         *
         * @return the node the edge points from
         */
        public Node getFrom() {
<span class="fc" id="L762">            return from;</span>
        }

        /**
         * Gets the node the edge points to.
         *
         * @return the node the edge points to
         */
        public Node getTo() {
<span class="fc" id="L771">            return to;</span>
        }

        /**
         * Sets the node the edge points to.
         *
         * @param to the node the edge points to
         */
        public void setTo(Node to) {
<span class="fc" id="L780">            this.to = to;</span>
<span class="fc" id="L781">        }</span>

        /**
         * Sets the node the edge points from.
         *
         * @param from the node the edge points from
         */
        public void setFrom(Node from) {
<span class="fc" id="L789">            this.from = from;</span>
<span class="fc" id="L790">        }</span>

        /**
         * Gets list of edges based on calculation strategy (e.g. upstream or downstream).
         *
         * @param strategy the calculation strategy
         * @return the list of edges
         */
        public ArrayList&lt;Edge&gt; getEdges(Strategy strategy) {
<span class="fc bfc" id="L799" title="All 2 branches covered.">            return (strategy == Strategy.UPSTREAM) ? edgesIn : edgesOut;</span>
        }

        /**
         * Gets list of edges that point into the node this edge points from.
         *
         * @return the list of edges
         */
        public ArrayList&lt;Edge&gt; getEdgesIn() {
<span class="fc" id="L808">            return getEdges(Strategy.UPSTREAM);</span>
        }

        /**
         * Gets list of edges that point out of the node this edge points to.
         *
         * @return the list of edges
         */
        public ArrayList&lt;Edge&gt; getEdgesOut() {
<span class="fc" id="L817">            return getEdges(Strategy.DOWNSTREAM);</span>
        }

        /**
         * Reverses the edge by swapping the nodes.
         *
         * @return the reversed edge
         */
        Edge reverse() {
<span class="fc" id="L826">            Node tempTo = to;</span>
<span class="fc" id="L827">            Node tempFrom = from;</span>
<span class="fc" id="L828">            to = tempFrom;</span>
<span class="fc" id="L829">            from = tempTo;</span>
<span class="fc" id="L830">            return this;</span>
        }

        /** Removes the linked edges. */
        public void clear() {
<span class="fc" id="L835">            edgesIn.clear();</span>
<span class="fc" id="L836">            edgesOut.clear();</span>
<span class="fc" id="L837">        }</span>

        /**
         * Formats edge as a string.
         *
         * @return a string representation of the edge
         */
        public String toString() {
<span class="fc" id="L845">            return &quot;[&quot; + from.toString() + &quot;~&quot; + to.toString() + &quot;]&quot;;</span>
        }

        /**
         * Checks if two nodes are equal based on to and from nodes.
         *
         * @param obj the object to check
         * @return {@code true} if coordinates of both nodes match, {@code false} otherwise
         */
        public boolean equals(Object obj) {
<span class="fc bfc" id="L855" title="All 2 branches covered.">            if (obj instanceof Edge) {</span>
<span class="fc" id="L856">                Edge edge = (Edge) obj;</span>
<span class="fc bfc" id="L857" title="All 4 branches covered.">                return to.equals(edge.to) &amp;&amp; from.equals(edge.from);</span>
            }
<span class="fc" id="L859">            return false;</span>
        }

        /**
         * Specifies object hashing based on from and to coordinates.
         *
         * @return a hash based on coordinates
         */
        public final int hashCode() {
<span class="fc" id="L868">            return this.from.hashCode() + (this.to.hashCode() &lt;&lt; 16);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>