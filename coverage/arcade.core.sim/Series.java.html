<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Series.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">arcade</a> &gt; <a href="index.source.html" class="el_package">arcade.core.sim</a> &gt; <span class="el_source">Series.java</span></div><h1>Series.java</h1><pre class="source lang-java linenums">package arcade.core.sim;

import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import sim.display.GUIState;
import sim.engine.SimState;
import arcade.core.sim.output.*;
import arcade.core.util.Box;
import arcade.core.util.MiniBox;
import static arcade.core.util.MiniBox.TAG_SEPARATOR;

/**
 * Abstract simulation manager for {@link Simulation} objects, differing only in random seed.
 *
 * &lt;p&gt;The class is instantiated by parsing an XML document specifying model setup. Constructors for
 * the {@link Simulation} objects are built, but not called to instantiate the simulation until the
 * series is run. {@code Series} objects that are not valid are flagged with {@code isSkipped} and
 * are not run.
 *
 * &lt;p&gt;{@link Simulation} objects are passed their parent {@code Series} object.
 */
public abstract class Series {
    /** Logger for {@code Series}. */
<span class="fc" id="L28">    private static final Logger LOGGER = Logger.getLogger(Series.class.getName());</span>

    /** Regular expression for numbers. */
    private static final String NUMBER_REGEX = &quot;^(\\d+)|(\\d+E\\d+)$&quot;;

    /** Regular expression for fractions. */
    private static final String FRACTION_REGEX = &quot;^(([0]*(\\.\\d*|))|(1[\\.0]*))$&quot;;

    /** Regular expression for distributions. */
    public static final String DISTRIBUTION_REGEX =
            &quot;^([A-Z\\_]+)\\(([A-Z]+)=([\\d\\.]+)(?:,([A-Z]+)=([\\d\\.]+))*\\)$&quot;;

    /** Offset of random seed to avoid using seed of 0. */
    public static final int SEED_OFFSET = 1000;

    /** {@code true} if {@code Series} is not valid, {@code false} otherwise. */
    public boolean isSkipped;

    /** {@code true} if {@code Series} is visualized, {@code false} otherwise. */
    public boolean isVis;

    /** Output saver for the simulation. */
    public OutputSaver saver;

    /** Output loader for the simulation. */
    public OutputLoader loader;

    /** Name of the series. */
    private final String name;

    /** Path and prefix for the series. */
    private final String prefix;

    /** Spatial conversion factor (um/voxel). */
    public final double ds;

    /** Spatial conversion factor in z (um/voxel). */
    public final double dz;

    /** Temporal conversion factor (hrs/tick). */
    public final double dt;

    /** Constructor for the simulation. */
    protected Constructor&lt;?&gt; simCons;

    /** Constructor for the visualization. */
    protected Constructor&lt;?&gt; visCons;

    /** Random seed of the first simulation in the series. */
    private final int startSeed;

    /** Random seed of the last simulation in the series. */
    private final int endSeed;

    /** Simulation length in ticks. */
    private final int ticks;

    /** Snapshot interval in ticks. */
    private final int interval;

    /** Length of the simulation. */
    public final int length;

    /** Width of the simulation. */
    public final int width;

    /** Height of the simulation. */
    public final int height;

    /** Margin for the simulation. */
    public final int margin;

    /** Map of population settings. */
    public HashMap&lt;String, MiniBox&gt; populations;

    /** Map of layer settings. */
    public HashMap&lt;String, MiniBox&gt; layers;

    /** Map of action settings. */
    public HashMap&lt;String, MiniBox&gt; actions;

    /** Map of component settings. */
    public HashMap&lt;String, MiniBox&gt; components;

    /**
     * Creates a {@code Series} object given setup information parsed from XML.
     *
     * @param setupDicts the map of attribute to value for single instance tags
     * @param setupLists the map of attribute to value for multiple instance tags
     * @param path the path for simulation output
     * @param parameters the default parameter values
     * @param isVis {@code true} if visualized, {@code false} otherwise
     */
    public Series(
            HashMap&lt;String, MiniBox&gt; setupDicts,
            HashMap&lt;String, ArrayList&lt;Box&gt;&gt; setupLists,
            String path,
            Box parameters,
<span class="fc" id="L126">            boolean isVis) {</span>
<span class="fc" id="L127">        MiniBox set = setupDicts.get(&quot;set&quot;);</span>
<span class="fc" id="L128">        MiniBox series = setupDicts.get(&quot;series&quot;);</span>
<span class="fc" id="L129">        MiniBox defaults = parameters.getIdValForTag(&quot;DEFAULT&quot;);</span>

<span class="fc" id="L131">        this.isVis = isVis;</span>

        // Set name and prefix.
<span class="fc" id="L134">        this.name = series.get(&quot;name&quot;);</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">        this.prefix = path + (set.contains(&quot;prefix&quot;) ? set.get(&quot;prefix&quot;) : &quot;&quot;) + name;</span>

        // Set random seeds.
<span class="fc" id="L138">        this.startSeed =</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">                (series.contains(&quot;start&quot;) ? series.getInt(&quot;start&quot;) : defaults.getInt(&quot;START_SEED&quot;));</span>
<span class="fc" id="L140">        this.endSeed =</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">                (series.contains(&quot;end&quot;) ? series.getInt(&quot;end&quot;) : defaults.getInt(&quot;END_SEED&quot;));</span>

        // Set number of ticks and interval
<span class="fc bfc" id="L144" title="All 2 branches covered.">        this.ticks = (series.contains(&quot;ticks&quot;) ? series.getInt(&quot;ticks&quot;) : defaults.getInt(&quot;TICKS&quot;));</span>
<span class="fc" id="L145">        this.interval =</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">                (series.contains(&quot;interval&quot;)</span>
<span class="fc" id="L147">                        ? series.getInt(&quot;interval&quot;)</span>
<span class="fc" id="L148">                        : defaults.getInt(&quot;INTERVAL&quot;));</span>

        // Set sizing.
<span class="fc" id="L151">        this.length =</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">                (series.contains(&quot;length&quot;) ? series.getInt(&quot;length&quot;) : defaults.getInt(&quot;LENGTH&quot;));</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">        this.width = (series.contains(&quot;width&quot;) ? series.getInt(&quot;width&quot;) : defaults.getInt(&quot;WIDTH&quot;));</span>
<span class="fc" id="L154">        this.height =</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">                (series.contains(&quot;height&quot;) ? series.getInt(&quot;height&quot;) : defaults.getInt(&quot;HEIGHT&quot;));</span>
<span class="fc" id="L156">        this.margin =</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">                (series.contains(&quot;margin&quot;) ? series.getInt(&quot;margin&quot;) : defaults.getInt(&quot;MARGIN&quot;));</span>

        // Set conversion factors.
<span class="fc bfc" id="L160" title="All 2 branches covered.">        this.ds = (series.contains(&quot;ds&quot;) ? series.getDouble(&quot;ds&quot;) : defaults.getDouble(&quot;DS&quot;));</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">        this.dz = (series.contains(&quot;dz&quot;) ? series.getDouble(&quot;dz&quot;) : defaults.getDouble(&quot;DZ&quot;));</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">        this.dt = (series.contains(&quot;dt&quot;) ? series.getDouble(&quot;dt&quot;) : defaults.getDouble(&quot;DT&quot;));</span>

        // Initialize simulation series.
<span class="fc" id="L165">        initialize(setupLists, parameters);</span>

        // Create constructors for simulation and visualization.
<span class="fc" id="L168">        makeConstructors();</span>
<span class="fc" id="L169">    }</span>

    /**
     * Gets the name of the series.
     *
     * @return the name of the series
     */
    public String getName() {
<span class="fc" id="L177">        return name;</span>
    }

    /**
     * Gets the prefix for the series, including file path.
     *
     * @return the file path and prefix for the series
     */
    public String getPrefix() {
<span class="fc" id="L186">        return prefix;</span>
    }

    /**
     * Gets the start random seed.
     *
     * @return the random seed
     */
    public int getStartSeed() {
<span class="fc" id="L195">        return startSeed;</span>
    }

    /**
     * Gets the end random seed.
     *
     * @return the random seed
     */
    public int getEndSeed() {
<span class="fc" id="L204">        return endSeed;</span>
    }

    /**
     * Gets the number of ticks per simulation.
     *
     * @return the ticks
     */
    public int getTicks() {
<span class="fc" id="L213">        return ticks;</span>
    }

    /**
     * Gets the number of ticks between snapshots.
     *
     * @return the interval
     */
    public int getInterval() {
<span class="fc" id="L222">        return interval;</span>
    }

    /**
     * Checks if string contains valid number greater than 0.
     *
     * @param box the box containing the fraction
     * @param key the number key
     * @return {@code true if valid}, {@code false} otherwise
     */
    protected static boolean isValidNumber(Box box, String key) {
<span class="fc bfc" id="L233" title="All 2 branches covered.">        if (box.getValue(key) == null) {</span>
<span class="fc" id="L234">            return false;</span>
        }
<span class="fc" id="L236">        return box.getValue(key).matches(NUMBER_REGEX);</span>
    }

    /**
     * Checks if string contains valid fraction between 0 and 1, inclusive.
     *
     * @param box the box containing the fraction
     * @param key the fraction key
     * @return {@code true if valid}, {@code false} otherwise
     */
    protected static boolean isValidFraction(Box box, String key) {
<span class="fc bfc" id="L247" title="All 2 branches covered.">        if (box.getValue(key) == null) {</span>
<span class="fc" id="L248">            return false;</span>
        }
<span class="fc" id="L250">        return box.getValue(key).matches(FRACTION_REGEX);</span>
    }

    /**
     * Initializes series simulation, agents, and environment.
     *
     * @param setupLists the map of attribute to value for multiple instance tags
     * @param parameters the default parameter values loaded from {@code parameter.xml}
     */
    protected abstract void initialize(HashMap&lt;String, ArrayList&lt;Box&gt;&gt; setupLists, Box parameters);

    /**
     * Creates agent populations.
     *
     * @param populationsBox the list of population setup dictionaries
     * @param populationDefaults the dictionary of default population parameters
     * @param populationConversions the dictionary of population parameter conversions
     */
    protected abstract void updatePopulations(
            ArrayList&lt;Box&gt; populationsBox,
            MiniBox populationDefaults,
            MiniBox populationConversions);

    /**
     * Creates environment layers.
     *
     * @param layersBox the list of layer setup dictionaries
     * @param layerDefaults the dictionary of default layer parameters
     * @param layerConversions the dictionary of layer parameter conversions
     */
    protected abstract void updateLayers(
            ArrayList&lt;Box&gt; layersBox, MiniBox layerDefaults, MiniBox layerConversions);

    /**
     * Creates selected actions.
     *
     * @param actionsBox the list of action dictionaries
     * @param actionDefaults the dictionary of default action parameters
     */
    protected abstract void updateActions(ArrayList&lt;Box&gt; actionsBox, MiniBox actionDefaults);

    /**
     * Creates selected components.
     *
     * @param componentsBox the list of component dictionaries
     * @param componentDefaults the dictionary of default component parameters
     */
    protected abstract void updateComponents(
            ArrayList&lt;Box&gt; componentsBox, MiniBox componentDefaults);

    /**
     * Parses parameter values based on default value.
     *
     * @param box the parameter map
     * @param parameter the parameter name
     * @param defaultParameter the default parameter value
     * @param values the map of parameter values
     * @param scales the map of parameter scaling
     */
    protected static void parseParameter(
            MiniBox box,
            String parameter,
            String defaultParameter,
            MiniBox values,
            MiniBox scales) {
<span class="fc bfc" id="L315" title="All 2 branches covered.">        String value = values.contains(parameter) ? values.get(parameter) : defaultParameter;</span>
<span class="fc" id="L316">        Matcher match = Pattern.compile(DISTRIBUTION_REGEX).matcher(value);</span>

<span class="fc bfc" id="L318" title="All 2 branches covered.">        if (match.find()) {</span>
<span class="fc" id="L319">            box.put(&quot;(DISTRIBUTION)&quot; + TAG_SEPARATOR + parameter, match.group(1).toUpperCase());</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">            for (int i = 0; i &lt; (match.groupCount() - 1) / 2; i++) {</span>
<span class="fc" id="L321">                int index = 2 * (i + 1);</span>
<span class="fc" id="L322">                box.put(parameter + &quot;_&quot; + match.group(index), match.group(index + 1));</span>
            }
        } else {
<span class="fc" id="L325">            box.put(parameter, value);</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">            if (scales.contains(parameter)) {</span>
<span class="fc" id="L327">                box.put(parameter, box.getDouble(parameter) * scales.getDouble(parameter));</span>
            }
        }
<span class="fc" id="L330">    }</span>

    /**
     * Updates conversion string into a value.
     *
     * &lt;p&gt;Conversion string is in the form of {@code D^N} where {@code D} is either {@code DS},
     * {@code DZ}, or {@code DT} and {@code N} is an integer exponent. Conversions with {@code DZ}
     * are replaced with {@code DS}. Multiple terms can be chained in the form {@code D^N1.D^N2}.
     * The {@code ^N} is not required if N = 1.
     *
     * @param convert the conversion string
     * @param ds the spatial conversion factor
     * @param dt the temporal conversion factor
     * @return the updated conversion factor
     */
    protected static double parseConversion(String convert, double ds, double dt) {
<span class="fc" id="L346">        return parseConversion(convert, ds, ds, dt);</span>
    }

    /**
     * Updates conversion string into a value.
     *
     * &lt;p&gt;Conversion string is in the form of {@code D^N} where {@code D} is either {@code DS},
     * {@code DZ}, or {@code DT} and {@code N} is an integer exponent. Multiple terms can be chained
     * in the form {@code D^N1.D^N2}. The {@code ^N} is not required if N = 1.
     *
     * @param convert the conversion string
     * @param ds the spatial conversion factor in xy
     * @param dz the spatial conversion factor in z
     * @param dt the temporal conversion factor
     * @return the updated conversion factor
     */
    protected static double parseConversion(String convert, double ds, double dz, double dt) {
<span class="fc" id="L363">        double value = 1;</span>
<span class="fc" id="L364">        String[] split = convert.split(&quot;\\.&quot;);</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">        for (String s : split) {</span>
<span class="fc" id="L366">            String[] subsplit = s.replace(&quot; &quot;, &quot;&quot;).split(&quot;\\^&quot;);</span>
            double v =
<span class="fc bfc" id="L368" title="All 2 branches covered.">                    (subsplit[0].equals(&quot;DS&quot;)</span>
<span class="fc" id="L369">                            ? ds</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">                            : (subsplit[0].equals(&quot;DZ&quot;)</span>
<span class="fc" id="L371">                                    ? dz</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">                                    : (subsplit[0].equals(&quot;DT&quot;) ? dt : 1)));</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">            int n = (subsplit.length == 2 ? Integer.parseInt(subsplit[1]) : 1);</span>
<span class="fc" id="L374">            value *= Math.pow(v, n);</span>
        }
<span class="fc" id="L376">        return value;</span>
    }

    /** Uses reflections to build constructors for simulation and visualization. */
    protected void makeConstructors() {
        // Create constructor for simulation class.
        try {
<span class="fc" id="L383">            Class&lt;?&gt; c = Class.forName(getSimClass());</span>
<span class="fc" id="L384">            simCons = c.getConstructor(long.class, Series.class);</span>
<span class="fc" id="L385">        } catch (Exception e) {</span>
<span class="fc" id="L386">            LOGGER.severe(&quot;simulation class [ &quot; + getSimClass() + &quot; ] not found&quot;);</span>
<span class="fc" id="L387">            e.printStackTrace();</span>
<span class="fc" id="L388">            isSkipped = true;</span>
<span class="fc" id="L389">        }</span>

        // Create constructor for visualization class.
        try {
<span class="fc" id="L393">            Class&lt;?&gt; c = Class.forName(getVisClass());</span>
<span class="fc" id="L394">            visCons = c.getConstructor(Simulation.class);</span>
<span class="fc" id="L395">        } catch (Exception e) {</span>
<span class="fc" id="L396">            LOGGER.severe(&quot;visualization class [ &quot; + getSimClass() + &quot; ] not found&quot;);</span>
<span class="fc" id="L397">            e.printStackTrace();</span>
<span class="fc" id="L398">            isSkipped = true;</span>
<span class="fc" id="L399">        }</span>
<span class="fc" id="L400">    }</span>

    /**
     * Gets the class name for the simulation.
     *
     * @return the simulation class
     */
    protected abstract String getSimClass();

    /**
     * Gets the class name for the visualization.
     *
     * @return the visualization class
     */
    protected abstract String getVisClass();

    /**
     * Calls {@code runSim} for each random seed.
     *
     * @throws Exception if simulation constructor cannot be instantiated
     */
    public void runSims() throws Exception {
        long simStart;
        long simEnd;

        // Iterate through each seed.
<span class="fc bfc" id="L426" title="All 2 branches covered.">        for (int seed = startSeed; seed &lt;= endSeed; seed++) {</span>
            // Pre-simulation output.
<span class="fc" id="L428">            LOGGER.info(String.format(&quot;simulation [ %s | %04d ] started&quot;, name, seed));</span>
<span class="fc" id="L429">            simStart = System.currentTimeMillis();</span>

            // Run simulation.
<span class="fc" id="L432">            SimState simstate = (SimState) (simCons.newInstance(seed + SEED_OFFSET, this));</span>
<span class="fc" id="L433">            runSim(simstate, seed);</span>

            // Post-simulation output.
<span class="fc" id="L436">            simEnd = System.currentTimeMillis();</span>
<span class="fc" id="L437">            LOGGER.info(</span>
<span class="fc" id="L438">                    String.format(</span>
                            &quot;simulation [ %s | %04d ] finished in %.4f minutes&quot;,
<span class="fc" id="L440">                            name, seed, (double) (simEnd - simStart) / 1000 / 60));</span>
        }
<span class="fc" id="L442">    }</span>

    /**
     * Iterates through each tick of the simulation.
     *
     * @param simstate the simulation state instance
     * @param seed the random seed
     */
    void runSim(SimState simstate, int seed) {
        // Start simulation.
<span class="fc" id="L452">        simstate.start();</span>

        // Set up logger checkpoints.
<span class="fc" id="L455">        double delta = ticks / 10.0;</span>
<span class="fc" id="L456">        double checkpoint = delta;</span>

        // Run simulation loop.
        double tick;
        do {
<span class="fc bfc" id="L461" title="All 2 branches covered.">            if (!simstate.schedule.step(simstate)) {</span>
<span class="fc" id="L462">                break;</span>
            }
<span class="fc" id="L464">            tick = simstate.schedule.getTime();</span>

<span class="fc bfc" id="L466" title="All 2 branches covered.">            if (tick &gt;= checkpoint) {</span>
<span class="fc" id="L467">                LOGGER.info(</span>
<span class="fc" id="L468">                        String.format(</span>
                                &quot;simulation [ %s | %04d ] tick %6d ( %4.2f %% )&quot;,
<span class="fc" id="L470">                                name, seed, (int) tick, (100 * tick / ticks)));</span>
<span class="fc" id="L471">                checkpoint += delta;</span>
            }
<span class="fc bfc" id="L473" title="All 2 branches covered.">        } while (tick &lt; ticks - 1);</span>

        // Finish simulation.
<span class="fc" id="L476">        simstate.finish();</span>
<span class="fc" id="L477">    }</span>

    /**
     * Creates controller for visualization.
     *
     * @throws Exception if visualization constructor cannot be instantiated
     */
    public void runVis() throws Exception {
<span class="fc bfc" id="L485" title="All 2 branches covered.">        if (System.getProperty(&quot;java.awt.headless&quot;) != null</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">                &amp;&amp; System.getProperty(&quot;java.awt.headless&quot;).equals(&quot;true&quot;)) {</span>
<span class="fc" id="L487">            return;</span>
        }
<span class="fc" id="L489">        Simulation sim = (Simulation) (simCons.newInstance(startSeed + SEED_OFFSET, this));</span>
<span class="fc" id="L490">        ((GUIState) visCons.newInstance(sim)).createController();</span>
<span class="fc" id="L491">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>