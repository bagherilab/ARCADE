<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OutputSaver.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">arcade</a> &gt; <a href="index.source.html" class="el_package">arcade.core.sim.output</a> &gt; <span class="el_source">OutputSaver.java</span></div><h1>OutputSaver.java</h1><pre class="source lang-java linenums">package arcade.core.sim.output;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import com.google.gson.Gson;
import sim.engine.Schedule;
import sim.engine.SimState;
import sim.engine.Steppable;
import arcade.core.sim.Series;
import arcade.core.sim.Simulation;
import static arcade.core.sim.Simulation.DEFAULT_CELL_TYPE;
import static arcade.core.sim.Simulation.DEFAULT_LOCATION_TYPE;

/**
 * Custom saver for serializing objects to JSON.
 *
 * &lt;p&gt;The saver is associated with an implementation-specific {@code Gson} instance that defines
 * serialization of implementation-specific classes. The associated {@link arcade.core.sim.Series}
 * instance is used to save static information specific to the series. The equipped {@link
 * arcade.core.sim.Simulation} instance is called to get cells / locations that are saved at a given
 * tick.
 */
public abstract class OutputSaver implements Steppable {
    /** Logger for {@code OutputSaver}. */
<span class="fc" id="L31">    protected static final Logger LOGGER = Logger.getLogger(OutputSaver.class.getName());</span>

    /** Number of elements to format in output string. */
    protected static final int FORMAT_ELEMENTS = 6;

    /** JSON representation. */
    protected final Gson gson;

    /** {@link arcade.core.sim.Series} instance. */
    final Series series;

    /** Prefix for saved files. */
    public String prefix;

    /** {@link arcade.core.sim.Simulation} instance. */
    protected Simulation sim;

    /** Snapshot interval in ticks. */
    private final int interval;

    /**
     * Creates an {@code OutputSaver} for the series.
     *
     * @param series the simulation series
     */
<span class="fc" id="L56">    public OutputSaver(Series series) {</span>
<span class="fc" id="L57">        this.series = series;</span>
<span class="fc" id="L58">        this.gson = makeGSON();</span>
<span class="fc" id="L59">        this.interval = series.getInterval();</span>
<span class="fc" id="L60">    }</span>

    /**
     * Creates a {@code Gson} instance for serializing objects.
     *
     * @return a {@code Gson} instance
     */
    protected abstract Gson makeGSON();

    /**
     * Equips a {@link arcade.core.sim.Simulation} instance to the saver.
     *
     * @param sim the simulation instance
     */
    public void equip(Simulation sim) {
<span class="fc" id="L75">        this.prefix = String.format(&quot;%s_%04d&quot;, series.getPrefix(), sim.getSeed());</span>
<span class="fc" id="L76">        this.sim = sim;</span>
<span class="fc" id="L77">    }</span>

    /** Saves the {@link arcade.core.sim.Series} as a JSON. */
    public void saveSeries() {
<span class="fc" id="L81">        String path = series.getPrefix() + &quot;.json&quot;;</span>
<span class="fc" id="L82">        String json = gson.toJson(series);</span>
<span class="fc" id="L83">        write(path, format(json, FORMAT_ELEMENTS));</span>
<span class="fc" id="L84">    }</span>

    /**
     * Save a list of {@link arcade.core.agent.cell.CellContainer} to a JSON.
     *
     * @param tick the simulation tick
     */
    public void saveCells(int tick) {
<span class="fc" id="L92">        String path = prefix + String.format(&quot;_%06d.CELLS.json&quot;, tick);</span>
<span class="fc" id="L93">        String json = gson.toJson(sim.getCells(), DEFAULT_CELL_TYPE);</span>
<span class="fc" id="L94">        write(path, format(json, FORMAT_ELEMENTS));</span>
<span class="fc" id="L95">    }</span>

    /**
     * Save a list of {@link arcade.core.env.location.LocationContainer} to a JSON.
     *
     * @param tick the simulation tick
     */
    public void saveLocations(int tick) {
<span class="fc" id="L103">        String path = prefix + String.format(&quot;_%06d.LOCATIONS.json&quot;, tick);</span>
<span class="fc" id="L104">        String json = gson.toJson(sim.getLocations(), DEFAULT_LOCATION_TYPE);</span>
<span class="fc" id="L105">        write(path, format(json, FORMAT_ELEMENTS));</span>
<span class="fc" id="L106">    }</span>

    /**
     * Steps through cell rules.
     *
     * @param simstate the MASON simulation state
     */
    @Override
    public void step(SimState simstate) {
<span class="fc" id="L115">        int tick = (int) simstate.schedule.getTime();</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">        if (tick % interval == 0) {</span>
<span class="fc" id="L117">            save(tick);</span>
        }
<span class="fc" id="L119">    }</span>

    /**
     * Saves the relevant data.
     *
     * @param tick the simulation tick
     */
    public void save(int tick) {
<span class="fc" id="L127">        saveCells(tick);</span>
<span class="fc" id="L128">        saveLocations(tick);</span>
<span class="fc" id="L129">    }</span>

    /**
     * Schedules the saver to take snapshots at the given interval.
     *
     * @param schedule the simulation schedule
     */
    public void schedule(Schedule schedule) {
<span class="fc" id="L137">        schedule.scheduleRepeating(Schedule.EPOCH, -1, this, 1);</span>
<span class="fc" id="L138">    }</span>

    /**
     * Writes the contents to the given file path.
     *
     * @param filepath the path for the file
     * @param contents the contents of the file
     */
    public void write(String filepath, String contents) {
        try {
            // Get writer
<span class="fc" id="L149">            File outfile = new File(filepath);</span>
<span class="fc" id="L150">            FileOutputStream fos = new FileOutputStream(outfile, false);</span>
<span class="fc" id="L151">            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(fos));</span>

            // Write contents
<span class="fc" id="L154">            bw.write(contents);</span>

            // Close streams.
<span class="fc" id="L157">            bw.close();</span>
<span class="fc" id="L158">            fos.close();</span>

<span class="fc" id="L160">            LOGGER.info(&quot;file [ &quot; + filepath + &quot; ] successfully written&quot;);</span>
<span class="fc" id="L161">        } catch (IOException ex) {</span>
<span class="fc" id="L162">            LOGGER.severe(&quot;error writing [ &quot; + filepath + &quot; ] due to &quot; + ex.getClass().getName());</span>
<span class="fc" id="L163">            ex.printStackTrace();</span>
<span class="fc" id="L164">            series.isSkipped = true;</span>
<span class="fc" id="L165">        }</span>
<span class="fc" id="L166">    }</span>

    /**
     * Formats the arrays in the given string.
     *
     * &lt;p&gt;Method reformats the output of GSON pretty printing by converting {@code [\n A,\n B,\n ...
     * N\n ]} to {@code [ A, B, ..., N ]} for lists of up to N elements.
     *
     * @param string the string to format
     * @param maxElements the maximum number of elements to format.
     * @return the formatted string
     */
    protected static String format(String string, int maxElements) {
<span class="fc" id="L179">        String formatted = string;</span>

<span class="fc bfc" id="L181" title="All 2 branches covered.">        for (int elements = 1; elements &lt; maxElements + 1; elements++) {</span>
<span class="fc" id="L182">            String inputPattern =</span>
<span class="fc" id="L183">                    IntStream.rangeClosed(1, elements)</span>
<span class="fc" id="L184">                            .mapToObj(Integer::toString)</span>
<span class="fc" id="L185">                            .map(s -&gt; &quot;([\\-\\d\\.]+)&quot;)</span>
<span class="fc" id="L186">                            .collect(Collectors.joining(&quot;,\\n[\\s\\t]+&quot;));</span>
<span class="fc" id="L187">            inputPattern = &quot;\\[\\n[\\s\\t]+&quot; + inputPattern + &quot;\\n[\\s\\t]+\\]&quot;;</span>

<span class="fc" id="L189">            String outputPattern =</span>
<span class="fc" id="L190">                    IntStream.rangeClosed(1, elements)</span>
<span class="fc" id="L191">                            .mapToObj(Integer::toString)</span>
<span class="fc" id="L192">                            .map(s -&gt; &quot;$&quot; + s)</span>
<span class="fc" id="L193">                            .collect(Collectors.joining(&quot;, &quot;));</span>
<span class="fc" id="L194">            outputPattern = &quot;[&quot; + outputPattern + &quot;]&quot;;</span>

<span class="fc" id="L196">            formatted = formatted.replaceAll(inputPattern, outputPattern);</span>
        }

<span class="fc" id="L199">        return formatted;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>