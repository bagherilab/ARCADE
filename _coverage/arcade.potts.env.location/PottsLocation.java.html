<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PottsLocation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">arcade</a> &gt; <a href="index.source.html" class="el_package">arcade.potts.env.location</a> &gt; <span class="el_source">PottsLocation.java</span></div><h1>PottsLocation.java</h1><pre class="source lang-java linenums">package arcade.potts.env.location;

import java.util.ArrayList;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.LinkedHashSet;
import ec.util.MersenneTwisterFast;
import arcade.core.env.location.Location;
import arcade.core.env.location.LocationContainer;
import arcade.core.util.Utilities;
import static arcade.potts.util.PottsEnums.Direction;
import static arcade.potts.util.PottsEnums.Region;

/**
 * Abstract implementation of {@link Location} for potts models.
 * &lt;p&gt;
 * {@code PottsLocation} objects manage the a list of associated {@link Voxel}
 * objects that comprise the location. These voxels are represented as an array
 * in the {@link arcade.potts.sim.Potts} layer and the two representations are
 * kept in sync.
 * &lt;p&gt;
 * Concrete implementations of {@code PottsLocation} manage the dimensionality
 * of the voxels.
 * &lt;p&gt;
 * {@code PottsLocation} also provides several general static methods for
 * manipulating voxel lists:
 * &lt;ul&gt;
 *     &lt;li&gt;&lt;strong&gt;Split&lt;/strong&gt; voxel list along a given direction&lt;/li&gt;
 *     &lt;li&gt;&lt;strong&gt;Connect&lt;/strong&gt; voxels to ensure that each list contains
 *     connected voxels&lt;/li&gt;
 *     &lt;li&gt;&lt;strong&gt;Balance&lt;/strong&gt; voxels between two lists to ensure they have
 *     a similar number of voxels&lt;/li&gt;
 *     &lt;li&gt;&lt;strong&gt;Check&lt;/strong&gt; voxels for connectedness&lt;/li&gt;
 * &lt;/ul&gt;
 */

public abstract class PottsLocation implements Location {
    /** Relative difference between split voxel numbers. */
    private static final double BALANCE_DIFFERENCE = 0.05;
    
    /** Relative padding for selecting maximum diameter. */
    private static final double DIAMETER_RATIO = 0.9;
    
    /** List of voxels for the location. */
    final ArrayList&lt;Voxel&gt; voxels;
    
    /** Location volume. */
    int volume;
    
    /** Location surface. */
    int surface;
    
    /** Location height. */
    int height;
    
    /** X position of center. */
    double cx;
    
    /** Y position of center. */
    double cy;
    
    /** Z position of center. */
    double cz;
    
    /**
     * Creates a {@code PottsLocation} for a list of voxels.
     *
     * @param voxels  the list of voxels
     */
<span class="fc" id="L70">    public PottsLocation(ArrayList&lt;Voxel&gt; voxels) {</span>
<span class="fc" id="L71">        this.voxels = new ArrayList&lt;&gt;(voxels);</span>
<span class="fc" id="L72">        this.volume = voxels.size();</span>
<span class="fc" id="L73">        this.surface = calculateSurface();</span>
<span class="fc" id="L74">        this.height = calculateHeight();</span>
<span class="fc" id="L75">        calculateCenter();</span>
<span class="fc" id="L76">    }</span>
    
    /**
     * Gets all voxels.
     *
     * @return  the list of voxels
     */
<span class="fc" id="L83">    public ArrayList&lt;Voxel&gt; getVoxels() { return new ArrayList&lt;&gt;(voxels); }</span>
    
    /**
     * Gets all voxels for a region.
     *
     * @param region  the region
     * @return  the list of reqion voxels
     */
<span class="fc" id="L91">    public ArrayList&lt;Voxel&gt; getVoxels(Region region) { return new ArrayList&lt;&gt;(); }</span>
    
    /**
     * Gets a set of regions.
     *
     * @return  the set of regions
     */
<span class="fc" id="L98">    public EnumSet&lt;Region&gt; getRegions() { return null; }</span>
    
    @Override
<span class="fc" id="L101">    public final double getVolume() { return volume; }</span>
    
    /**
     * Gets the volume of the location for a given region.
     *
     * @param region  the region
     * @return  the location region volume
     */
<span class="fc" id="L109">    public double getVolume(Region region) { return getVolume(); }</span>
    
    @Override
<span class="fc" id="L112">    public final double getSurface() { return surface; }</span>
    
    /**
     * Gets the surface area of the location for a given region.
     *
     * @param region  the region
     * @return  the location region surface area
     */
<span class="fc" id="L120">    public double getSurface(Region region) { return getSurface(); }</span>
    
    @Override
<span class="fc" id="L123">    public final double getHeight() { return height; }</span>
    
    /**
     * Gets the height of the location for a given region.
     *
     * @param region  the region
     * @return  the location height
     */
<span class="fc" id="L131">    public double getHeight(Region region) { return getHeight(); }</span>
    
    /**
     * Adds a voxel at the given coordinates.
     *
     * @param x  the x coordinate
     * @param y  the y coordinate
     * @param z  the z coordinate
     */
    public void add(int x, int y, int z) {
<span class="fc" id="L141">        Voxel voxel = new Voxel(x, y, z);</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">        if (!voxels.contains(voxel)) {</span>
<span class="fc" id="L143">            voxels.add(voxel);</span>
<span class="fc" id="L144">            volume++;</span>
<span class="fc" id="L145">            surface += updateSurface(voxel);</span>
<span class="fc" id="L146">            height += updateHeight(voxel);</span>
<span class="fc" id="L147">            updateCenter(x, y, z, 1);</span>
        }
<span class="fc" id="L149">    }</span>
    
    /**
     * Adds a voxel at the given coordinates for given region.
     *
     * @param region  the voxel region
     * @param x  the x coordinate
     * @param y  the y coordinate
     * @param z  the z coordinate
     */
<span class="fc" id="L159">    public void add(Region region, int x, int y, int z) { add(x, y, z); }</span>
    
    /**
     * Removes the voxel at the given coordinates.
     *
     * @param x  the x coordinate
     * @param y  the y coordinate
     * @param z  the z coordinate
     */
    public void remove(int x, int y, int z) {
<span class="fc" id="L169">        Voxel voxel = new Voxel(x, y, z);</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">        if (voxels.contains(voxel)) {</span>
<span class="fc" id="L171">            voxels.remove(voxel);</span>
<span class="fc" id="L172">            volume--;</span>
<span class="fc" id="L173">            surface -= updateSurface(voxel);</span>
<span class="fc" id="L174">            height -= updateHeight(voxel);</span>
<span class="fc" id="L175">            updateCenter(x, y, z, -1);</span>
        }
<span class="fc" id="L177">    }</span>
    
    /**
     * Removes the voxel at the given coordinates for given region.
     *
     * @param region  the voxel region
     * @param x  the x coordinate
     * @param y  the y coordinate
     * @param z  the z coordinate
     */
<span class="fc" id="L187">    public void remove(Region region, int x, int y, int z) { remove(x, y, z); }</span>
    
    /**
     * Assigns the voxel at the given coordinates to the given region.
     *
     * @param region  the voxel region
     * @param voxel  the voxel to assign
     */
<span class="fc" id="L195">    public void assign(Region region, Voxel voxel) { }</span>
    
    /**
     * Assigns target number of voxels to given region.
     *
     * @param region  the region to assign
     * @param target  the target number of voxels to assign
     * @param random  the seeded random number generator
     */
<span class="fc" id="L204">    public void distribute(Region region, int target, MersenneTwisterFast random) { }</span>
    
    /**
     * Finds the closest voxel that exists in the location.
     *
     * @param voxel  the starting voxel
     * @return  the closest voxel or the starting voxel if it exists
     */
    public Voxel adjust(Voxel voxel) {
<span class="fc bfc" id="L213" title="All 2 branches covered.">        if (voxels.contains(voxel)) {</span>
<span class="fc" id="L214">            return voxel;</span>
        }
        
<span class="fc" id="L217">        int x = voxel.x;</span>
<span class="fc" id="L218">        int y = voxel.y;</span>
<span class="fc" id="L219">        int z = voxel.z;</span>
        
<span class="fc" id="L221">        double minimumDistance = Double.MAX_VALUE;</span>
        
<span class="fc bfc" id="L223" title="All 2 branches covered.">        for (Voxel v : voxels) {</span>
<span class="fc" id="L224">            double distance = Math.sqrt(Math.pow(v.x - x, 2)</span>
<span class="fc" id="L225">                    + Math.pow(v.y - y, 2)</span>
<span class="fc" id="L226">                    + Math.pow(v.z - z, 2));</span>
            
<span class="fc bfc" id="L228" title="All 2 branches covered.">            if (distance &lt; minimumDistance) {</span>
<span class="fc" id="L229">                minimumDistance = distance;</span>
<span class="fc" id="L230">                voxel = v;</span>
            }
<span class="fc" id="L232">        }</span>
        
<span class="fc" id="L234">        return voxel;</span>
    }
    
    /**
     * Clears all voxel lists and arrays.
     *
     * @param ids  the potts array for ids
     * @param regions  the potts array for regions
     */
    public void clear(int[][][] ids, int[][][] regions) {
<span class="fc" id="L244">        voxels.forEach(voxel -&gt; ids[voxel.z][voxel.x][voxel.y] = 0);</span>
<span class="fc" id="L245">        voxels.clear();</span>
<span class="fc" id="L246">    }</span>
    
    /**
     * Updates the array for the location.
     *
     * @param id  the location id
     * @param ids  the potts array for ids
     * @param regions  the potts array for regions
     */
    public void update(int id, int[][][] ids, int[][][] regions) {
<span class="fc" id="L256">        voxels.forEach(voxel -&gt; ids[voxel.z][voxel.x][voxel.y] = id);</span>
<span class="fc" id="L257">    }</span>
    
    /**
     * Splits the location voxels into two lists.
     * &lt;p&gt;
     * The location are split along the direction with the shortest diameter.
     * The lists of locations are guaranteed to be connected, and generally will
     * be balanced in size. One of the splits is assigned to the current
     * location and the other is returned.
     *
     * @param random  the seeded random number generator
     * @return  a location with the split voxels
     */
    public Location split(MersenneTwisterFast random) {
        // Get center voxel.
<span class="fc" id="L272">        Voxel center = getCenter();</span>
        
        // Initialize lists of split voxels.
<span class="fc" id="L275">        ArrayList&lt;Voxel&gt; voxelsA = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L276">        ArrayList&lt;Voxel&gt; voxelsB = new ArrayList&lt;&gt;();</span>
        
        // Get split direction.
<span class="fc" id="L279">        Direction direction = getDirection(random);</span>
<span class="fc" id="L280">        splitVoxels(direction, voxels, voxelsA, voxelsB, center, random);</span>
        
        // Ensure that voxel split is connected and balanced.
<span class="fc" id="L283">        connectVoxels(voxelsA, voxelsB, this, random);</span>
<span class="fc" id="L284">        balanceVoxels(voxelsA, voxelsB, this, random);</span>
        
        // Select one split to keep for this location and return the other.
<span class="fc bfc" id="L287" title="All 2 branches covered.">        if (random.nextDouble() &lt; 0.5) {</span>
<span class="fc" id="L288">            return separateVoxels(voxelsA, voxelsB, random);</span>
        } else {
<span class="fc" id="L290">            return separateVoxels(voxelsB, voxelsA, random);</span>
        }
    }
    
    /**
     * Gets the voxel at the center of the location.
     * &lt;p&gt;
     * The center voxel is not guaranteed to exist in the location. If the
     * center voxel must exist, use {@code adjust()} to get the closest voxel
     * that exists.
     *
     * @return  the center voxel, returns {@code null} if there are no voxels
     */
    public Voxel getCenter() {
<span class="fc bfc" id="L304" title="All 2 branches covered.">        if (voxels.size() == 0) {</span>
<span class="fc" id="L305">            return null;</span>
        }
        
<span class="fc" id="L308">        int x = (int) Math.round(cx);</span>
<span class="fc" id="L309">        int y = (int) Math.round(cy);</span>
<span class="fc" id="L310">        int z = (int) Math.round(cz);</span>
        
<span class="fc" id="L312">        return new Voxel(x, y, z);</span>
    }
    
    /**
     * Gets the centroid of the location.
     * &lt;p&gt;
     * Note that centroid positions may not be integer values. If a specific
     * center voxel is needed, use {@code getCenter()} instead.
     *
     * @return  the location centroid
     */
    public double[] getCentroid() {
<span class="fc" id="L324">        return new double[] { cx, cy, cz };</span>
    }
    
    /**
     * Gets the centroid of the location for the region.
     * &lt;p&gt;
     * Note that centroid positions may not be integer values. If a specific
     * center voxel is needed, use {@code getCenter()} instead.
     *
     * @param region  the voxel region
     * @return  the location centroid
     */
    public double[] getCentroid(Region region) {
<span class="fc" id="L337">        return getCentroid();</span>
    }
    
    /**
     * Calculates the exact center of the location.
     */
    void calculateCenter() {
<span class="fc bfc" id="L344" title="All 2 branches covered.">        if (voxels.size() == 0) {</span>
<span class="fc" id="L345">            cx = 0;</span>
<span class="fc" id="L346">            cy = 0;</span>
<span class="fc" id="L347">            cx = 0;</span>
        } else {
<span class="fc" id="L349">            cx = voxels.stream().mapToDouble(voxel -&gt; voxel.x).sum() / voxels.size();</span>
<span class="fc" id="L350">            cy = voxels.stream().mapToDouble(voxel -&gt; voxel.y).sum() / voxels.size();</span>
<span class="fc" id="L351">            cz = voxels.stream().mapToDouble(voxel -&gt; voxel.z).sum() / voxels.size();</span>
        }
<span class="fc" id="L353">    }</span>
    
    /**
     * Updates the centroid of the location.
     *
     * @param x  the x position of the changed voxel
     * @param y  the y position of the changed voxel
     * @param z  the z position of the changed voxel
     * @param change  the direction of change (add = +1, remove = -1)
     */
    void updateCenter(int x, int y, int z, int change) {
<span class="fc bfc" id="L364" title="All 2 branches covered.">        if (voxels.size() == 0) {</span>
<span class="fc" id="L365">            cx = 0;</span>
<span class="fc" id="L366">            cy = 0;</span>
<span class="fc" id="L367">            cz = 0;</span>
        } else {
<span class="fc" id="L369">            cx = (cx * (volume - change) + change * x) / volume;</span>
<span class="fc" id="L370">            cy = (cy * (volume - change) + change * y) / volume;</span>
<span class="fc" id="L371">            cz = (cz * (volume - change) + change * z) / volume;</span>
        }
<span class="fc" id="L373">    }</span>
    
    /**
     * Makes a new {@code PottsLocation} with the given voxels.
     *
     * @param voxels  the list of voxels
     * @return  a new {@code PottsLocation}
     */
    abstract PottsLocation makeLocation(ArrayList&lt;Voxel&gt; voxels);
    
    /**
     * Converts volume and height to surface area.
     *
     * @param volume  the volume
     * @param height  the height
     * @return  the surface area
     */
    public abstract double convertSurface(double volume, double height);
    
    /**
     * Calculates surface of location.
     *
     * @return  the surface
     */
    abstract int calculateSurface();
    
    /**
     * Calculates the local change in surface of the location.
     *
     * @param voxel  the voxel the update is centered in
     * @return  the change in surface
     */
    abstract int updateSurface(Voxel voxel);
    
    /**
     * Calculates height of location.
     *
     * @return  the height
     */
    abstract int calculateHeight();
    
    /**
     * Calculates the local change in height of the location.
     *
     * @param voxel  the voxel the update is centered in
     * @return  the change in height
     */
    abstract int updateHeight(Voxel voxel);
    
    /**
     * Gets list of neighbors of a given voxel.
     *
     * @param focus  the focus voxel
     * @return  the list of neighbor voxels
     */
    abstract ArrayList&lt;Voxel&gt; getNeighbors(Voxel focus);
    
    /**
     * Calculates diameters in each direction.
     *
     * @return  the map of direction to diameter
     */
    abstract HashMap&lt;Direction, Integer&gt; getDiameters();
    
    /**
     * Selects the slice direction for a given maximum diameter direction.
     *
     * @param direction  the direction of the minimum diameter
     * @param diameters  the list of diameters
     * @return  the slice direction
     */
    abstract Direction getSlice(Direction direction, HashMap&lt;Direction, Integer&gt; diameters);
    
    /**
     * Selects specified number of voxels from a focus voxel.
     *
     * @param focus  the focus voxel
     * @param n  the number of voxels to select
     * @return  the list of selected voxels
     */
    abstract ArrayList&lt;Voxel&gt; getSelected(Voxel focus, double n);
    
    /**
     * Gets the direction of the slice.
     *
     * @param random  the seeded random number generator
     * @return  the direction of the slice
     */
    Direction getDirection(MersenneTwisterFast random) {
<span class="fc" id="L462">        HashMap&lt;Direction, Integer&gt; diameters = getDiameters();</span>
<span class="fc" id="L463">        ArrayList&lt;Direction&gt; directions = new ArrayList&lt;&gt;();</span>
        
        // Determine maximum diameter.
        int diameter;
<span class="fc" id="L467">        int maximumDiameter = 0;</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">        for (Direction direction : Direction.values()) {</span>
<span class="fc" id="L469">            diameter = diameters.getOrDefault(direction, 0);</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">            if (diameter &gt; maximumDiameter) {</span>
<span class="fc" id="L471">                maximumDiameter = diameter;</span>
            }
        }
        
        // Find all directions with the maximum diameter.
<span class="fc bfc" id="L476" title="All 2 branches covered.">        for (Direction direction : Direction.values()) {</span>
<span class="fc" id="L477">            diameter = diameters.getOrDefault(direction, 0);</span>
<span class="fc bfc" id="L478" title="All 2 branches covered.">            if (diameter &gt;= DIAMETER_RATIO * maximumDiameter) {</span>
<span class="fc" id="L479">                directions.add(direction);</span>
            }
        }
        
        // Randomly select one direction with the minimum diameter.
<span class="fc" id="L484">        Direction d = directions.get(random.nextInt(directions.size()));</span>
        
        // Convert diameter direction to slice direction.
<span class="fc bfc" id="L487" title="All 2 branches covered.">        return (d == Direction.UNDEFINED ? Direction.random(random) : getSlice(d, diameters));</span>
    }
    
    @Override
    public LocationContainer convert(int id) {
<span class="fc" id="L492">        return new PottsLocationContainer(id, getCenter(), voxels);</span>
    }
    
    /**
     * Separates the voxels in the list between this location and a new
     * location.
     *
     * @param voxelsA  the list of voxels for this location
     * @param voxelsB  the list of voxels for the split location
     * @param random  the seeded random number generator
     * @return  a {@link arcade.core.env.location.Location} object with split voxels
     */
    Location separateVoxels(ArrayList&lt;Voxel&gt; voxelsA, ArrayList&lt;Voxel&gt; voxelsB,
                            MersenneTwisterFast random) {
<span class="fc" id="L506">        voxels.clear();</span>
<span class="fc" id="L507">        voxels.addAll(voxelsA);</span>
<span class="fc" id="L508">        volume = voxels.size();</span>
<span class="fc" id="L509">        surface = calculateSurface();</span>
<span class="fc" id="L510">        height = calculateHeight();</span>
<span class="fc" id="L511">        calculateCenter();</span>
<span class="fc" id="L512">        return makeLocation(voxelsB);</span>
    }
    
    /**
     * Splits the voxels in the location along a given direction.
     *
     * @param direction  the direction of the slice
     * @param voxels  the list of voxels
     * @param voxelsA  the container list for the first half of the split
     * @param voxelsB  the container list for the second half of the split
     * @param center  the center voxel
     * @param random  the seeded random number generator
     */
    static void splitVoxels(Direction direction, ArrayList&lt;Voxel&gt; voxels,
                            ArrayList&lt;Voxel&gt; voxelsA, ArrayList&lt;Voxel&gt; voxelsB,
                            Voxel center, MersenneTwisterFast random) {
<span class="fc bfc" id="L528" title="All 2 branches covered.">        for (Voxel voxel : voxels) {</span>
<span class="fc bfc" id="L529" title="All 10 branches covered.">            switch (direction) {</span>
                case ZX_PLANE:
<span class="fc bfc" id="L531" title="All 2 branches covered.">                    if (voxel.y &lt; center.y) {</span>
<span class="fc" id="L532">                        voxelsA.add(voxel);</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">                    } else if (voxel.y &gt; center.y) {</span>
<span class="fc" id="L534">                        voxelsB.add(voxel);</span>
                    } else {
<span class="fc bfc" id="L536" title="All 2 branches covered.">                        if (random.nextDouble() &gt; 0.5) {</span>
<span class="fc" id="L537">                            voxelsA.add(voxel);</span>
                        } else {
<span class="fc" id="L539">                            voxelsB.add(voxel);</span>
                        }
                    }
<span class="fc" id="L542">                    break;</span>
                case YZ_PLANE:
<span class="fc bfc" id="L544" title="All 2 branches covered.">                    if (voxel.x &lt; center.x) {</span>
<span class="fc" id="L545">                        voxelsA.add(voxel);</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">                    } else if (voxel.x &gt; center.x) {</span>
<span class="fc" id="L547">                        voxelsB.add(voxel);</span>
                    } else {
<span class="fc bfc" id="L549" title="All 2 branches covered.">                        if (random.nextDouble() &gt; 0.5) {</span>
<span class="fc" id="L550">                            voxelsA.add(voxel);</span>
                        } else {
<span class="fc" id="L552">                            voxelsB.add(voxel);</span>
                        }
                    }
<span class="fc" id="L555">                    break;</span>
                case XY_PLANE:
<span class="fc bfc" id="L557" title="All 2 branches covered.">                    if (voxel.z &lt; center.z) {</span>
<span class="fc" id="L558">                        voxelsA.add(voxel);</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">                    } else if (voxel.z &gt; center.z) {</span>
<span class="fc" id="L560">                        voxelsB.add(voxel);</span>
                    } else {
<span class="fc bfc" id="L562" title="All 2 branches covered.">                        if (random.nextDouble() &gt; 0.5) {</span>
<span class="fc" id="L563">                            voxelsA.add(voxel);</span>
                        } else {
<span class="fc" id="L565">                            voxelsB.add(voxel);</span>
                        }
                    }
<span class="fc" id="L568">                    break;</span>
                case NEGATIVE_XY:
<span class="fc bfc" id="L570" title="All 2 branches covered.">                    if (voxel.x - center.x &gt; center.y - voxel.y) {</span>
<span class="fc" id="L571">                        voxelsA.add(voxel);</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">                    } else if (voxel.x - center.x &lt; center.y - voxel.y) {</span>
<span class="fc" id="L573">                        voxelsB.add(voxel);</span>
                    } else {
<span class="fc bfc" id="L575" title="All 2 branches covered.">                        if (random.nextDouble() &gt; 0.5) {</span>
<span class="fc" id="L576">                            voxelsA.add(voxel);</span>
                        } else {
<span class="fc" id="L578">                            voxelsB.add(voxel);</span>
                        }
                    }
<span class="fc" id="L581">                    break;</span>
                case POSITIVE_XY:
<span class="fc bfc" id="L583" title="All 2 branches covered.">                    if (voxel.x - center.x &gt; voxel.y - center.y) {</span>
<span class="fc" id="L584">                        voxelsA.add(voxel);</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">                    } else if (voxel.x - center.x &lt; voxel.y - center.y) {</span>
<span class="fc" id="L586">                        voxelsB.add(voxel);</span>
                    } else {
<span class="fc bfc" id="L588" title="All 2 branches covered.">                        if (random.nextDouble() &gt; 0.5) {</span>
<span class="fc" id="L589">                            voxelsA.add(voxel);</span>
                        } else {
<span class="fc" id="L591">                            voxelsB.add(voxel);</span>
                        }
                    }
<span class="fc" id="L594">                    break;</span>
                case NEGATIVE_YZ:
<span class="fc bfc" id="L596" title="All 2 branches covered.">                    if (voxel.y - center.y &gt; center.z - voxel.z) {</span>
<span class="fc" id="L597">                        voxelsA.add(voxel);</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">                    } else if (voxel.y - center.y &lt; center.z - voxel.z) {</span>
<span class="fc" id="L599">                        voxelsB.add(voxel);</span>
                    } else {
<span class="fc bfc" id="L601" title="All 2 branches covered.">                        if (random.nextDouble() &gt; 0.5) {</span>
<span class="fc" id="L602">                            voxelsA.add(voxel);</span>
                        } else {
<span class="fc" id="L604">                            voxelsB.add(voxel);</span>
                        }
                    }
<span class="fc" id="L607">                    break;</span>
                case POSITIVE_YZ:
<span class="fc bfc" id="L609" title="All 2 branches covered.">                    if (voxel.y - center.y &gt; voxel.z - center.z) {</span>
<span class="fc" id="L610">                        voxelsA.add(voxel);</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">                    } else if (voxel.y - center.y &lt; voxel.z - center.z) {</span>
<span class="fc" id="L612">                        voxelsB.add(voxel);</span>
                    } else {
<span class="fc bfc" id="L614" title="All 2 branches covered.">                        if (random.nextDouble() &gt; 0.5) {</span>
<span class="fc" id="L615">                            voxelsA.add(voxel);</span>
                        } else {
<span class="fc" id="L617">                            voxelsB.add(voxel);</span>
                        }
                    }
<span class="fc" id="L620">                    break;</span>
                case NEGATIVE_ZX:
<span class="fc bfc" id="L622" title="All 2 branches covered.">                    if (voxel.z - center.z &gt; center.x - voxel.x) {</span>
<span class="fc" id="L623">                        voxelsA.add(voxel);</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">                    } else if (voxel.z - center.z &lt; center.x - voxel.x) {</span>
<span class="fc" id="L625">                        voxelsB.add(voxel);</span>
                    } else {
<span class="fc bfc" id="L627" title="All 2 branches covered.">                        if (random.nextDouble() &gt; 0.5) {</span>
<span class="fc" id="L628">                            voxelsA.add(voxel);</span>
                        } else {
<span class="fc" id="L630">                            voxelsB.add(voxel);</span>
                        }
                    }
<span class="fc" id="L633">                    break;</span>
                case POSITIVE_ZX:
<span class="fc bfc" id="L635" title="All 2 branches covered.">                    if (voxel.z - center.z &gt; voxel.x - center.x) {</span>
<span class="fc" id="L636">                        voxelsA.add(voxel);</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">                    } else if (voxel.z - center.z &lt; voxel.x - center.x) {</span>
<span class="fc" id="L638">                        voxelsB.add(voxel);</span>
                    } else {
<span class="fc bfc" id="L640" title="All 2 branches covered.">                        if (random.nextDouble() &gt; 0.5) {</span>
<span class="fc" id="L641">                            voxelsA.add(voxel);</span>
                        } else {
<span class="fc" id="L643">                            voxelsB.add(voxel);</span>
                        }
                    }
<span class="fc" id="L646">                    break;</span>
                default:
                    break;
            }
<span class="fc" id="L650">        }</span>
<span class="fc" id="L651">    }</span>
    
    /**
     * Connects voxels in the splits.
     * &lt;p&gt;
     * Checks that the voxels in each split are connected. If not, then move the
     * unconnected voxels into the other split.
     *
     * @param voxelsA  the list for the first half of the split
     * @param voxelsB  the list for the second half of the split
     * @param location  the location instance
     * @param random  the seeded random number generator
     */
    static void connectVoxels(ArrayList&lt;Voxel&gt; voxelsA, ArrayList&lt;Voxel&gt; voxelsB,
                              PottsLocation location, MersenneTwisterFast random) {
        // Check that both coordinate lists are simply connected.
<span class="fc" id="L667">        ArrayList&lt;Voxel&gt; unconnectedA = checkVoxels(voxelsA, location, random, true);</span>
<span class="fc" id="L668">        ArrayList&lt;Voxel&gt; unconnectedB = checkVoxels(voxelsB, location, random, true);</span>
        
        // If either coordinate list is not connected, attempt to connect them
        // by adding in the unconnected coordinates of the other list.
<span class="fc bfc" id="L672" title="All 4 branches covered.">        while (unconnectedA != null || unconnectedB != null) {</span>
            ArrayList&lt;Voxel&gt; unconnectedAB;
            ArrayList&lt;Voxel&gt; unconnectedBA;
            
<span class="fc bfc" id="L676" title="All 2 branches covered.">            if (unconnectedA != null) {</span>
<span class="fc" id="L677">                voxelsB.addAll(unconnectedA);</span>
            }
<span class="fc" id="L679">            unconnectedBA = checkVoxels(voxelsB, location, random, true);</span>
            
<span class="fc bfc" id="L681" title="All 2 branches covered.">            if (unconnectedB != null) {</span>
<span class="fc" id="L682">                voxelsA.addAll(unconnectedB);</span>
            }
<span class="fc" id="L684">            unconnectedAB = checkVoxels(voxelsA, location, random, true);</span>
            
<span class="fc" id="L686">            unconnectedA = unconnectedAB;</span>
<span class="fc" id="L687">            unconnectedB = unconnectedBA;</span>
<span class="fc" id="L688">        }</span>
<span class="fc" id="L689">    }</span>
    
    /**
     * Balances voxels in the splits.
     * &lt;p&gt;
     * Checks that the number of voxels in each split are within a certain
     * difference. If not, then add voxels from the larger split into the
     * smaller split such that both splits are still connected. For small split
     * sizes, there may not be a valid split that is both connected and within
     * the difference; in these cases, connectedness is prioritized and the
     * splits are returned not balanced.
     *
     * @param voxelsA  the list for the first half of the split
     * @param voxelsB  the list for the second half of the split
     * @param location  the location instance
     * @param random  the seeded random number generator
     */
    static void balanceVoxels(ArrayList&lt;Voxel&gt; voxelsA, ArrayList&lt;Voxel&gt; voxelsB,
                              PottsLocation location, MersenneTwisterFast random) {
<span class="fc" id="L708">        int nA = voxelsA.size();</span>
<span class="fc" id="L709">        int nB = voxelsB.size();</span>
        
<span class="fc bfc" id="L711" title="All 2 branches covered.">        while (Math.abs(nA - nB) &gt; Math.ceil((nA + nB) * BALANCE_DIFFERENCE)) {</span>
            ArrayList&lt;Voxel&gt; fromVoxels;
            ArrayList&lt;Voxel&gt; toVoxels;
            
<span class="fc bfc" id="L715" title="All 2 branches covered.">            if (nA &gt; nB) {</span>
<span class="fc" id="L716">                fromVoxels = voxelsA;</span>
<span class="fc" id="L717">                toVoxels = voxelsB;</span>
            } else {
<span class="fc" id="L719">                fromVoxels = voxelsB;</span>
<span class="fc" id="L720">                toVoxels = voxelsA;</span>
            }
            
            // Get all valid neighbor voxels.
<span class="fc" id="L724">            LinkedHashSet&lt;Voxel&gt; neighborSet = new LinkedHashSet&lt;&gt;();</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">            for (Voxel voxel : toVoxels) {</span>
<span class="fc" id="L726">                ArrayList&lt;Voxel&gt; neighbors = location.getNeighbors(voxel);</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">                for (Voxel neighbor : neighbors) {</span>
<span class="fc bfc" id="L728" title="All 2 branches covered.">                    if (!toVoxels.contains(neighbor)) {</span>
<span class="fc" id="L729">                        neighborSet.add(neighbor);</span>
                    }
<span class="fc" id="L731">                }</span>
<span class="fc" id="L732">            }</span>
            
            // If one list is empty, add all voxels in other list as neighbors.
<span class="fc bfc" id="L735" title="All 2 branches covered.">            if (toVoxels.size() == 0) {</span>
<span class="fc" id="L736">                neighborSet.addAll(fromVoxels);</span>
            }
            
<span class="fc" id="L739">            ArrayList&lt;Voxel&gt; neighborList = new ArrayList&lt;&gt;(neighborSet);</span>
<span class="fc" id="L740">            Utilities.shuffleList(neighborList, random);</span>
            
            // Select a neighbor to move from one list to the other.
<span class="fc" id="L743">            boolean added = false;</span>
<span class="fc" id="L744">            ArrayList&lt;Voxel&gt; invalidCoords = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">            for (Voxel voxel : neighborList) {</span>
<span class="fc bfc" id="L746" title="All 2 branches covered.">                if (fromVoxels.contains(voxel)) {</span>
<span class="fc" id="L747">                    toVoxels.add(voxel);</span>
<span class="fc" id="L748">                    fromVoxels.remove(voxel);</span>
                    
                    // Check that removal of coordinate does not cause the list
                    // to become unconnected.
<span class="fc" id="L752">                    ArrayList&lt;Voxel&gt; unconnected = checkVoxels(fromVoxels, location, random, false);</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">                    if (unconnected == null) {</span>
<span class="fc" id="L754">                        added = true;</span>
<span class="fc" id="L755">                        break;</span>
                    } else {
<span class="fc" id="L757">                        fromVoxels.add(voxel);</span>
<span class="fc" id="L758">                        toVoxels.remove(voxel);</span>
<span class="fc" id="L759">                        invalidCoords.add(voxel);</span>
                    }
                }
<span class="fc" id="L762">            }</span>
            
<span class="fc bfc" id="L764" title="All 2 branches covered.">            if (!added) {</span>
<span class="fc" id="L765">                toVoxels.addAll(invalidCoords);</span>
<span class="fc" id="L766">                fromVoxels.removeAll(invalidCoords);</span>
<span class="fc" id="L767">                connectVoxels(voxelsA, voxelsB, location, random);</span>
<span class="fc" id="L768">                break;</span>
            }
            
<span class="fc" id="L771">            nA = voxelsA.size();</span>
<span class="fc" id="L772">            nB = voxelsB.size();</span>
<span class="fc" id="L773">        }</span>
<span class="fc" id="L774">    }</span>
    
    /**
     * Checks voxels in the list for connectedness.
     * &lt;p&gt;
     * All the connected voxels from a random starting voxel are found and
     * marked as visited. If there are no remaining unvisited voxels, then the
     * list is fully connected. If there are, then the smaller of the visited or
     * unvisited lists is returned.
     * &lt;p&gt;
     * Some voxel lists may have more than one unconnected section.
     *
     * @param voxels  the list of voxels
     * @param location  the location instance
     * @param random  the seeded random number generator
     * @param update  {@code true} if list should be updated, {@code false} otherwise
     * @return  a list of unconnected voxels, {@code null} if list is connected
     */
    static ArrayList&lt;Voxel&gt; checkVoxels(ArrayList&lt;Voxel&gt; voxels, PottsLocation location,
                                        MersenneTwisterFast random, boolean update) {
<span class="fc bfc" id="L794" title="All 2 branches covered.">        if (voxels.size() == 0) {</span>
<span class="fc" id="L795">            return null;</span>
        }
        
<span class="fc" id="L798">        ArrayList&lt;Voxel&gt; unvisited = new ArrayList&lt;&gt;(voxels);</span>
<span class="fc" id="L799">        ArrayList&lt;Voxel&gt; visited = new ArrayList&lt;&gt;();</span>
        ArrayList&lt;Voxel&gt; nextList;
        LinkedHashSet&lt;Voxel&gt; nextSet;
<span class="fc" id="L802">        LinkedHashSet&lt;Voxel&gt; currSet = new LinkedHashSet&lt;&gt;();</span>
        
<span class="fc" id="L804">        currSet.add(unvisited.get(random.nextInt(unvisited.size())));</span>
<span class="fc" id="L805">        int currSize = currSet.size();</span>
        
<span class="fc bfc" id="L807" title="All 2 branches covered.">        while (currSize &gt; 0) {</span>
<span class="fc" id="L808">            nextSet = new LinkedHashSet&lt;&gt;();</span>
            
            // Iterate through each coordinate in current coordinate set.
<span class="fc bfc" id="L811" title="All 2 branches covered.">            for (Voxel voxel : currSet) {</span>
<span class="fc" id="L812">                nextList = new ArrayList&lt;&gt;();</span>
                
                // Iterate through each connected direction from current voxel
                // and add to neighbor list if it exists.
<span class="fc" id="L816">                ArrayList&lt;Voxel&gt; neighbors = location.getNeighbors(voxel);</span>
<span class="fc bfc" id="L817" title="All 2 branches covered.">                for (Voxel neighbor : neighbors) {</span>
<span class="fc bfc" id="L818" title="All 2 branches covered.">                    if (unvisited.contains(neighbor)) {</span>
<span class="fc" id="L819">                        nextList.add(neighbor);</span>
                    }
<span class="fc" id="L821">                }</span>
                
                // Updated next voxel set with list of neighbors.
<span class="fc" id="L824">                nextSet.addAll(nextList);</span>
<span class="fc" id="L825">                visited.add(voxel);</span>
<span class="fc" id="L826">                unvisited.remove(voxel);</span>
<span class="fc" id="L827">            }</span>
            
<span class="fc" id="L829">            currSet = nextSet;</span>
<span class="fc" id="L830">            currSize = currSet.size();</span>
        }
        
        // If not all coordinates have been visited, then the list of
        // coordinates is not connected.
<span class="fc bfc" id="L835" title="All 2 branches covered.">        if (unvisited.size() != 0) {</span>
<span class="fc bfc" id="L836" title="All 2 branches covered.">            if (unvisited.size() &gt; visited.size()) {</span>
<span class="fc bfc" id="L837" title="All 2 branches covered.">                if (update) {</span>
<span class="fc" id="L838">                    voxels.removeAll(visited);</span>
                }
<span class="fc" id="L840">                return visited;</span>
            } else {
<span class="fc bfc" id="L842" title="All 2 branches covered.">                if (update) {</span>
<span class="fc" id="L843">                    voxels.removeAll(unvisited);</span>
                }
<span class="fc" id="L845">                return unvisited;</span>
            }
        } else {
<span class="fc" id="L848">            return null;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>