<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PottsCell.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">arcade</a> &gt; <a href="index.source.html" class="el_package">arcade.potts.agent.cell</a> &gt; <span class="el_source">PottsCell.java</span></div><h1>PottsCell.java</h1><pre class="source lang-java linenums">package arcade.potts.agent.cell;

import java.util.EnumMap;
import sim.engine.Schedule;
import sim.engine.SimState;
import sim.engine.Stoppable;
import arcade.core.agent.cell.Cell;
import arcade.core.agent.cell.CellContainer;
import arcade.core.agent.cell.CellState;
import arcade.core.agent.module.Module;
import arcade.core.agent.process.Process;
import arcade.core.agent.process.ProcessDomain;
import arcade.core.env.location.Location;
import arcade.core.sim.Simulation;
import arcade.core.util.GrabBag;
import arcade.core.util.Parameters;
import arcade.potts.agent.module.PottsModule;
import arcade.potts.env.location.PottsLocation;
import static arcade.potts.util.PottsEnums.Ordering;
import static arcade.potts.util.PottsEnums.Region;

/**
 * Implementation of {@link Cell} for potts models.
 *
 * &lt;p&gt;{@code PottsCell} agents exist in one of five states: quiescent, proliferative, apoptotic,
 * necrotic, or autotic. Each state may be further divided into relevant phases.
 *
 * &lt;p&gt;General order of rules for the {@code PottsCell} step:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;update age
 *   &lt;li&gt;step state module
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Cell parameters are tracked using a map between the parameter name and value.
 *
 * &lt;p&gt;To integrate with the Potts layer, {@code PottsCell} agents also contain critical and target
 * volumes and surfaces. Additional parameters specific to each term in the Hamiltonian are tracked
 * by the specific Hamiltonian class instance.
 */
public abstract class PottsCell implements Cell {
    /** Stopper used to stop this agent from being stepped in the schedule. */
    Stoppable stopper;

    /** Cell {@link Location} object. */
    private final PottsLocation location;

    /** Unique cell ID. */
    final int id;

    /** Cell parent ID. */
    final int parent;

    /** Cell population index. */
    final int pop;

    /** Cell state. */
    private CellState state;

    /** Cell age [ticks]. */
    int age;

    /** Number of divisions. */
    int divisions;

    /** {@code true} if the cell has regions, {@code false} otherwise. */
    final boolean hasRegions;

    /** Target cell volume [voxels]. */
    private double targetVolume;

    /** Target region cell volumes [voxels]. */
    private final EnumMap&lt;Region, Double&gt; targetRegionVolumes;

    /** Target cell surface [voxels]. */
    private double targetSurface;

    /** Target region cell surfaces [voxels]. */
    private final EnumMap&lt;Region, Double&gt; targetRegionSurfaces;

    /** Critical volume for cell [voxels]. */
    final double criticalVolume;

    /** Critical volumes for cell by region [voxels]. */
    final EnumMap&lt;Region, Double&gt; criticalRegionVolumes;

    /** Critical height for cell [voxels]. */
    final double criticalHeight;

    /** Critical heights for cell by region [voxels]. */
    final EnumMap&lt;Region, Double&gt; criticalRegionHeights;

    /** Cell state module. */
    protected Module module;

    /** Cell parameters. */
    final Parameters parameters;

    /** Cell population links. */
    final GrabBag links;

    /**
     * Creates a {@code PottsCell} agent.
     *
     * @param container the cell container
     * @param location the {@link Location} of the cell
     * @param parameters the cell parameters
     * @param links the map of population links
     */
    public PottsCell(
<span class="fc" id="L111">            PottsCellContainer container, Location location, Parameters parameters, GrabBag links) {</span>
<span class="fc" id="L112">        this.id = container.id;</span>
<span class="fc" id="L113">        this.parent = container.parent;</span>
<span class="fc" id="L114">        this.pop = container.pop;</span>
<span class="fc" id="L115">        this.age = container.age;</span>
<span class="fc" id="L116">        this.divisions = container.divisions;</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">        this.hasRegions = container.regionVoxels != null;</span>
<span class="fc" id="L118">        this.location = (PottsLocation) location;</span>
<span class="fc" id="L119">        this.parameters = parameters;</span>
<span class="fc" id="L120">        this.links = links;</span>
<span class="fc" id="L121">        this.criticalVolume = container.criticalVolume;</span>
<span class="fc" id="L122">        this.criticalHeight = container.criticalHeight;</span>

<span class="fc" id="L124">        setState(container.state);</span>

<span class="fc bfc" id="L126" title="All 4 branches covered.">        if (module != null &amp;&amp; container.phase != null) {</span>
<span class="fc" id="L127">            ((PottsModule) module).setPhase(container.phase);</span>
        }

<span class="fc bfc" id="L130" title="All 2 branches covered.">        if (hasRegions) {</span>
<span class="fc" id="L131">            this.criticalRegionVolumes = container.criticalRegionVolumes.clone();</span>
<span class="fc" id="L132">            this.criticalRegionHeights = container.criticalRegionHeights.clone();</span>
<span class="fc" id="L133">            this.targetRegionVolumes = new EnumMap&lt;&gt;(Region.class);</span>
<span class="fc" id="L134">            this.targetRegionSurfaces = new EnumMap&lt;&gt;(Region.class);</span>
        } else {
<span class="fc" id="L136">            this.criticalRegionVolumes = null;</span>
<span class="fc" id="L137">            this.criticalRegionHeights = null;</span>
<span class="fc" id="L138">            this.targetRegionVolumes = null;</span>
<span class="fc" id="L139">            this.targetRegionSurfaces = null;</span>
        }
<span class="fc" id="L141">    }</span>

    @Override
    public int getID() {
<span class="fc" id="L145">        return id;</span>
    }

    @Override
    public int getParent() {
<span class="fc" id="L150">        return parent;</span>
    }

    @Override
    public int getPop() {
<span class="fc" id="L155">        return pop;</span>
    }

    @Override
    public CellState getState() {
<span class="fc" id="L160">        return state;</span>
    }

    @Override
    public int getAge() {
<span class="fc" id="L165">        return age;</span>
    }

    @Override
    public int getDivisions() {
<span class="fc" id="L170">        return divisions;</span>
    }

    @Override
    public Location getLocation() {
<span class="fc" id="L175">        return location;</span>
    }

    @Override
    public Module getModule() {
<span class="fc" id="L180">        return module;</span>
    }

    @Override
    public Process getProcess(ProcessDomain domain) {
<span class="fc" id="L185">        return null;</span>
    }

    @Override
    public Parameters getParameters() {
<span class="fc" id="L190">        return parameters;</span>
    }

    /**
     * Checks if the cell has regions.
     *
     * @return {@code true} if the cell has regions, {@code false} otherwise
     */
    public boolean hasRegions() {
<span class="fc" id="L199">        return hasRegions;</span>
    }

    @Override
    public double getVolume() {
<span class="fc" id="L204">        return location.getVolume();</span>
    }

    /**
     * Gets the cell volume for a region.
     *
     * @param region the region
     * @return the cell region volume
     */
    public double getVolume(Region region) {
<span class="fc bfc" id="L214" title="All 2 branches covered.">        return (hasRegions ? location.getVolume(region) : 0);</span>
    }

    @Override
    public double getHeight() {
<span class="fc" id="L219">        return location.getHeight();</span>
    }

    /**
     * Gets the cell height for a region.
     *
     * @param region the region
     * @return the cell region height
     */
    public double getHeight(Region region) {
<span class="fc bfc" id="L229" title="All 2 branches covered.">        return (hasRegions ? location.getHeight(region) : 0);</span>
    }

    /**
     * Gets the cell surface.
     *
     * @return the cell surface
     */
    public double getSurface() {
<span class="fc" id="L238">        return location.getSurface();</span>
    }

    /**
     * Gets the cell surface for a region.
     *
     * @param region the region
     * @return the cell region surface
     */
    public double getSurface(Region region) {
<span class="fc bfc" id="L248" title="All 2 branches covered.">        return (hasRegions ? location.getSurface(region) : 0);</span>
    }

    /**
     * Gets the target volume.
     *
     * @return the target volume
     */
    public double getTargetVolume() {
<span class="fc" id="L257">        return targetVolume;</span>
    }

    /**
     * Gets the target volume for a region.
     *
     * @param region the region
     * @return the target region volume
     */
    public double getTargetVolume(Region region) {
<span class="fc bfc" id="L267" title="All 4 branches covered.">        return (hasRegions &amp;&amp; targetRegionVolumes.containsKey(region)</span>
<span class="fc" id="L268">                ? targetRegionVolumes.get(region)</span>
<span class="fc" id="L269">                : 0);</span>
    }

    /**
     * Gets the target surface.
     *
     * @return the target surface
     */
    public double getTargetSurface() {
<span class="fc" id="L278">        return targetSurface;</span>
    }

    /**
     * Gets the target surface for a region.
     *
     * @param region the region
     * @return the target region surface
     */
    public double getTargetSurface(Region region) {
<span class="fc bfc" id="L288" title="All 4 branches covered.">        return (hasRegions &amp;&amp; targetRegionSurfaces.containsKey(region)</span>
<span class="fc" id="L289">                ? targetRegionSurfaces.get(region)</span>
<span class="fc" id="L290">                : 0);</span>
    }

    @Override
    public double getCriticalVolume() {
<span class="fc" id="L295">        return criticalVolume;</span>
    }

    /**
     * Gets the critical volume for a region.
     *
     * @param region the region
     * @return the critical region volume
     */
    public double getCriticalVolume(Region region) {
<span class="fc bfc" id="L305" title="All 4 branches covered.">        return (hasRegions &amp;&amp; criticalRegionVolumes.containsKey(region)</span>
<span class="fc" id="L306">                ? criticalRegionVolumes.get(region)</span>
<span class="fc" id="L307">                : 0);</span>
    }

    @Override
    public double getCriticalHeight() {
<span class="fc" id="L312">        return criticalHeight;</span>
    }

    /**
     * Gets the critical height for a region.
     *
     * @param region the region
     * @return the critical region height
     */
    public double getCriticalHeight(Region region) {
<span class="fc bfc" id="L322" title="All 4 branches covered.">        return (hasRegions &amp;&amp; criticalRegionHeights.containsKey(region)</span>
<span class="fc" id="L323">                ? criticalRegionHeights.get(region)</span>
<span class="fc" id="L324">                : 0);</span>
    }

    @Override
    public void stop() {
<span class="fc" id="L329">        stopper.stop();</span>
<span class="fc" id="L330">    }</span>

    @Override
    public void setState(CellState newState) {
<span class="fc" id="L334">        this.state = newState;</span>
<span class="fc" id="L335">        setStateModule(newState);</span>
<span class="fc" id="L336">    }</span>

    /**
     * Sets the state module for the cell.
     *
     * @param newState the cell state
     */
    abstract void setStateModule(CellState newState);

    @Override
    public void schedule(Schedule schedule) {
<span class="fc" id="L347">        stopper = schedule.scheduleRepeating(this, Ordering.CELLS.ordinal(), 1);</span>
<span class="fc" id="L348">    }</span>

    /**
     * Initializes the potts arrays with the cell.
     *
     * @param ids the {@link arcade.potts.sim.Potts} array for ids
     * @param regions the {@link arcade.potts.sim.Potts} array for regions
     */
    public void initialize(int[][][] ids, int[][][] regions) {
<span class="fc" id="L357">        location.update(id, ids, regions);</span>

<span class="fc" id="L359">        targetVolume = location.getVolume();</span>
<span class="fc" id="L360">        targetSurface = location.getSurface();</span>

<span class="fc bfc" id="L362" title="All 2 branches covered.">        if (!hasRegions) {</span>
<span class="fc" id="L363">            return;</span>
        }

<span class="fc bfc" id="L366" title="All 2 branches covered.">        for (Region region : location.getRegions()) {</span>
<span class="fc" id="L367">            targetRegionVolumes.put(region, location.getVolume(region));</span>
<span class="fc" id="L368">            targetRegionSurfaces.put(region, location.getSurface(region));</span>
<span class="fc" id="L369">        }</span>
<span class="fc" id="L370">    }</span>

    /**
     * Resets the potts arrays with the cell.
     *
     * @param ids the {@link arcade.potts.sim.Potts} array for ids
     * @param regions the {@link arcade.potts.sim.Potts} array for regions
     */
    public void reset(int[][][] ids, int[][][] regions) {
<span class="fc" id="L379">        location.update(id, ids, regions);</span>

<span class="fc" id="L381">        targetVolume = criticalVolume;</span>
<span class="fc" id="L382">        targetSurface = location.convertSurface(targetVolume, criticalHeight);</span>

<span class="fc bfc" id="L384" title="All 2 branches covered.">        if (!hasRegions) {</span>
<span class="fc" id="L385">            return;</span>
        }

<span class="fc bfc" id="L388" title="All 2 branches covered.">        for (Region region : location.getRegions()) {</span>
<span class="fc" id="L389">            double regionHeight = criticalRegionHeights.get(region);</span>
<span class="fc" id="L390">            double regionVolume = criticalRegionVolumes.get(region);</span>
<span class="fc" id="L391">            targetRegionVolumes.put(region, regionVolume);</span>
<span class="fc" id="L392">            targetRegionSurfaces.put(region, location.convertSurface(regionVolume, regionHeight));</span>
<span class="fc" id="L393">        }</span>
<span class="fc" id="L394">    }</span>

    @Override
    public void step(SimState simstate) {
<span class="fc" id="L398">        Simulation sim = (Simulation) simstate;</span>

        // Increase age of cell.
<span class="fc" id="L401">        age++;</span>

        // Step the module for the cell state.
<span class="fc" id="L404">        module.step(simstate.random, sim);</span>
<span class="fc" id="L405">    }</span>

    /**
     * Sets the target volume and surface for the cell.
     *
     * @param volume the target volume
     * @param surface the target surface
     */
    public void setTargets(double volume, double surface) {
<span class="fc" id="L414">        targetVolume = volume;</span>
<span class="fc" id="L415">        targetSurface = surface;</span>
<span class="fc" id="L416">    }</span>

    /**
     * Sets the target volume and surface for a region.
     *
     * @param region the region
     * @param volume the target volume
     * @param surface the target surface
     */
    public void setTargets(Region region, double volume, double surface) {
<span class="fc" id="L426">        targetRegionVolumes.put(region, volume);</span>
<span class="fc" id="L427">        targetRegionSurfaces.put(region, surface);</span>
<span class="fc" id="L428">    }</span>

    /**
     * Updates target volume and surface area. When scale is greater than one, volume increases by
     * given rate. When scale is less than one, volume decreases by given rate. If scale is one,
     * sizes are not changed.
     *
     * @param rate the rate of change
     * @param scale the relative final size scaling
     */
    public void updateTarget(double rate, double scale) {
<span class="fc bfc" id="L439" title="All 2 branches covered.">        if (scale == 1) {</span>
<span class="fc" id="L440">            return;</span>
        }

<span class="fc bfc" id="L443" title="All 2 branches covered.">        if (hasRegions) {</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">            if (scale &lt; 1) {</span>
<span class="fc" id="L445">                rate = Math.min(rate, targetRegionVolumes.get(Region.DEFAULT));</span>
            }
<span class="fc" id="L447">            double updateVolume = targetRegionVolumes.get(Region.DEFAULT) - targetVolume;</span>
<span class="fc" id="L448">            targetRegionVolumes.put(Region.DEFAULT, updateVolume);</span>
        }

<span class="fc bfc" id="L451" title="All 2 branches covered.">        if (scale &gt; 1) {</span>
<span class="fc" id="L452">            targetVolume += rate;</span>
<span class="fc" id="L453">            targetVolume = Math.min(targetVolume, scale * criticalVolume);</span>
        } else {
<span class="fc" id="L455">            targetVolume -= rate;</span>
<span class="fc" id="L456">            targetVolume = Math.max(targetVolume, scale * criticalVolume);</span>
        }

<span class="fc" id="L459">        targetSurface = location.convertSurface(targetVolume, criticalHeight);</span>

<span class="fc bfc" id="L461" title="All 2 branches covered.">        if (hasRegions) {</span>
<span class="fc" id="L462">            double updateVolume = targetRegionVolumes.get(Region.DEFAULT) + targetVolume;</span>
<span class="fc" id="L463">            targetRegionVolumes.put(Region.DEFAULT, updateVolume);</span>

<span class="fc" id="L465">            double criticalRegionHeight = criticalRegionHeights.get(Region.DEFAULT);</span>
<span class="fc" id="L466">            double updateSurface = location.convertSurface(updateVolume, criticalRegionHeight);</span>
<span class="fc" id="L467">            targetRegionSurfaces.put(Region.DEFAULT, updateSurface);</span>
        }
<span class="fc" id="L469">    }</span>

    /**
     * Updates target volume and surface area for a region.
     *
     * &lt;p&gt;If the region is the DEFAULT region, then updates are the same as for a cell without
     * regions.
     *
     * @param region the region
     * @param rate the rate of change
     * @param scale the relative final size scaling
     */
    public void updateTarget(Region region, double rate, double scale) {
<span class="fc bfc" id="L482" title="All 4 branches covered.">        if (!hasRegions || scale == 1) {</span>
<span class="fc" id="L483">            return;</span>
        }

<span class="fc bfc" id="L486" title="All 2 branches covered.">        if (region == Region.DEFAULT) {</span>
<span class="fc" id="L487">            updateTarget(rate, scale);</span>
<span class="fc" id="L488">            return;</span>
        }

<span class="fc bfc" id="L491" title="All 2 branches covered.">        if (scale &gt; 1) {</span>
<span class="fc" id="L492">            rate = Math.min(rate, targetRegionVolumes.get(Region.DEFAULT));</span>
        }

<span class="fc" id="L495">        double criticalRegionVolume = criticalRegionVolumes.get(region);</span>
<span class="fc" id="L496">        double criticalRegionHeight = criticalRegionHeights.get(region);</span>

<span class="fc" id="L498">        double updateVolume = targetRegionVolumes.get(region);</span>

<span class="fc" id="L500">        double preUpdateVolume = targetRegionVolumes.get(Region.DEFAULT) + updateVolume;</span>
<span class="fc" id="L501">        targetRegionVolumes.put(Region.DEFAULT, preUpdateVolume);</span>

<span class="fc bfc" id="L503" title="All 2 branches covered.">        if (scale &gt; 1) {</span>
<span class="fc" id="L504">            updateVolume += rate;</span>
<span class="fc" id="L505">            updateVolume = Math.min(updateVolume, scale * criticalRegionVolume);</span>
        } else {
<span class="fc" id="L507">            updateVolume -= rate;</span>
<span class="fc" id="L508">            updateVolume = Math.max(updateVolume, scale * criticalRegionVolume);</span>
        }

<span class="fc" id="L511">        targetRegionVolumes.put(region, updateVolume);</span>
<span class="fc" id="L512">        double updateSurface = location.convertSurface(updateVolume, criticalRegionHeight);</span>
<span class="fc" id="L513">        targetRegionSurfaces.put(region, updateSurface);</span>

<span class="fc" id="L515">        double postUpdateVolume = targetRegionVolumes.get(Region.DEFAULT) - updateVolume;</span>
<span class="fc" id="L516">        targetRegionVolumes.put(Region.DEFAULT, postUpdateVolume);</span>

<span class="fc" id="L518">        double defaultRegionHeight = criticalRegionHeights.get(Region.DEFAULT);</span>
<span class="fc" id="L519">        double postUpdateSurface = location.convertSurface(postUpdateVolume, defaultRegionHeight);</span>
<span class="fc" id="L520">        targetRegionSurfaces.put(Region.DEFAULT, postUpdateSurface);</span>
<span class="fc" id="L521">    }</span>

    @Override
    public CellContainer convert() {
<span class="fc bfc" id="L525" title="All 2 branches covered.">        if (hasRegions) {</span>
<span class="fc" id="L526">            EnumMap&lt;Region, Integer&gt; regionVolumes = new EnumMap&lt;&gt;(Region.class);</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">            for (Region region : location.getRegions()) {</span>
<span class="fc" id="L528">                regionVolumes.put(region, (int) location.getVolume(region));</span>
<span class="fc" id="L529">            }</span>

<span class="fc" id="L531">            return new PottsCellContainer(</span>
                    id,
                    parent,
                    pop,
                    age,
                    divisions,
                    state,
<span class="fc" id="L538">                    ((PottsModule) module).getPhase(),</span>
<span class="fc" id="L539">                    (int) getVolume(),</span>
                    regionVolumes,
                    criticalVolume,
                    criticalHeight,
                    criticalRegionVolumes,
                    criticalRegionHeights);
        } else {
<span class="fc" id="L546">            return new PottsCellContainer(</span>
                    id,
                    parent,
                    pop,
                    age,
                    divisions,
                    state,
<span class="fc" id="L553">                    ((PottsModule) module).getPhase(),</span>
<span class="fc" id="L554">                    (int) getVolume(),</span>
                    criticalVolume,
                    criticalHeight);
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>