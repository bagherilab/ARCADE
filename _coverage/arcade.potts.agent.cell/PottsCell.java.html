<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PottsCell.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">arcade</a> &gt; <a href="index.source.html" class="el_package">arcade.potts.agent.cell</a> &gt; <span class="el_source">PottsCell.java</span></div><h1>PottsCell.java</h1><pre class="source lang-java linenums">package arcade.potts.agent.cell;

import java.util.EnumMap;
import sim.engine.Schedule;
import sim.engine.SimState;
import sim.engine.Stoppable;
import ec.util.MersenneTwisterFast;
import arcade.core.agent.cell.Cell;
import arcade.core.agent.cell.CellContainer;
import arcade.core.agent.module.Module;
import arcade.core.agent.process.Process;
import arcade.core.env.location.Location;
import arcade.core.sim.Simulation;
import arcade.core.util.MiniBox;
import arcade.potts.agent.module.PottsModule;
import arcade.potts.agent.module.PottsModuleApoptosisSimple;
import arcade.potts.agent.module.PottsModuleAutosis;
import arcade.potts.agent.module.PottsModuleNecrosis;
import arcade.potts.agent.module.PottsModuleProliferationSimple;
import arcade.potts.agent.module.PottsModuleQuiescence;
import arcade.potts.env.location.PottsLocation;
import static arcade.core.util.Enums.Domain;
import static arcade.core.util.Enums.Region;
import static arcade.core.util.Enums.State;
import static arcade.potts.util.PottsEnums.Ordering;

/**
 * Implementation of {@link Cell} for potts models.
 * &lt;p&gt;
 * {@code PottsCell} agents exist in one of five states: quiescent,
 * proliferative, apoptotic, necrotic, or autotic. Each state may be further
 * divided into relevant phases.
 * &lt;p&gt;
 * General order of rules for the {@code PottsCell} step:
 * &lt;ul&gt;
 *     &lt;li&gt;update age&lt;/li&gt;
 *     &lt;li&gt;step state module&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Cell parameters are tracked using a map between the parameter name and value.
 * &lt;p&gt;
 * To integrate with the Potts layer, {@code PottsCell} agents also contain
 * critical and target volumes and surfaces.
 * Additional parameters specific to each term in the Hamiltonian are tracked
 * by the specific Hamiltonian class instance.
 */

public final class PottsCell implements Cell {
    /** Stopper used to stop this agent from being stepped in the schedule. */
    Stoppable stopper;
    
    /** Cell {@link Location} object. */
    private final PottsLocation location;
    
    /** Unique cell ID. */
    final int id;
    
    /** Cell parent ID. */
    final int parent;
    
    /** Cell population index. */
    final int pop;
    
    /** Cell state. */
    private State state;
    
    /** Cell age [ticks]. */
    private int age;
    
    /** Number of divisions. */
    private int divisions;
    
    /** {@code true} if the cell has regions, {@code false} otherwise. */
    private final boolean hasRegions;
    
    /** Target cell volume [voxels]. */
    private double targetVolume;
    
    /** Target region cell volumes [voxels]. */
    private final EnumMap&lt;Region, Double&gt; targetRegionVolumes;
    
    /** Target cell surface [voxels]. */
    private double targetSurface;
    
    /** Target region cell surfaces [voxels]. */
    private final EnumMap&lt;Region, Double&gt; targetRegionSurfaces;
    
    /** Critical volume for cell [voxels]. */
    private final double criticalVolume;
    
    /** Critical volumes for cell by region [voxels]. */
    private final EnumMap&lt;Region, Double&gt; criticalRegionVolumes;
    
    /** Critical height for cell [voxels]. */
    private final double criticalHeight;
    
    /** Critical heights for cell by region [voxels]. */
    private final EnumMap&lt;Region, Double&gt; criticalRegionHeights;
    
    /** Cell state module. */
    protected Module module;
    
    /** Cell parameters. */
    final MiniBox parameters;
    
    /**
     * Creates a {@code PottsCell} agent.
     *
     * @param id  the cell ID
     * @param parent  the parent ID
     * @param pop  the cell population index
     * @param state  the cell state
     * @param age  the cell age
     * @param divisions  the number of cell divisions
     * @param location  the {@link Location} of the cell
     * @param hasRegions  {@code true} if cell has regions, {@code false} otherwise
     * @param parameters  the dictionary of parameters
     * @param criticalVolume  the critical cell volume
     * @param criticalHeight  the critical cell height
     * @param criticalRegionVolumes  the map of critical volumes for regions
     * @param criticalRegionHeights  the map of critical heights for regions
     */
    public PottsCell(int id, int parent, int pop, State state, int age, int divisions,
                     Location location, boolean hasRegions, MiniBox parameters,
                     double criticalVolume, double criticalHeight,
                     EnumMap&lt;Region, Double&gt; criticalRegionVolumes,
<span class="fc" id="L127">                     EnumMap&lt;Region, Double&gt; criticalRegionHeights) {</span>
<span class="fc" id="L128">        this.id = id;</span>
<span class="fc" id="L129">        this.parent = parent;</span>
<span class="fc" id="L130">        this.pop = pop;</span>
<span class="fc" id="L131">        this.age = age;</span>
<span class="fc" id="L132">        this.divisions = divisions;</span>
<span class="fc" id="L133">        this.hasRegions = hasRegions;</span>
<span class="fc" id="L134">        this.location = (PottsLocation) location;</span>
<span class="fc" id="L135">        this.parameters = parameters;</span>
<span class="fc" id="L136">        this.criticalVolume = criticalVolume;</span>
<span class="fc" id="L137">        this.criticalHeight = criticalHeight;</span>
        
<span class="fc" id="L139">        setState(state);</span>
        
<span class="fc bfc" id="L141" title="All 2 branches covered.">        if (hasRegions) {</span>
<span class="fc" id="L142">            this.criticalRegionVolumes = criticalRegionVolumes.clone();</span>
<span class="fc" id="L143">            this.criticalRegionHeights = criticalRegionHeights.clone();</span>
<span class="fc" id="L144">            this.targetRegionVolumes = new EnumMap&lt;&gt;(Region.class);</span>
<span class="fc" id="L145">            this.targetRegionSurfaces = new EnumMap&lt;&gt;(Region.class);</span>
        } else {
<span class="fc" id="L147">            this.criticalRegionVolumes = null;</span>
<span class="fc" id="L148">            this.criticalRegionHeights = null;</span>
<span class="fc" id="L149">            this.targetRegionVolumes = null;</span>
<span class="fc" id="L150">            this.targetRegionSurfaces = null;</span>
        }
<span class="fc" id="L152">    }</span>
    
    @Override
<span class="fc" id="L155">    public int getID() { return id; }</span>
    
    @Override
<span class="fc" id="L158">    public int getParent() { return parent; }</span>
    
    @Override
<span class="fc" id="L161">    public int getPop() { return pop; }</span>
    
    @Override
<span class="fc" id="L164">    public State getState() { return state; }</span>
    
    @Override
<span class="fc" id="L167">    public int getAge() { return age; }</span>
    
    @Override
<span class="fc" id="L170">    public int getDivisions() { return divisions; }</span>
    
    @Override
<span class="fc" id="L173">    public boolean hasRegions() { return hasRegions; }</span>
    
    @Override
<span class="fc" id="L176">    public Location getLocation() { return location; }</span>
    
    @Override
<span class="fc" id="L179">    public Module getModule() { return module; }</span>
    
    @Override
<span class="fc" id="L182">    public Process getProcess(Domain domain) { return null; }</span>
    
    @Override
<span class="fc" id="L185">    public MiniBox getParameters() { return parameters; }</span>
    
    @Override
<span class="fc" id="L188">    public double getVolume() { return location.getVolume(); }</span>
    
    @Override
    public double getVolume(Region region) {
<span class="fc bfc" id="L192" title="All 2 branches covered.">        return (hasRegions ? location.getVolume(region) : 0);</span>
    }
    
    @Override
<span class="fc" id="L196">    public double getHeight() { return location.getHeight(); }</span>
    
    @Override
    public double getHeight(Region region) {
<span class="fc bfc" id="L200" title="All 2 branches covered.">        return (hasRegions ? location.getHeight(region) : 0);</span>
    }
    
    /**
     * Gets the cell surface.
     *
     * @return  the cell surface
     */
<span class="fc" id="L208">    public double getSurface() { return location.getSurface(); }</span>
    
    /**
     * Gets the cell surface for a region.
     *
     * @param region  the region
     * @return  the cell region surface
     */
    public double getSurface(Region region) {
<span class="fc bfc" id="L217" title="All 2 branches covered.">        return (hasRegions ? location.getSurface(region) : 0);</span>
    }
    
    /**
     * Gets the target volume.
     *
     * @return  the target volume
     */
<span class="fc" id="L225">    public double getTargetVolume() { return targetVolume; }</span>
    
    /**
     * Gets the target volume for a region.
     *
     * @param region  the region
     * @return  the target region volume
     */
    public double getTargetVolume(Region region) {
<span class="fc bfc" id="L234" title="All 4 branches covered.">        return (hasRegions &amp;&amp; targetRegionVolumes.containsKey(region)</span>
<span class="fc" id="L235">                ? targetRegionVolumes.get(region)</span>
                : 0);
    }
    
    /**
     * Gets the target surface.
     *
     * @return  the target surface
     */
<span class="fc" id="L244">    public double getTargetSurface() { return targetSurface; }</span>
    
    /**
     * Gets the target surface for a region.
     *
     * @param region  the region
     * @return  the target region surface
     */
    public double getTargetSurface(Region region) {
<span class="fc bfc" id="L253" title="All 4 branches covered.">        return (hasRegions &amp;&amp; targetRegionSurfaces.containsKey(region)</span>
<span class="fc" id="L254">                ? targetRegionSurfaces.get(region)</span>
                : 0);
    }
    
    @Override
<span class="fc" id="L259">    public double getCriticalVolume() { return criticalVolume; }</span>
    
    @Override
    public double getCriticalVolume(Region region) {
<span class="fc bfc" id="L263" title="All 4 branches covered.">        return (hasRegions &amp;&amp; criticalRegionVolumes.containsKey(region)</span>
<span class="fc" id="L264">                ? criticalRegionVolumes.get(region)</span>
                : 0);
    }
    
    @Override
<span class="fc" id="L269">    public double getCriticalHeight() { return criticalHeight; }</span>
    
    @Override
    public double getCriticalHeight(Region region) {
<span class="fc bfc" id="L273" title="All 4 branches covered.">        return (hasRegions &amp;&amp; criticalRegionHeights.containsKey(region)</span>
<span class="fc" id="L274">                ? criticalRegionHeights.get(region)</span>
                : 0);
    }
    
    @Override
<span class="fc" id="L279">    public void stop() { stopper.stop(); }</span>
    
    @Override
    public PottsCell make(int newID, State newState, Location newLocation,
                          MersenneTwisterFast random) {
<span class="fc" id="L284">        divisions++;</span>
<span class="fc" id="L285">        return new PottsCell(newID, id, pop, newState, age, divisions, newLocation,</span>
                hasRegions, parameters, criticalVolume, criticalHeight,
                criticalRegionVolumes, criticalRegionHeights);
    }
    
    @Override
    public void setState(State state) {
<span class="fc" id="L292">        this.state = state;</span>
        
<span class="fc bfc" id="L294" title="All 6 branches covered.">        switch (state) {</span>
            case QUIESCENT:
<span class="fc" id="L296">                module = new PottsModuleQuiescence(this);</span>
<span class="fc" id="L297">                break;</span>
            case PROLIFERATIVE:
<span class="fc" id="L299">                module = new PottsModuleProliferationSimple(this);</span>
<span class="fc" id="L300">                break;</span>
            case APOPTOTIC:
<span class="fc" id="L302">                module = new PottsModuleApoptosisSimple(this);</span>
<span class="fc" id="L303">                break;</span>
            case NECROTIC:
<span class="fc" id="L305">                module = new PottsModuleNecrosis(this);</span>
<span class="fc" id="L306">                break;</span>
            case AUTOTIC:
<span class="fc" id="L308">                module = new PottsModuleAutosis(this);</span>
<span class="fc" id="L309">                break;</span>
            default:
                // State must be one of the above cases.
<span class="fc" id="L312">                module = null;</span>
                break;
        }
<span class="fc" id="L315">    }</span>
    
    @Override
    public void schedule(Schedule schedule) {
<span class="fc" id="L319">        stopper = schedule.scheduleRepeating(this, Ordering.CELLS.ordinal(), 1);</span>
<span class="fc" id="L320">    }</span>
    
    /**
     * Initializes the potts arrays with the cell.
     *
     * @param ids  the {@link arcade.potts.sim.Potts} array for ids
     * @param regions  the {@link arcade.potts.sim.Potts} array for regions
     */
    public void initialize(int[][][] ids, int[][][] regions) {
<span class="fc" id="L329">        location.update(id, ids, regions);</span>
        
<span class="fc" id="L331">        targetVolume = location.getVolume();</span>
<span class="fc" id="L332">        targetSurface = location.getSurface();</span>
        
<span class="fc bfc" id="L334" title="All 2 branches covered.">        if (!hasRegions) {</span>
<span class="fc" id="L335">            return;</span>
        }
        
<span class="fc bfc" id="L338" title="All 2 branches covered.">        for (Region region : location.getRegions()) {</span>
<span class="fc" id="L339">            targetRegionVolumes.put(region, location.getVolume(region));</span>
<span class="fc" id="L340">            targetRegionSurfaces.put(region, location.getSurface(region));</span>
<span class="fc" id="L341">        }</span>
<span class="fc" id="L342">    }</span>
    
    /**
     * Resets the potts arrays with the cell.
     *
     * @param ids  the {@link arcade.potts.sim.Potts} array for ids
     * @param regions  the {@link arcade.potts.sim.Potts} array for regions
     */
    public void reset(int[][][] ids, int[][][] regions) {
<span class="fc" id="L351">        location.update(id, ids, regions);</span>
        
<span class="fc" id="L353">        targetVolume = criticalVolume;</span>
<span class="fc" id="L354">        targetSurface = location.convertSurface(targetVolume, criticalHeight);</span>
        
<span class="fc bfc" id="L356" title="All 2 branches covered.">        if (!hasRegions) {</span>
<span class="fc" id="L357">            return;</span>
        }
        
<span class="fc bfc" id="L360" title="All 2 branches covered.">        for (Region region : location.getRegions()) {</span>
<span class="fc" id="L361">            double regionHeight = criticalRegionHeights.get(region);</span>
<span class="fc" id="L362">            double regionVolume = criticalRegionVolumes.get(region);</span>
<span class="fc" id="L363">            targetRegionVolumes.put(region, regionVolume);</span>
<span class="fc" id="L364">            targetRegionSurfaces.put(region, location.convertSurface(regionVolume, regionHeight));</span>
<span class="fc" id="L365">        }</span>
<span class="fc" id="L366">    }</span>
    
    @Override
    public void step(SimState simstate) {
<span class="fc" id="L370">        Simulation sim = (Simulation) simstate;</span>
        
        // Increase age of cell.
<span class="fc" id="L373">        age++;</span>
        
        // Step the module for the cell state.
<span class="fc" id="L376">        module.step(simstate.random, sim);</span>
<span class="fc" id="L377">    }</span>
    
    /**
     * Sets the target volume and surface for the cell.
     *
     * @param volume  the target volume
     * @param surface  the target surface
     */
    public void setTargets(double volume, double surface) {
<span class="fc" id="L386">        targetVolume = volume;</span>
<span class="fc" id="L387">        targetSurface = surface;</span>
<span class="fc" id="L388">    }</span>
    
    /**
     * Sets the target volume and surface for a region.
     *
     * @param region  the region
     * @param volume  the target volume
     * @param surface  the target surface
     */
    public void setTargets(Region region, double volume, double surface) {
<span class="fc" id="L398">        targetRegionVolumes.put(region, volume);</span>
<span class="fc" id="L399">        targetRegionSurfaces.put(region, surface);</span>
<span class="fc" id="L400">    }</span>
    
    /**
     * Updates target volume and surface area. When scale is greater than one,
     * volume increases by given rate. When scale is less than one, volume
     * decreases by given rate. If scale is one, sizes are not changed.
     *
     * @param rate  the rate of change
     * @param scale  the relative final size scaling
     */
    public void updateTarget(double rate, double scale) {
<span class="fc bfc" id="L411" title="All 2 branches covered.">        if (scale == 1) {</span>
<span class="fc" id="L412">            return;</span>
        }
        
<span class="fc bfc" id="L415" title="All 2 branches covered.">        if (hasRegions) {</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">            if (scale &lt; 1) {</span>
<span class="fc" id="L417">                rate = Math.min(rate, targetRegionVolumes.get(Region.DEFAULT));</span>
            }
<span class="fc" id="L419">            double updateVolume = targetRegionVolumes.get(Region.DEFAULT) - targetVolume;</span>
<span class="fc" id="L420">            targetRegionVolumes.put(Region.DEFAULT, updateVolume);</span>
        }
        
<span class="fc bfc" id="L423" title="All 2 branches covered.">        if (scale &gt; 1) {</span>
<span class="fc" id="L424">            targetVolume += rate;</span>
<span class="fc" id="L425">            targetVolume = Math.min(targetVolume, scale * criticalVolume);</span>
        } else {
<span class="fc" id="L427">            targetVolume -= rate;</span>
<span class="fc" id="L428">            targetVolume = Math.max(targetVolume, scale * criticalVolume);</span>
        }
        
<span class="fc" id="L431">        targetSurface = location.convertSurface(targetVolume, criticalHeight);</span>
        
<span class="fc bfc" id="L433" title="All 2 branches covered.">        if (hasRegions) {</span>
<span class="fc" id="L434">            double updateVolume = targetRegionVolumes.get(Region.DEFAULT) + targetVolume;</span>
<span class="fc" id="L435">            targetRegionVolumes.put(Region.DEFAULT, updateVolume);</span>
            
<span class="fc" id="L437">            double criticalRegionHeight = criticalRegionHeights.get(Region.DEFAULT);</span>
<span class="fc" id="L438">            double updateSurface = location.convertSurface(updateVolume, criticalRegionHeight);</span>
<span class="fc" id="L439">            targetRegionSurfaces.put(Region.DEFAULT, updateSurface);</span>
        }
<span class="fc" id="L441">    }</span>
    
    /**
     * Updates target volume and surface area for a region.
     * &lt;p&gt;
     * If the region is the DEFAULT region, then updates are the same as for a
     * cell without regions.
     *
     * @param region  the region
     * @param rate  the rate of change
     * @param scale  the relative final size scaling
     */
    public void updateTarget(Region region, double rate, double scale) {
<span class="fc bfc" id="L454" title="All 4 branches covered.">        if (!hasRegions || scale == 1) {</span>
<span class="fc" id="L455">            return;</span>
        }
        
<span class="fc bfc" id="L458" title="All 2 branches covered.">        if (region == Region.DEFAULT) {</span>
<span class="fc" id="L459">            updateTarget(rate, scale);</span>
<span class="fc" id="L460">            return;</span>
        }
        
<span class="fc bfc" id="L463" title="All 2 branches covered.">        if (scale &gt; 1) {</span>
<span class="fc" id="L464">            rate = Math.min(rate, targetRegionVolumes.get(Region.DEFAULT));</span>
        }
        
<span class="fc" id="L467">        double criticalRegionVolume = criticalRegionVolumes.get(region);</span>
<span class="fc" id="L468">        double criticalRegionHeight = criticalRegionHeights.get(region);</span>
        
<span class="fc" id="L470">        double updateVolume = targetRegionVolumes.get(region);</span>
        
<span class="fc" id="L472">        double preUpdateVolume = targetRegionVolumes.get(Region.DEFAULT) + updateVolume;</span>
<span class="fc" id="L473">        targetRegionVolumes.put(Region.DEFAULT, preUpdateVolume);</span>
        
<span class="fc bfc" id="L475" title="All 2 branches covered.">        if (scale &gt; 1) {</span>
<span class="fc" id="L476">            updateVolume += rate;</span>
<span class="fc" id="L477">            updateVolume = Math.min(updateVolume, scale * criticalRegionVolume);</span>
        } else {
<span class="fc" id="L479">            updateVolume -= rate;</span>
<span class="fc" id="L480">            updateVolume = Math.max(updateVolume, scale * criticalRegionVolume);</span>
        }
        
<span class="fc" id="L483">        targetRegionVolumes.put(region, updateVolume);</span>
<span class="fc" id="L484">        double updateSurface = location.convertSurface(updateVolume, criticalRegionHeight);</span>
<span class="fc" id="L485">        targetRegionSurfaces.put(region, updateSurface);</span>
        
<span class="fc" id="L487">        double postUpdateVolume = targetRegionVolumes.get(Region.DEFAULT) - updateVolume;</span>
<span class="fc" id="L488">        targetRegionVolumes.put(Region.DEFAULT, postUpdateVolume);</span>
        
<span class="fc" id="L490">        double defaultRegionHeight = criticalRegionHeights.get(Region.DEFAULT);</span>
<span class="fc" id="L491">        double postUpdateSurface = location.convertSurface(postUpdateVolume, defaultRegionHeight);</span>
<span class="fc" id="L492">        targetRegionSurfaces.put(Region.DEFAULT, postUpdateSurface);</span>
<span class="fc" id="L493">    }</span>
    
    @Override
    public CellContainer convert() {
<span class="fc bfc" id="L497" title="All 2 branches covered.">        if (hasRegions) {</span>
<span class="fc" id="L498">            EnumMap&lt;Region, Integer&gt; regionVolumes = new EnumMap&lt;&gt;(Region.class);</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">            for (Region region : location.getRegions()) {</span>
<span class="fc" id="L500">                regionVolumes.put(region, (int) location.getVolume(region));</span>
<span class="fc" id="L501">            }</span>
            
<span class="fc" id="L503">            return new PottsCellContainer(id, parent, pop, age, divisions, state,</span>
<span class="fc" id="L504">                    ((PottsModule) module).getPhase(), (int) getVolume(), regionVolumes,</span>
                    criticalVolume, criticalHeight, criticalRegionVolumes, criticalRegionHeights);
        } else {
<span class="fc" id="L507">            return new PottsCellContainer(id, parent, pop, age, divisions, state,</span>
<span class="fc" id="L508">                    ((PottsModule) module).getPhase(), (int) getVolume(),</span>
                    criticalVolume, criticalHeight);
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>