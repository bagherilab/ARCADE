<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Matrix.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">arcade</a> &gt; <a href="index.source.html" class="el_package">arcade.core.util</a> &gt; <span class="el_source">Matrix.java</span></div><h1>Matrix.java</h1><pre class="source lang-java linenums">package arcade.core.util;

import java.util.ArrayList;

/**
 * Container class for dense and sparse matrix representations.
 *
 * &lt;p&gt;Class provides a subset of matrix operations needed for solving a system of linear equations
 * using the successive over-relaxation method in {@link arcade.core.util.Solver}.
 */
public class Matrix {
    /** Container class for sparse matrix representation. */
    public static class Value {
        /** Row index of value. */
        int i;

        /** Column index of value. */
        int j;

        /** Value in matrix. */
        double v;

        /**
         * Creates a value in a sparse matrix.
         *
         * @param i the row index of the value
         * @param j the column index of the value
         * @param v the value
         */
<span class="fc" id="L30">        Value(int i, int j, double v) {</span>
<span class="fc" id="L31">            this.i = i;</span>
<span class="fc" id="L32">            this.j = j;</span>
<span class="fc" id="L33">            this.v = v;</span>
<span class="fc" id="L34">        }</span>

        /**
         * Gets hash based on (i, j) indices.
         *
         * @return the hash
         */
        public final int hashCode() {
<span class="nc" id="L42">            return i + (j &lt;&lt; 8);</span>
        }

        /**
         * Checks if two values have the same (i, j) indices.
         *
         * @param obj the value to compare
         * @return {@code true} if values have the same indices, {@code false} otherwise
         */
        public final boolean equals(Object obj) {
<span class="pc bpc" id="L52" title="1 of 2 branches missed.">            if (!(obj instanceof Value)) {</span>
<span class="nc" id="L53">                return false;</span>
            }
<span class="fc" id="L55">            Value value = (Value) obj;</span>
<span class="pc bpc" id="L56" title="3 of 6 branches missed.">            return value.i == i &amp;&amp; value.j == j &amp;&amp; value.v == v;</span>
        }

        /**
         * Formats value as a string.
         *
         * @return a string representation of the value
         */
        public String toString() {
<span class="nc" id="L65">            return &quot;(&quot; + i + &quot;,&quot; + j + &quot;) = &quot; + v;</span>
        }
    }

    /** Hidden utility class constructor. */
<span class="fc" id="L70">    protected Matrix() {</span>
<span class="fc" id="L71">        throw new UnsupportedOperationException();</span>
    }

    /**
     * Converts a dense matrix representation to a sparse matrix representation.
     *
     * @param mat the dense matrix representation
     * @return the sparse matrix representation
     */
    public static ArrayList&lt;Value&gt; toSparse(double[][] mat) {
<span class="fc" id="L81">        ArrayList&lt;Value&gt; a = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L82">        int n = mat.length;</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">            for (int j = 0; j &lt; n; j++) {</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">                if (mat[i][j] != 0) {</span>
<span class="fc" id="L86">                    a.add(new Value(i, j, mat[i][j]));</span>
                }
            }
        }
<span class="fc" id="L90">        return a;</span>
    }

    /**
     * Converts a sparse matrix representation to a dense matrix representation.
     *
     * @param mat the sparse matrix representation
     * @return the dense matrix representation
     */
    public static double[][] toDense(ArrayList&lt;Value&gt; mat) {
<span class="fc" id="L100">        int n = 0;</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">        for (Value v : mat) {</span>
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">            if (v.i &gt; n) {</span>
<span class="nc" id="L103">                n = v.i;</span>
            }
<span class="fc bfc" id="L105" title="All 2 branches covered.">            if (v.j &gt; n) {</span>
<span class="fc" id="L106">                n = v.j;</span>
            }
<span class="fc" id="L108">        }</span>
<span class="fc" id="L109">        double[][] a = new double[n + 1][n + 1];</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">        for (Value v : mat) {</span>
<span class="fc" id="L111">            a[v.i][v.j] = v.v;</span>
<span class="fc" id="L112">        }</span>
<span class="fc" id="L113">        return a;</span>
    }

    /**
     * Inverts a upper triangular matrix.
     *
     * @param mat the upper triangular matrix to invert
     * @return the inverted matrix
     */
    public static double[][] invertUpper(double[][] mat) {
<span class="fc" id="L123">        int n = mat.length;</span>
<span class="fc" id="L124">        double[][] inv = new double[n][n];</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">        for (int k = 0; k &lt; n; k++) {</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">            for (int i = 0; i &lt; k; i++) {</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">                for (int j = 0; j &lt; k; j++) {</span>
<span class="fc" id="L128">                    inv[i][k] = inv[i][k] + inv[i][j] * mat[j][k];</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">                    if (inv[i][k] == -0.0) {</span>
<span class="fc" id="L130">                        inv[i][k] = 0;</span>
                    }
                }
            }
<span class="fc bfc" id="L134" title="All 2 branches covered.">            for (int j = 0; j &lt; k; j++) {</span>
<span class="fc" id="L135">                inv[j][k] = -inv[j][k] / mat[k][k];</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">                if (inv[j][k] == -0.0) {</span>
<span class="fc" id="L137">                    inv[j][k] = 0;</span>
                }
            }

<span class="fc" id="L141">            inv[k][k] = 1.0 / mat[k][k];</span>
        }
<span class="fc" id="L143">        return inv;</span>
    }

    /**
     * Inverts a lower triangular matrix.
     *
     * @param mat the lower triangular matrix to invert
     * @return the inverted matrix
     */
    public static double[][] invertLower(double[][] mat) {
<span class="fc" id="L153">        int n = mat.length;</span>
<span class="fc" id="L154">        double[][] inv = new double[n][n];</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">        for (int k = 0; k &lt; n; k++) {</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">            for (int i = 0; i &lt; k; i++) {</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">                for (int j = 0; j &lt; k; j++) {</span>
<span class="fc" id="L158">                    inv[k][i] = inv[k][i] + inv[j][i] * mat[k][j];</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">                    if (inv[k][i] == -0.0) {</span>
<span class="fc" id="L160">                        inv[k][i] = 0;</span>
                    }
                }
            }
<span class="fc bfc" id="L164" title="All 2 branches covered.">            for (int j = 0; j &lt; k; j++) {</span>
<span class="fc" id="L165">                inv[k][j] = -inv[k][j] / mat[k][k];</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">                if (inv[k][j] == -0.0) {</span>
<span class="fc" id="L167">                    inv[k][j] = 0;</span>
                }
            }

<span class="fc" id="L171">            inv[k][k] = 1.0 / mat[k][k];</span>
        }
<span class="fc" id="L173">        return inv;</span>
    }

    /**
     * Solves the equation {@code Lx = b} using forward substitution for a dense matrix.
     *
     * &lt;p&gt;Matrix L must be a square lower triangular matrix.
     *
     * @param mat the matrix of coefficients
     * @param vec the right-hand side vector
     * @return the left-hand side vector
     */
    public static double[] forwardSubstitution(double[][] mat, double[] vec) {
<span class="fc" id="L186">        int n = vec.length;</span>
<span class="fc" id="L187">        double[] subbed = new double[n];</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L189">            double val = 0;</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">            for (int j = 0; j &lt; i; j++) {</span>
<span class="fc" id="L191">                val += subbed[j] * mat[i][j];</span>
            }
<span class="fc" id="L193">            val = vec[i] - val;</span>
<span class="fc" id="L194">            subbed[i] = val / mat[i][i];</span>
        }
<span class="fc" id="L196">        return subbed;</span>
    }

    /**
     * Solves the equation {@code Lx = U} using forward substitution for a dense matrix.
     *
     * &lt;p&gt;The matrices {@code L} and {@code U} are the square lower and upper triangular matrices of
     * the given matrix.
     *
     * @param mat the matrix of coefficients
     * @return the left-hand side matrix
     */
    public static double[][] forwardSubstitution(double[][] mat) {
<span class="fc" id="L209">        double[][] lower = getLower(mat, false);</span>
<span class="fc" id="L210">        double[][] upper = getUpper(mat, true);</span>
<span class="fc" id="L211">        int n = lower.length;</span>
<span class="fc" id="L212">        double[][] subbed = new double[n][n];</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">            for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L215">                double val = 0;</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">                for (int k = 0; k &lt; i; k++) {</span>
<span class="fc" id="L217">                    val += subbed[k][j] * lower[i][k];</span>
                }
<span class="fc" id="L219">                val = upper[i][j] - val;</span>
<span class="fc" id="L220">                subbed[i][j] = val / lower[i][i];</span>
            }
        }
<span class="fc" id="L223">        return subbed;</span>
    }

    /**
     * Solves the equation {@code Lx = b} using forward substitution for a sparse matrix.
     *
     * @param mat the matrix of coefficients
     * @param vec the right-hand side vector
     * @return the left-hand side vector
     */
    public static double[] forwardSubstitution(ArrayList&lt;Value&gt; mat, double[] vec) {
<span class="pc bpc" id="L234" title="1 of 4 branches missed.">        mat.sort((v1, v2) -&gt; (v1.i == v2.i ? Integer.compare(v1.j, v2.j) : (v1.i &gt; v2.i ? 1 : -1)));</span>

<span class="fc" id="L236">        int n = vec.length;</span>
<span class="fc" id="L237">        double[] subbed = new double[n];</span>
<span class="fc" id="L238">        double[] diag = new double[n];</span>

        // Group lower diagonal by row.
<span class="fc" id="L241">        ArrayList&lt;ArrayList&lt;Value&gt;&gt; rowsL = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">        for (int r = 0; r &lt; n; r++) {</span>
<span class="fc" id="L243">            rowsL.add(new ArrayList&lt;&gt;());</span>
        }
<span class="fc bfc" id="L245" title="All 2 branches covered.">        for (Value v : mat) {</span>
<span class="fc" id="L246">            rowsL.get(v.i).add(v);</span>
<span class="fc" id="L247">        }</span>

        // Get values along diagonal.
<span class="fc bfc" id="L250" title="All 2 branches covered.">        for (Value v : mat) {</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">            if (v.i == v.j) {</span>
<span class="fc" id="L252">                diag[v.i] = v.v;</span>
            }
<span class="fc" id="L254">        }</span>

        // Iterate only through non-zero entries in the lower diagonal matrix.
<span class="fc bfc" id="L257" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L258">            ArrayList&lt;Value&gt; rowL = rowsL.get(i);</span>
<span class="fc" id="L259">            double val = 0;</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">            for (Value v : rowL) {</span>
<span class="fc" id="L261">                val += subbed[v.j] * v.v;</span>
<span class="fc" id="L262">            }</span>
<span class="fc" id="L263">            val = vec[i] - val;</span>
<span class="fc" id="L264">            subbed[i] = val / diag[i];</span>
        }

<span class="fc" id="L267">        return subbed;</span>
    }

    /**
     * Solves the equation {@code Lx = U} using forward substitution for a sparse matrix.
     *
     * &lt;p&gt;The matrices {@code L} and {@code U} are the square lower and upper triangular matrices of
     * the given matrix.
     *
     * @param mat the matrix of coefficients
     * @return the left-hand side matrix
     */
    public static ArrayList&lt;Value&gt; forwardSubstitution(ArrayList&lt;Value&gt; mat) {
<span class="pc bpc" id="L280" title="1 of 4 branches missed.">        mat.sort((v1, v2) -&gt; (v1.i == v2.i ? Integer.compare(v1.j, v2.j) : (v1.i &gt; v2.i ? 1 : -1)));</span>

<span class="fc" id="L282">        double[][] upper = getUpper(toDense(mat), true);</span>
<span class="fc" id="L283">        ArrayList&lt;Value&gt; lower = getLower(mat, true);</span>
<span class="fc" id="L284">        int n = upper.length;</span>
<span class="fc" id="L285">        double[][] subbed = new double[n][n];</span>
<span class="fc" id="L286">        double[] diag = new double[n];</span>

        // Group lower diagonal by row.
<span class="fc" id="L289">        ArrayList&lt;ArrayList&lt;Value&gt;&gt; rows = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">        for (int r = 0; r &lt; n; r++) {</span>
<span class="fc" id="L291">            rows.add(new ArrayList&lt;&gt;());</span>
        }
<span class="fc bfc" id="L293" title="All 2 branches covered.">        for (Value v : lower) {</span>
<span class="fc" id="L294">            rows.get(v.i).add(v);</span>
<span class="fc" id="L295">        }</span>

        // Get values along diagonal.
<span class="fc bfc" id="L298" title="All 2 branches covered.">        for (Value v : mat) {</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">            if (v.i == v.j) {</span>
<span class="fc" id="L300">                diag[v.i] = v.v;</span>
            }
<span class="fc" id="L302">        }</span>

        // Iterate only through non-zero entries in the lower diagonal matrix.
<span class="fc bfc" id="L305" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L306">            ArrayList&lt;Value&gt; row = rows.get(i);</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">            for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L308">                double val = 0;</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">                for (Value v : row) {</span>
<span class="fc" id="L310">                    val += subbed[v.j][j] * v.v;</span>
<span class="fc" id="L311">                }</span>
<span class="fc" id="L312">                val = upper[i][j] - val;</span>
<span class="fc" id="L313">                subbed[i][j] = val / diag[i];</span>
            }
        }

<span class="fc" id="L317">        return toSparse(subbed);</span>
    }

    /**
     * Gets the upper triangular of a dense matrix.
     *
     * @param mat the matrix
     * @param strict {@code true} if triangular is strict, {@code false} otherwise
     * @return the upper triangular matrix
     */
    public static double[][] getUpper(double[][] mat, boolean strict) {
<span class="fc" id="L328">        int n = mat.length;</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">        int off = (strict ? 1 : 0);</span>
<span class="fc" id="L330">        double[][] upper = new double[n][n];</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">            for (int j = i + off; j &lt; n; j++) {</span>
<span class="fc" id="L333">                upper[i][j] = mat[i][j];</span>
            }
        }
<span class="fc" id="L336">        return upper;</span>
    }

    /**
     * Gets the lower triangular of a dense matrix.
     *
     * @param mat the matrix
     * @param strict {@code true} if triangular is strict, {@code false} otherwise
     * @return the lower triangular matrix
     */
    public static double[][] getLower(double[][] mat, boolean strict) {
<span class="fc" id="L347">        int n = mat.length;</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">        int off = (strict ? 0 : 1);</span>
<span class="fc" id="L349">        double[][] lower = new double[n][n];</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">            for (int j = 0; j &lt; i + off; j++) {</span>
<span class="fc" id="L352">                lower[i][j] = mat[i][j];</span>
            }
        }
<span class="fc" id="L355">        return lower;</span>
    }

    /**
     * Gets the upper triangular of a sparse matrix.
     *
     * @param mat the matrix
     * @param strict {@code true} if triangular is strict, {@code false} otherwise
     * @return the upper triangular matrix
     */
    public static ArrayList&lt;Value&gt; getUpper(ArrayList&lt;Value&gt; mat, boolean strict) {
<span class="fc" id="L366">        ArrayList&lt;Value&gt; upper = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">        int off = (strict ? 0 : 1);</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">        for (Value v : mat) {</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">            if (v.j &gt; v.i - off) {</span>
<span class="fc" id="L370">                upper.add(v);</span>
            }
<span class="fc" id="L372">        }</span>
<span class="fc" id="L373">        return upper;</span>
    }

    /**
     * Gets the lower triangular of a sparse matrix.
     *
     * @param mat the matrix
     * @param strict {@code true} if triangular is strict, {@code false} otherwise
     * @return the lower triangular matrix
     */
    public static ArrayList&lt;Value&gt; getLower(ArrayList&lt;Value&gt; mat, boolean strict) {
<span class="fc" id="L384">        ArrayList&lt;Value&gt; lower = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">        int off = (strict ? 0 : 1);</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">        for (Value v : mat) {</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">            if (v.j &lt; v.i + off) {</span>
<span class="fc" id="L388">                lower.add(v);</span>
            }
<span class="fc" id="L390">        }</span>
<span class="fc" id="L391">        return lower;</span>
    }

    /**
     * Multiplies two dense square matrices.
     *
     * @param matA the first matrix
     * @param matB the second matrix
     * @return the product of the two matrices
     */
    public static double[][] multiply(double[][] matA, double[][] matB) {
<span class="fc" id="L402">        int n = matA.length;</span>
<span class="fc" id="L403">        double[][] multiplied = new double[n][n];</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">            for (int j = 0; j &lt; n; j++) {</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">                for (int k = 0; k &lt; n; k++) {</span>
<span class="fc" id="L407">                    multiplied[i][j] += matA[i][k] * matB[k][j];</span>
                }
            }
        }
<span class="fc" id="L411">        return multiplied;</span>
    }

    /**
     * Multiplies a dense square matrix and a vector.
     *
     * @param mat the matrix
     * @param vec the vector
     * @return the product of the matrix and vector
     */
    public static double[] multiply(double[][] mat, double[] vec) {
<span class="fc" id="L422">        int n = mat.length;</span>
<span class="fc" id="L423">        double[] multiplied = new double[n];</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">            for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L426">                multiplied[i] += mat[i][j] * vec[j];</span>
            }
        }
<span class="fc" id="L429">        return multiplied;</span>
    }

    /**
     * Multiplies a sparse square matrix and a vector.
     *
     * @param mat the matrix
     * @param vec the vector
     * @return the product of the matrix and vector
     */
    public static double[] multiply(ArrayList&lt;Value&gt; mat, double[] vec) {
<span class="nc" id="L440">        int n = vec.length;</span>
<span class="nc" id="L441">        double[] multiplied = new double[n];</span>

        // Iterate through all entries and multiply.
<span class="nc bnc" id="L444" title="All 2 branches missed.">        for (Value a : mat) {</span>
<span class="nc" id="L445">            multiplied[a.i] += a.v * vec[a.j];</span>
<span class="nc" id="L446">        }</span>

<span class="nc" id="L448">        return multiplied;</span>
    }

    /**
     * Multiplies two sparse square matrices.
     *
     * @param matA the first matrix
     * @param matB the second matrix
     * @return the product of the two matrices
     */
    public static ArrayList&lt;Value&gt; multiply(ArrayList&lt;Value&gt; matA, ArrayList&lt;Value&gt; matB) {
<span class="fc" id="L459">        ArrayList&lt;Value&gt; multiplied = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L460">        ArrayList&lt;Value&gt; products = new ArrayList&lt;&gt;();</span>

        // Iterate through both matrices and calculate products.
<span class="fc bfc" id="L463" title="All 2 branches covered.">        for (Value a : matA) {</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">            for (Value b : matB) {</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">                if (a.j == b.i) {</span>
<span class="fc" id="L466">                    products.add(new Value(a.i, b.j, a.v * b.v));</span>
                }
<span class="fc" id="L468">            }</span>
<span class="fc" id="L469">        }</span>

        // Sort products.
<span class="fc" id="L472">        products.sort(</span>
<span class="fc bfc" id="L473" title="All 4 branches covered.">                (v1, v2) -&gt; (v1.i == v2.i ? Integer.compare(v1.j, v2.j) : (v1.i &gt; v2.i ? 1 : -1)));</span>

<span class="fc" id="L475">        int i = 0;</span>
<span class="fc" id="L476">        int j = 0;</span>
<span class="fc" id="L477">        double sum = 0;</span>

        // Iterate through products and make summations. Products must be sorted.
<span class="fc bfc" id="L480" title="All 2 branches covered.">        for (Value p : products) {</span>
<span class="fc bfc" id="L481" title="All 4 branches covered.">            if (p.i != i || p.j != j) {</span>
<span class="fc" id="L482">                multiplied.add(new Value(i, j, sum));</span>
<span class="fc" id="L483">                sum = 0;</span>
<span class="fc" id="L484">                i = p.i;</span>
<span class="fc" id="L485">                j = p.j;</span>
            }
<span class="fc" id="L487">            sum += p.v;</span>
<span class="fc" id="L488">        }</span>

        // Add in last case.
<span class="fc" id="L491">        Value p = products.get(products.size() - 1);</span>
<span class="pc bpc" id="L492" title="2 of 4 branches missed.">        if (p.i == i &amp;&amp; p.j == j) {</span>
<span class="fc" id="L493">            multiplied.add(new Value(i, j, sum));</span>
        }

<span class="fc" id="L496">        return multiplied;</span>
    }

    /**
     * Adds two vectors.
     *
     * @param vecA the first vector
     * @param vecB the second vector
     * @return the sum of the two vectors
     */
    public static double[] add(double[] vecA, double[] vecB) {
<span class="nc" id="L507">        int n = vecA.length;</span>
<span class="nc" id="L508">        double[] added = new double[n];</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L510">            added[i] = vecA[i] + vecB[i];</span>
        }
<span class="nc" id="L512">        return added;</span>
    }

    /**
     * Subtracts two vectors.
     *
     * @param vecA the first vector
     * @param vecB the second vector
     * @return the difference of the two vectors
     */
    public static double[] subtract(double[] vecA, double[] vecB) {
<span class="nc" id="L523">        int n = vecA.length;</span>
<span class="nc" id="L524">        double[] subtracted = new double[n];</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L526">            subtracted[i] = vecA[i] - vecB[i];</span>
        }
<span class="nc" id="L528">        return subtracted;</span>
    }

    /**
     * Scales the values in a dense matrix.
     *
     * @param mat the matrix
     * @param scale the value to scale by
     * @return the scaled matrix
     */
    public static double[][] scale(double[][] mat, double scale) {
<span class="nc" id="L539">        int n = mat.length;</span>
<span class="nc" id="L540">        double[][] scaled = new double[n][n];</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L542">            scaled[i] = scale(mat[i], scale);</span>
        }
<span class="nc" id="L544">        return scaled;</span>
    }

    /**
     * Scales the values in a dense vector.
     *
     * @param vec the vector
     * @param scale the value to scale by
     * @return the scaled vector
     */
    public static double[] scale(double[] vec, double scale) {
<span class="nc" id="L555">        int n = vec.length;</span>
<span class="nc" id="L556">        double[] scaled = new double[n];</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L558">            scaled[i] = vec[i] * scale;</span>
        }
<span class="nc" id="L560">        return scaled;</span>
    }

    /**
     * Scales the values in a sparse matrix.
     *
     * @param mat the matrix
     * @param scale the value to scale by
     * @return the scaled matrix
     */
    public static ArrayList&lt;Value&gt; scale(ArrayList&lt;Value&gt; mat, double scale) {
<span class="nc" id="L571">        ArrayList&lt;Value&gt; scaled = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">        for (Value a : mat) {</span>
<span class="nc" id="L573">            scaled.add(new Value(a.i, a.j, a.v * scale));</span>
<span class="nc" id="L574">        }</span>
<span class="nc" id="L575">        return scaled;</span>
    }

    /**
     * Normalizes the vector.
     *
     * @param vec the vector
     * @return the normalized vector
     */
    public static double normalize(double[] vec) {
<span class="fc" id="L585">        double sum = 0;</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">        for (double v : vec) {</span>
<span class="fc" id="L587">            sum += v * v;</span>
        }
<span class="fc" id="L589">        return Math.sqrt(sum);</span>
    }

    /**
     * Calculates dot product of two vectors.
     *
     * @param vecA the first matrix
     * @param vecB the second matrix
     * @return the dot product of the two vectors
     */
    public static double dot(double[] vecA, double[] vecB) {
<span class="fc" id="L600">        double sum = 0;</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">        for (int i = 0; i &lt; vecA.length; i++) {</span>
<span class="fc" id="L602">            sum += vecA[i] * vecB[i];</span>
        }
<span class="fc" id="L604">        return sum;</span>
    }

    /**
     * Converts the vector to a unit vector.
     *
     * @param vec the vector to convert
     */
    public static void unit(double[] vec) {
<span class="fc" id="L613">        double norm = normalize(vec);</span>
<span class="fc bfc" id="L614" title="All 2 branches covered.">        for (int i = 0; i &lt; vec.length; i++) {</span>
<span class="fc" id="L615">            vec[i] /= norm;</span>
        }
<span class="fc" id="L617">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>