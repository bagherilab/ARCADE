<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Matrix.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">arcade</a> &gt; <a href="index.source.html" class="el_package">arcade.core.util</a> &gt; <span class="el_source">Matrix.java</span></div><h1>Matrix.java</h1><pre class="source lang-java linenums">package arcade.core.util;

import java.util.ArrayList;

/**
 * Container class for dense and sparse matrix representations.
 * &lt;p&gt;
 * Class provides a subset of matrix operations needed for solving a system
 * of linear equations using the successive over-relaxation method in
 * {@link arcade.core.util.Solver}.
 */

public class Matrix {
    /** Container class for sparse matrix representation. */
    public static class Value {
        /** Row index of value. */
        int i;
        
        /** Column index of value. */
        int j;
        
        /** Value in matrix. */
        double v;
        
        /**
         * Creates a value in a sparse matrix.
         *
         * @param i  the row index of the value
         * @param j  the column index of the value
         * @param v  the value
         */
<span class="fc" id="L32">        Value(int i, int j, double v) {</span>
<span class="fc" id="L33">            this.i = i;</span>
<span class="fc" id="L34">            this.j = j;</span>
<span class="fc" id="L35">            this.v = v;</span>
<span class="fc" id="L36">        }</span>
        
        /**
         * Gets hash based on (i, j) indices.
         *
         * @return  the hash
         */
<span class="nc" id="L43">        public final int hashCode() { return i + (j &lt;&lt; 8); }</span>
        
        /**
         * Checks if two values have the same (i, j) indices.
         *
         * @param obj  the value to compare
         * @return  {@code true} if values have the same indices, {@code false} otherwise
         */
        public final boolean equals(Object obj) {
<span class="pc bpc" id="L52" title="1 of 2 branches missed.">            if (!(obj instanceof Value)) { return false; }</span>
<span class="fc" id="L53">            Value value = (Value) obj;</span>
<span class="pc bpc" id="L54" title="3 of 6 branches missed.">            return value.i == i &amp;&amp; value.j == j &amp;&amp; value.v == v;</span>
        }
        
        /**
         * Formats value as a string.
         *
         * @return  a string representation of the value
         */
        public String toString() {
<span class="nc" id="L63">            return &quot;(&quot; + i + &quot;,&quot; + j + &quot;) = &quot; + v;</span>
        }
    }
    
    /**
     * Hidden utility class constructor.
     */
<span class="fc" id="L70">    protected Matrix() {</span>
<span class="fc" id="L71">        throw new UnsupportedOperationException();</span>
    }
    
    /**
     * Converts a dense matrix representation to a sparse matrix representation.
     *
     * @param mat  the dense matrix representation
     * @return  the sparse matrix representation
     */
    public static ArrayList&lt;Value&gt; toSparse(double[][] mat) {
<span class="fc" id="L81">        ArrayList&lt;Value&gt; a = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L82">        int n = mat.length;</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">            for (int j = 0; j &lt; n; j++) {</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">                if (mat[i][j] != 0) { a.add(new Value(i, j, mat[i][j])); }</span>
            }
        }
<span class="fc" id="L88">        return a;</span>
    }
    
    /**
     * Converts a sparse matrix representation to a dense matrix representation.
     *
     * @param mat  the sparse matrix representation
     * @return  the dense matrix representation
     */
    public static double[][] toDense(ArrayList&lt;Value&gt; mat) {
<span class="fc" id="L98">        int n = 0;</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">        for (Value v : mat) {</span>
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">            if (v.i &gt; n) { n = v.i; }</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">            if (v.j &gt; n) { n = v.j; }</span>
<span class="fc" id="L102">        }</span>
<span class="fc" id="L103">        double[][] a = new double[n + 1][n + 1];</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">        for (Value v : mat) {</span>
<span class="fc" id="L105">            a[v.i][v.j] = v.v;</span>
<span class="fc" id="L106">        }</span>
<span class="fc" id="L107">        return a;</span>
    }
    
    /**
     * Inverts a upper triangular matrix.
     *
     * @param mat  the upper triangular matrix to invert
     * @return  the inverted matrix
     */
    public static double[][] invertUpper(double[][] mat) {
<span class="fc" id="L117">        int n = mat.length;</span>
<span class="fc" id="L118">        double[][] inv = new double[n][n];</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">        for (int k = 0; k &lt; n; k++) {</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">            for (int i = 0; i &lt; k; i++) {</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">                for (int j = 0; j &lt; k; j++) {</span>
<span class="fc" id="L122">                    inv[i][k] = inv[i][k] + inv[i][j] * mat[j][k];</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">                    if (inv[i][k] == -0.0) { inv[i][k] = 0; }</span>
                }
            }
<span class="fc bfc" id="L126" title="All 2 branches covered.">            for (int j = 0; j &lt; k; j++) {</span>
<span class="fc" id="L127">                inv[j][k] = -inv[j][k] / mat[k][k];</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">                if (inv[j][k] == -0.0) { inv[j][k] = 0; }</span>
            }
            
<span class="fc" id="L131">            inv[k][k] = 1.0 / mat[k][k];</span>
        }
<span class="fc" id="L133">        return inv;</span>
    }
    
    /**
     * Inverts a lower triangular matrix.
     *
     * @param mat  the lower triangular matrix to invert
     * @return  the inverted matrix
     */
    public static double[][] invertLower(double[][] mat) {
<span class="fc" id="L143">        int n = mat.length;</span>
<span class="fc" id="L144">        double[][] inv = new double[n][n];</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">        for (int k = 0; k &lt; n; k++) {</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">            for (int i = 0; i &lt; k; i++) {</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">                for (int j = 0; j &lt; k; j++) {</span>
<span class="fc" id="L148">                    inv[k][i] = inv[k][i] + inv[j][i] * mat[k][j];</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">                    if (inv[k][i] == -0.0) { inv[k][i] = 0; }</span>
                }
            }
<span class="fc bfc" id="L152" title="All 2 branches covered.">            for (int j = 0; j &lt; k; j++) {</span>
<span class="fc" id="L153">                inv[k][j] = -inv[k][j] / mat[k][k];</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">                if (inv[k][j] == -0.0) { inv[k][j] = 0; }</span>
            }
            
<span class="fc" id="L157">            inv[k][k] = 1.0 / mat[k][k];</span>
        }
<span class="fc" id="L159">        return inv;</span>
    }
    
    /**
     * Solves the equation {@code Lx = b} using forward substitution for a
     * dense matrix.
     * &lt;p&gt;
     * Matrix L must be a square lower triangular matrix.
     *
     * @param mat  the matrix of coefficients
     * @param vec  the right-hand side vector
     * @return  the left-hand side vector
     */
    public static double[] forwardSubstitution(double[][] mat, double[] vec) {
<span class="fc" id="L173">        int n = vec.length;</span>
<span class="fc" id="L174">        double[] subbed = new double[n];</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L176">            double val = 0;</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">            for (int j = 0; j &lt; i; j++) {</span>
<span class="fc" id="L178">                val += subbed[j] * mat[i][j];</span>
            }
<span class="fc" id="L180">            val = vec[i] - val;</span>
<span class="fc" id="L181">            subbed[i] = val / mat[i][i];</span>
        }
<span class="fc" id="L183">        return subbed;</span>
    }
    
    /**
     * Solves the equation {@code Lx = U} using forward substitution for a
     * dense matrix.
     * &lt;p&gt;
     * The matrices {@code L} and {@code U} are the square lower and upper
     * triangular matrices of the given matrix.
     *
     * @param mat  the matrix of coefficients
     * @return  the left-hand side matrix
     */
    public static double[][] forwardSubstitution(double[][] mat) {
<span class="fc" id="L197">        double[][] lower = getLower(mat, false);</span>
<span class="fc" id="L198">        double[][] upper = getUpper(mat, true);</span>
<span class="fc" id="L199">        int n = lower.length;</span>
<span class="fc" id="L200">        double[][] subbed = new double[n][n];</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">            for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L203">                double val = 0;</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">                for (int k = 0; k &lt; i; k++) {</span>
<span class="fc" id="L205">                    val += subbed[k][j] * lower[i][k];</span>
                }
<span class="fc" id="L207">                val = upper[i][j] - val;</span>
<span class="fc" id="L208">                subbed[i][j] = val / lower[i][i];</span>
            }
        }
<span class="fc" id="L211">        return subbed;</span>
    }
    
    /**
     * Solves the equation {@code Lx = b} using forward substitution for a
     * sparse matrix.
     *
     * @param mat  the matrix of coefficients
     * @param vec  the right-hand side vector
     * @return  the left-hand side vector
     */
    public static double[] forwardSubstitution(ArrayList&lt;Value&gt; mat, double[] vec) {
<span class="fc" id="L223">        mat.sort((v1, v2) -&gt;</span>
<span class="pc bpc" id="L224" title="1 of 4 branches missed.">                (v1.i == v2.i ? Integer.compare(v1.j, v2.j) : (v1.i &gt; v2.i ? 1 : -1)));</span>
        
<span class="fc" id="L226">        int n = vec.length;</span>
<span class="fc" id="L227">        double[] subbed = new double[n];</span>
<span class="fc" id="L228">        double[] diag = new double[n];</span>
        
        // Group lower diagonal by row.
<span class="fc" id="L231">        ArrayList&lt;ArrayList&lt;Value&gt;&gt; rowsL = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">        for (int r = 0; r &lt; n; r++) {</span>
<span class="fc" id="L233">            rowsL.add(new ArrayList&lt;&gt;());</span>
        }
<span class="fc bfc" id="L235" title="All 2 branches covered.">        for (Value v : mat) {</span>
<span class="fc" id="L236">            rowsL.get(v.i).add(v);</span>
<span class="fc" id="L237">        }</span>
        
        // Get values along diagonal.
<span class="fc bfc" id="L240" title="All 2 branches covered.">        for (Value v : mat) {</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">            if (v.i == v.j) { diag[v.i] = v.v; }</span>
<span class="fc" id="L242">        }</span>
        
        // Iterate only through non-zero entries in the lower diagonal matrix.
<span class="fc bfc" id="L245" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L246">            ArrayList&lt;Value&gt; rowL = rowsL.get(i);</span>
<span class="fc" id="L247">            double val = 0;</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">            for (Value v : rowL) {</span>
<span class="fc" id="L249">                val += subbed[v.j] * v.v;</span>
<span class="fc" id="L250">            }</span>
<span class="fc" id="L251">            val = vec[i] - val;</span>
<span class="fc" id="L252">            subbed[i] = val / diag[i];</span>
        }
        
<span class="fc" id="L255">        return subbed;</span>
    }
    
    /**
     * Solves the equation {@code Lx = U} using forward substitution for a
     * sparse matrix.
     * &lt;p&gt;
     * The matrices {@code L} and {@code U} are the square lower and upper
     * triangular matrices of the given matrix.
     *
     * @param mat  the matrix of coefficients
     * @return  the left-hand side matrix
     */
    public static ArrayList&lt;Value&gt; forwardSubstitution(ArrayList&lt;Value&gt; mat) {
<span class="fc" id="L269">        mat.sort((v1, v2) -&gt;</span>
<span class="pc bpc" id="L270" title="1 of 4 branches missed.">                (v1.i == v2.i ? Integer.compare(v1.j, v2.j) : (v1.i &gt; v2.i ? 1 : -1)));</span>
        
<span class="fc" id="L272">        double[][] upper = getUpper(toDense(mat), true);</span>
<span class="fc" id="L273">        ArrayList&lt;Value&gt; lower = getLower(mat, true);</span>
<span class="fc" id="L274">        int n = upper.length;</span>
<span class="fc" id="L275">        double[][] subbed = new double[n][n];</span>
<span class="fc" id="L276">        double[] diag = new double[n];</span>
        
        // Group lower diagonal by row.
<span class="fc" id="L279">        ArrayList&lt;ArrayList&lt;Value&gt;&gt; rows = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">        for (int r = 0; r &lt; n; r++) {</span>
<span class="fc" id="L281">            rows.add(new ArrayList&lt;&gt;());</span>
        }
<span class="fc bfc" id="L283" title="All 2 branches covered.">        for (Value v : lower) {</span>
<span class="fc" id="L284">            rows.get(v.i).add(v);</span>
<span class="fc" id="L285">        }</span>
        
        // Get values along diagonal.
<span class="fc bfc" id="L288" title="All 2 branches covered.">        for (Value v : mat) {</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">            if (v.i == v.j) { diag[v.i] = v.v; }</span>
<span class="fc" id="L290">        }</span>
        
        // Iterate only through non-zero entries in the lower diagonal matrix.
<span class="fc bfc" id="L293" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L294">            ArrayList&lt;Value&gt; row = rows.get(i);</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">            for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L296">                double val = 0;</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">                for (Value v : row) {</span>
<span class="fc" id="L298">                    val += subbed[v.j][j] * v.v;</span>
<span class="fc" id="L299">                }</span>
<span class="fc" id="L300">                val = upper[i][j] - val;</span>
<span class="fc" id="L301">                subbed[i][j] = val / diag[i];</span>
            }
        }
        
<span class="fc" id="L305">        return toSparse(subbed);</span>
    }
    
    /**
     * Gets the upper triangular of a dense matrix.
     *
     * @param mat  the matrix
     * @param strict  {@code true} if triangular is strict, {@code false} otherwise
     * @return  the upper triangular matrix
     */
    public static double[][] getUpper(double[][] mat, boolean strict) {
<span class="fc" id="L316">        int n = mat.length;</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">        int off = (strict ? 1 : 0);</span>
<span class="fc" id="L318">        double[][] upper = new double[n][n];</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">            for (int j = i + off; j &lt; n; j++) {</span>
<span class="fc" id="L321">                upper[i][j] = mat[i][j];</span>
            }
        }
<span class="fc" id="L324">        return upper;</span>
    }
    
    /**
     * Gets the lower triangular of a dense matrix.
     *
     * @param mat  the matrix
     * @param strict  {@code true} if triangular is strict, {@code false} otherwise
     * @return  the lower triangular matrix
     */
    public static double[][] getLower(double[][] mat, boolean strict) {
<span class="fc" id="L335">        int n = mat.length;</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">        int off = (strict ? 0 : 1);</span>
<span class="fc" id="L337">        double[][] lower = new double[n][n];</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">            for (int j = 0; j &lt; i + off; j++) {</span>
<span class="fc" id="L340">                lower[i][j] = mat[i][j];</span>
            }
        }
<span class="fc" id="L343">        return lower;</span>
    }
    
    /**
     * Gets the upper triangular of a sparse matrix.
     *
     * @param mat  the matrix
     * @param strict  {@code true} if triangular is strict, {@code false} otherwise
     * @return  the upper triangular matrix
     */
    public static ArrayList&lt;Value&gt; getUpper(ArrayList&lt;Value&gt; mat, boolean strict) {
<span class="fc" id="L354">        ArrayList&lt;Value&gt; upper = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">        int off = (strict ? 0 : 1);</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">        for (Value v : mat) {</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">            if (v.j &gt; v.i - off) { upper.add(v); }</span>
<span class="fc" id="L358">        }</span>
<span class="fc" id="L359">        return upper;</span>
    }
    
    /**
     * Gets the lower triangular of a sparse matrix.
     *
     * @param mat  the matrix
     * @param strict  {@code true} if triangular is strict, {@code false} otherwise
     * @return  the lower triangular matrix
     */
    public static ArrayList&lt;Value&gt; getLower(ArrayList&lt;Value&gt; mat, boolean strict) {
<span class="fc" id="L370">        ArrayList&lt;Value&gt; lower = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">        int off = (strict ? 0 : 1);</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">        for (Value v : mat) {</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">            if (v.j &lt; v.i + off) { lower.add(v); }</span>
<span class="fc" id="L374">        }</span>
<span class="fc" id="L375">        return lower;</span>
    }
    
    /**
     * Multiplies two dense square matrices.
     *
     * @param matA  the first matrix
     * @param matB  the second matrix
     * @return  the product of the two matrices
     */
    public static double[][] multiply(double[][] matA, double[][] matB) {
<span class="fc" id="L386">        int n = matA.length;</span>
<span class="fc" id="L387">        double[][] multiplied = new double[n][n];</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">            for (int j = 0; j &lt; n; j++) {</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">                for (int k = 0; k &lt; n; k++) {</span>
<span class="fc" id="L391">                    multiplied[i][j] += matA[i][k] * matB[k][j];</span>
                }
            }
        }
<span class="fc" id="L395">        return multiplied;</span>
    }
    
    /**
     * Multiplies a dense square matrix and a vector.
     *
     * @param mat  the matrix
     * @param vec  the vector
     * @return  the product of the matrix and vector
     */
    public static double[] multiply(double[][] mat, double[] vec) {
<span class="fc" id="L406">        int n = mat.length;</span>
<span class="fc" id="L407">        double[] multiplied = new double[n];</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">            for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L410">                multiplied[i] += mat[i][j] * vec[j];</span>
            }
        }
<span class="fc" id="L413">        return multiplied;</span>
    }
    
    /**
     * Multiplies a sparse square matrix and a vector.
     *
     * @param mat  the matrix
     * @param vec  the vector
     * @return  the product of the matrix and vector
     */
    public static double[] multiply(ArrayList&lt;Value&gt; mat, double[] vec) {
<span class="nc" id="L424">        int n = vec.length;</span>
<span class="nc" id="L425">        double[] multiplied = new double[n];</span>
        
        // Iterate through all entries and multiply.
<span class="nc bnc" id="L428" title="All 2 branches missed.">        for (Value a : mat) {</span>
<span class="nc" id="L429">            multiplied[a.i] += a.v * vec[a.j];</span>
<span class="nc" id="L430">        }</span>
        
<span class="nc" id="L432">        return multiplied;</span>
    }
    
    /**
     * Multiplies two sparse square matrices.
     *
     * @param matA  the first matrix
     * @param matB  the second matrix
     * @return  the product of the two matrices
     */
    public static ArrayList&lt;Value&gt; multiply(ArrayList&lt;Value&gt; matA, ArrayList&lt;Value&gt; matB) {
<span class="fc" id="L443">        ArrayList&lt;Value&gt; multiplied = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L444">        ArrayList&lt;Value&gt; products = new ArrayList&lt;&gt;();</span>
        
        // Iterate through both matrices and calculate products.
<span class="fc bfc" id="L447" title="All 2 branches covered.">        for (Value a : matA) {</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">            for (Value b : matB) {</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">                if (a.j == b.i) { products.add(new Value(a.i, b.j, a.v * b.v)); }</span>
<span class="fc" id="L450">            }</span>
<span class="fc" id="L451">        }</span>
        
        // Sort products.
<span class="fc" id="L454">        products.sort((v1, v2) -&gt;</span>
<span class="fc bfc" id="L455" title="All 4 branches covered.">                (v1.i == v2.i ? Integer.compare(v1.j, v2.j) : (v1.i &gt; v2.i ? 1 : -1)));</span>
        
<span class="fc" id="L457">        int i = 0;</span>
<span class="fc" id="L458">        int j = 0;</span>
<span class="fc" id="L459">        double sum = 0;</span>
        
        // Iterate through products and make summations. Products must be sorted.
<span class="fc bfc" id="L462" title="All 2 branches covered.">        for (Value p : products) {</span>
<span class="fc bfc" id="L463" title="All 4 branches covered.">            if (p.i != i || p.j != j) {</span>
<span class="fc" id="L464">                multiplied.add(new Value(i, j, sum));</span>
<span class="fc" id="L465">                sum = 0;</span>
<span class="fc" id="L466">                i = p.i;</span>
<span class="fc" id="L467">                j = p.j;</span>
            }
<span class="fc" id="L469">            sum += p.v;</span>
<span class="fc" id="L470">        }</span>
        
        // Add in last case.
<span class="fc" id="L473">        Value p = products.get(products.size() - 1);</span>
<span class="pc bpc" id="L474" title="2 of 4 branches missed.">        if (p.i == i &amp;&amp; p.j == j) { multiplied.add(new Value(i, j, sum)); }</span>
        
<span class="fc" id="L476">        return multiplied;</span>
    }
    
    /**
     * Adds two vectors.
     *
     * @param vecA  the first vector
     * @param vecB  the second vector
     * @return  the sum of the two vectors
     */
    public static double[] add(double[] vecA, double[] vecB) {
<span class="nc" id="L487">        int n = vecA.length;</span>
<span class="nc" id="L488">        double[] added = new double[n];</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L490">            added[i] = vecA[i] + vecB[i];</span>
        }
<span class="nc" id="L492">        return added;</span>
    }
    
    /**
     * Subtracts two vectors.
     *
     * @param vecA  the first vector
     * @param vecB  the second vector
     * @return  the difference of the two vectors
     */
    public static double[] subtract(double[] vecA, double[] vecB) {
<span class="nc" id="L503">        int n = vecA.length;</span>
<span class="nc" id="L504">        double[] subtracted = new double[n];</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L506">            subtracted[i] = vecA[i] - vecB[i];</span>
        }
<span class="nc" id="L508">        return subtracted;</span>
    }
    
    /**
     * Scales the values in a dense matrix.
     *
     * @param mat  the matrix
     * @param scale  the value to scale by
     * @return  the scaled matrix
     */
    public static double[][] scale(double[][] mat, double scale) {
<span class="nc" id="L519">        int n = mat.length;</span>
<span class="nc" id="L520">        double[][] scaled = new double[n][n];</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L522">            scaled[i] = scale(mat[i], scale);</span>
        }
<span class="nc" id="L524">        return scaled;</span>
    }
    
    /**
     * Scales the values in a dense vector.
     *
     * @param vec  the vector
     * @param scale  the value to scale by
     * @return  the scaled vector
     */
    public static double[] scale(double[] vec, double scale) {
<span class="nc" id="L535">        int n = vec.length;</span>
<span class="nc" id="L536">        double[] scaled = new double[n];</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L538">            scaled[i] = vec[i] * scale;</span>
        }
<span class="nc" id="L540">        return scaled;</span>
    }
    
    /**
     * Scales the values in a sparse matrix.
     *
     * @param mat  the matrix
     * @param scale  the value to scale by
     * @return  the scaled matrix
     */
    public static ArrayList&lt;Value&gt; scale(ArrayList&lt;Value&gt; mat, double scale) {
<span class="nc" id="L551">        ArrayList&lt;Value&gt; scaled = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">        for (Value a : mat) {</span>
<span class="nc" id="L553">            scaled.add(new Value(a.i, a.j, a.v * scale));</span>
<span class="nc" id="L554">        }</span>
<span class="nc" id="L555">        return scaled;</span>
    }
    
    /**
     * Normalizes the vector.
     *
     * @param vec  the vector
     * @return  the normalized vector
     */
    public static double normalize(double[] vec) {
<span class="fc" id="L565">        double sum = 0;</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">        for (double v : vec) {</span>
<span class="fc" id="L567">            sum += v * v;</span>
        }
<span class="fc" id="L569">        return Math.sqrt(sum);</span>
    }
    
    /**
     * Calculates dot product of two vectors.
     *
     * @param vecA  the first matrix
     * @param vecB  the second matrix
     * @return  the dot product of the two vectors
     */
    public static double dot(double[] vecA, double[] vecB) {
<span class="fc" id="L580">        double sum = 0;</span>
<span class="fc bfc" id="L581" title="All 2 branches covered.">        for (int i = 0; i &lt; vecA.length; i++) {</span>
<span class="fc" id="L582">            sum += vecA[i] * vecB[i];</span>
        }
<span class="fc" id="L584">        return sum;</span>
    }
    
    /**
     * Converts the vector to a unit vector.
     *
     * @param vec  the vector to convert
     */
    public static void unit(double[] vec) {
<span class="fc" id="L593">        double norm = normalize(vec);</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">        for (int i = 0; i &lt; vec.length; i++) {</span>
<span class="fc" id="L595">            vec[i] /= norm;</span>
        }
<span class="fc" id="L597">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>