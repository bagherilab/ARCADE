<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Graph.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">arcade</a> &gt; <a href="index.source.html" class="el_package">arcade.core.util</a> &gt; <span class="el_source">Graph.java</span></div><h1>Graph.java</h1><pre class="source lang-java linenums">package arcade.core.util;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import sim.util.Bag;

/**
 * Container class for directed graph using nodes as hashes.
 *
 * &lt;p&gt;{@code Edge} objects represent edges in the graph and {@code Node} objects represent nodes in
 * the graph. Nodes may have more than one edge in or out.
 */
public final class Graph {
    /** Collection of all {@code Edge} objects in a graph. */
    private final Bag allEdges;

    /** Map of {@code Node} OUT to bag of {@code Edge} objects. */
    private final Map&lt;Node, Bag&gt; nodeToOutBag;

    /** Map of {@code Node} IN to bag of {@code Edge} objects. */
    private final Map&lt;Node, Bag&gt; nodeToInBag;

    /** Creates an empty {@code Graph}. */
<span class="nc" id="L29">    public Graph() {</span>
<span class="nc" id="L30">        allEdges = new Bag();</span>
<span class="nc" id="L31">        nodeToOutBag = new HashMap&lt;&gt;();</span>
<span class="nc" id="L32">        nodeToInBag = new HashMap&lt;&gt;();</span>
<span class="nc" id="L33">    }</span>

    /**
     * Updates edges and nodes with contents of given graph.
     *
     * @param graph the graph object
     */
    public void update(Graph graph) {
<span class="nc" id="L41">        allEdges.addAll(graph.allEdges);</span>
<span class="nc" id="L42">        nodeToOutBag.putAll(graph.nodeToOutBag);</span>
<span class="nc" id="L43">        nodeToInBag.putAll(graph.nodeToInBag);</span>
<span class="nc" id="L44">    }</span>

    /** Clear edges and nodes from graph. */
    public void clear() {
<span class="nc" id="L48">        allEdges.clear();</span>
<span class="nc" id="L49">        nodeToOutBag.clear();</span>
<span class="nc" id="L50">        nodeToInBag.clear();</span>
<span class="nc" id="L51">    }</span>

    /**
     * Gets all edges in the graph.
     *
     * @return a bag containing the edges
     */
    public Bag getAllEdges() {
<span class="nc" id="L59">        return allEdges;</span>
    }

    /**
     * Gets edges out of the given node.
     *
     * @param node the node that edges are from
     * @return a bag containing the edges
     */
    public Bag getEdgesOut(Node node) {
<span class="nc" id="L69">        return nodeToOutBag.get(node);</span>
    }

    /**
     * Gets edges into the given node.
     *
     * @param node the node that edges are to
     * @return a bag containing the edges
     */
    public Bag getEdgesIn(Node node) {
<span class="nc" id="L79">        return nodeToInBag.get(node);</span>
    }

    /**
     * Gets the in degree at the given node.
     *
     * @param node the node
     * @return the in degree
     */
    public int getInDegree(Node node) {
<span class="nc bnc" id="L89" title="All 2 branches missed.">        return nodeToInBag.containsKey(node) ? nodeToInBag.get(node).numObjs : 0;</span>
    }

    /**
     * Gets the out degree at the given node.
     *
     * @param node the node
     * @return the out degree
     */
    public int getOutDegree(Node node) {
<span class="nc bnc" id="L99" title="All 2 branches missed.">        return nodeToOutBag.containsKey(node) ? nodeToOutBag.get(node).numObjs : 0;</span>
    }

    /**
     * Gets the total degree (in degree + out degree) at the given node.
     *
     * @param node the node
     * @return the degree
     */
    public int getDegree(Node node) {
<span class="nc" id="L109">        return getInDegree(node) + getOutDegree(node);</span>
    }

    /**
     * Checks if the graph has an edge between the given nodes.
     *
     * @param from the node the edge points from
     * @param to the node the edge points to
     * @return {@code true} if edge exists, {@code false} otherwise
     */
    public boolean hasEdge(Node from, Node to) {
<span class="nc" id="L120">        Bag bag = getEdgesOut(from);</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">        if (bag == null) {</span>
<span class="nc" id="L122">            return false;</span>
        }
<span class="nc bnc" id="L124" title="All 2 branches missed.">        for (Object obj : bag) {</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">            if (to.equals(((Edge) obj).to)) {</span>
<span class="nc" id="L126">                return true;</span>
            }
<span class="nc" id="L128">        }</span>
<span class="nc" id="L129">        return false;</span>
    }

    /** Defines a filter for edges in a graph. */
    public interface GraphFilter {
        /**
         * Applies filter to an {link Edge} object.
         *
         * @param edge the edge
         * @return {@code true} if edge passes filter, {@code false} otherwise
         */
        boolean filter(Edge edge);
    }

    /**
     * Filters this graph for edges and copies them to the given graph object.
     *
     * &lt;p&gt;Notes that the links in the subgraph are not correct.
     *
     * @param g the graph to add filtered edges to
     * @param f the edge filter
     */
    public void getSubgraph(Graph g, GraphFilter f) {
<span class="nc bnc" id="L152" title="All 2 branches missed.">        for (Object obj : allEdges) {</span>
<span class="nc" id="L153">            Edge edge = (Edge) obj;</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">            if (f.filter(edge)) {</span>
<span class="nc" id="L155">                g.allEdges.add(edge);</span>
<span class="nc" id="L156">                g.setOutMap(edge.getFrom(), edge);</span>
<span class="nc" id="L157">                g.setInMap(edge.getTo(), edge);</span>
            }
<span class="nc" id="L159">        }</span>
<span class="nc" id="L160">    }</span>

    /** Sets the TO and FROM nodes for edges to be the same object. */
    public void mergeNodes() {
<span class="nc" id="L164">        Set&lt;Node&gt; sOut = nodeToOutBag.keySet();</span>
<span class="nc" id="L165">        Set&lt;Node&gt; sIn = nodeToInBag.keySet();</span>
<span class="nc" id="L166">        Set&lt;Node&gt; set =</span>
<span class="nc" id="L167">                new LinkedHashSet&lt;Node&gt;() {</span>
                    {
<span class="nc" id="L169">                        addAll(sOut);</span>
<span class="nc" id="L170">                        addAll(sIn);</span>
<span class="nc" id="L171">                    }</span>
                };

<span class="nc bnc" id="L174" title="All 2 branches missed.">        for (Node obj : set) {</span>
<span class="nc" id="L175">            Node join = obj.duplicate();</span>
<span class="nc" id="L176">            Bag out = getEdgesOut(obj);</span>
<span class="nc" id="L177">            Bag in = getEdgesIn(obj);</span>

            // Iterate through all edges OUT of node.
<span class="nc bnc" id="L180" title="All 2 branches missed.">            if (out != null) {</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">                for (Object x : out) {</span>
<span class="nc" id="L182">                    Edge e = (Edge) x;</span>
<span class="nc" id="L183">                    e.setFrom(join);</span>
<span class="nc" id="L184">                }</span>
            }

            // Iterate through all edges IN to node.
<span class="nc bnc" id="L188" title="All 2 branches missed.">            if (in != null) {</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">                for (Object x : in) {</span>
<span class="nc" id="L190">                    Edge e = (Edge) x;</span>
<span class="nc" id="L191">                    e.setTo(join);</span>
<span class="nc" id="L192">                }</span>
            }
<span class="nc" id="L194">        }</span>
<span class="nc" id="L195">    }</span>

    /**
     * Adds edge to graph.
     *
     * @param edge the edge to add
     */
    public void addEdge(Edge edge) {
<span class="nc" id="L203">        allEdges.add(edge);</span>
<span class="nc" id="L204">        setOutMap(edge.getFrom(), edge);</span>
<span class="nc" id="L205">        setInMap(edge.getTo(), edge);</span>
<span class="nc" id="L206">        setLinks(edge);</span>
<span class="nc" id="L207">    }</span>

    /**
     * Adds the edge to the bag for the mapping of OUT node to edge.
     *
     * @param node the node hash
     * @param edge the edge
     */
    private void setOutMap(Node node, Edge edge) {
<span class="nc" id="L216">        Bag objs = nodeToOutBag.get(node);</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">        if (objs == null) {</span>
<span class="nc" id="L218">            objs = new Bag(10);</span>
<span class="nc" id="L219">            nodeToOutBag.put(node.duplicate(), objs);</span>
        }
<span class="nc" id="L221">        objs.add(edge);</span>
<span class="nc" id="L222">    }</span>

    /**
     * Adds the edge to the bag for the mapping of IN node to edge.
     *
     * @param node the node hash
     * @param edge the edge
     */
    private void setInMap(Node node, Edge edge) {
<span class="nc" id="L231">        Bag objs = nodeToInBag.get(node);</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (objs == null) {</span>
<span class="nc" id="L233">            objs = new Bag(10);</span>
<span class="nc" id="L234">            nodeToInBag.put(node.duplicate(), objs);</span>
        }
<span class="nc" id="L236">        objs.add(edge);</span>
<span class="nc" id="L237">    }</span>

    /**
     * Adds links between edges in and out of the nodes for a given edge.
     *
     * @param edge the edge
     */
    public void setLinks(Edge edge) {
<span class="nc" id="L245">        Bag outTo = getEdgesOut(edge.getTo());</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">        if (outTo != null) {</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">            for (Object obj : outTo) {</span>
<span class="nc" id="L248">                Edge e = (Edge) obj;</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">                if (!e.edgesIn.contains(edge)) {</span>
<span class="nc" id="L250">                    e.edgesIn.add(edge);</span>
                }
<span class="nc bnc" id="L252" title="All 2 branches missed.">                if (!edge.edgesOut.contains(e)) {</span>
<span class="nc" id="L253">                    edge.edgesOut.add(e);</span>
                }
<span class="nc" id="L255">            }</span>
        }

<span class="nc" id="L258">        Bag inFrom = getEdgesIn(edge.getFrom());</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">        if (inFrom != null) {</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">            for (Object obj : inFrom) {</span>
<span class="nc" id="L261">                Edge e = (Edge) obj;</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">                if (!e.edgesOut.contains(edge)) {</span>
<span class="nc" id="L263">                    e.edgesOut.add(edge);</span>
                }
<span class="nc bnc" id="L265" title="All 2 branches missed.">                if (!edge.edgesIn.contains(e)) {</span>
<span class="nc" id="L266">                    edge.edgesIn.add(e);</span>
                }
<span class="nc" id="L268">            }</span>
        }
<span class="nc" id="L270">    }</span>

    /**
     * Removes edge from graph.
     *
     * @param edge the edge to remove
     */
    public void removeEdge(Edge edge) {
<span class="nc" id="L278">        allEdges.remove(edge);</span>
<span class="nc" id="L279">        unsetOutMap(edge.getFrom(), edge);</span>
<span class="nc" id="L280">        unsetInMap(edge.getTo(), edge);</span>
<span class="nc" id="L281">        unsetLinks(edge);</span>
<span class="nc" id="L282">    }</span>

    /**
     * Removes the edge from the bag for the mapping of OUT node to edge.
     *
     * @param node the node hash
     * @param edge the edge
     */
    private void unsetOutMap(Node node, Edge edge) {
<span class="nc" id="L291">        Bag objs = nodeToOutBag.get(node);</span>
<span class="nc" id="L292">        objs.remove(edge);</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">        if (objs.numObjs == 0) {</span>
<span class="nc" id="L294">            nodeToOutBag.remove(node);</span>
        }
<span class="nc" id="L296">    }</span>

    /**
     * Removes the edge from the bag for the mapping of IN node to edge.
     *
     * @param node the node hash
     * @param edge the edge
     */
    private void unsetInMap(Node node, Edge edge) {
<span class="nc" id="L305">        Bag objs = nodeToInBag.get(node);</span>
<span class="nc" id="L306">        objs.remove(edge);</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (objs.numObjs == 0) {</span>
<span class="nc" id="L308">            nodeToInBag.remove(node);</span>
        }
<span class="nc" id="L310">    }</span>

    /**
     * Removes links between edges in and out of the nodes for a given edge.
     *
     * @param edge the edge
     */
    private void unsetLinks(Edge edge) {
<span class="nc" id="L318">        Bag outTo = getEdgesOut(edge.getTo());</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">        if (outTo != null) {</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">            for (Object obj : outTo) {</span>
<span class="nc" id="L321">                Edge e = (Edge) obj;</span>
<span class="nc" id="L322">                e.edgesIn.remove(edge);</span>
<span class="nc" id="L323">                edge.edgesOut.remove(e);</span>
<span class="nc" id="L324">            }</span>
        }

<span class="nc" id="L327">        Bag inFrom = getEdgesIn(edge.getFrom());</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">        if (inFrom != null) {</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">            for (Object obj : inFrom) {</span>
<span class="nc" id="L330">                Edge e = (Edge) obj;</span>
<span class="nc" id="L331">                e.edgesOut.remove(edge);</span>
<span class="nc" id="L332">                edge.edgesIn.remove(e);</span>
<span class="nc" id="L333">            }</span>
        }
<span class="nc" id="L335">    }</span>

    /**
     * Removes the given edge and adds the reversed edge.
     *
     * @param edge the edge to reverse
     */
    public void reverseEdge(Edge edge) {
<span class="nc" id="L343">        removeEdge(edge);</span>
<span class="nc" id="L344">        addEdge(edge.reverse());</span>
<span class="nc" id="L345">    }</span>

    /**
     * Displays the graph as a list of edges and nodes.
     *
     * @return the string representation of the graph
     */
    public String toString() {
<span class="nc" id="L353">        String s = &quot;&quot;;</span>

<span class="nc" id="L355">        s += &quot;\nEDGES OUT\n\n&quot;;</span>
<span class="nc" id="L356">        Set&lt;Node&gt; setFrom = nodeToOutBag.keySet();</span>
<span class="nc" id="L357">        List&lt;Node&gt; sortedFrom = new ArrayList&lt;&gt;(setFrom);</span>
<span class="nc" id="L358">        Collections.sort(sortedFrom);</span>

<span class="nc bnc" id="L360" title="All 2 branches missed.">        for (Object obj : sortedFrom) {</span>
<span class="nc" id="L361">            Bag b = nodeToOutBag.get(obj);</span>
<span class="nc" id="L362">            s += obj.toString() + &quot; : &quot;;</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">            for (int i = 0; i &lt; b.numObjs; i++) {</span>
<span class="nc" id="L364">                s += b.get(i) + &quot; &quot;;</span>
            }
<span class="nc" id="L366">            s += &quot;\n&quot;;</span>
<span class="nc" id="L367">        }</span>

<span class="nc" id="L369">        s += &quot;\nEDGES IN\n\n&quot;;</span>
<span class="nc" id="L370">        Set&lt;Node&gt; setTo = nodeToInBag.keySet();</span>
<span class="nc" id="L371">        List&lt;Node&gt; sortedTo = new ArrayList&lt;&gt;(setTo);</span>
<span class="nc" id="L372">        Collections.sort(sortedTo);</span>

<span class="nc bnc" id="L374" title="All 2 branches missed.">        for (Object obj : sortedTo) {</span>
<span class="nc" id="L375">            Bag b = nodeToInBag.get(obj);</span>
<span class="nc" id="L376">            s += obj.toString() + &quot; : &quot;;</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">            for (int i = 0; i &lt; b.numObjs; i++) {</span>
<span class="nc" id="L378">                s += b.get(i) + &quot; &quot;;</span>
            }
<span class="nc" id="L380">            s += &quot;\n&quot;;</span>
<span class="nc" id="L381">        }</span>

<span class="nc" id="L383">        return s;</span>
    }

    /**
     * Nested class representing a graph node.
     *
     * &lt;p&gt;The node tracks its corresponding position in the lattice.
     */
    public abstract static class Node implements Comparable&lt;Node&gt; {
        /** Coordinate in x direction. */
        protected int x;

        /** Coordinate in y direction. */
        protected int y;

        /** Coordinate in z direction. */
        protected int z;

        /**
         * Creates a {@code Node} at the given coordinates.
         *
         * @param x the x coordinate
         * @param y the y coordinate
         * @param z the z coordinate
         */
<span class="nc" id="L408">        public Node(int x, int y, int z) {</span>
<span class="nc" id="L409">            this.x = x;</span>
<span class="nc" id="L410">            this.y = y;</span>
<span class="nc" id="L411">            this.z = z;</span>
<span class="nc" id="L412">        }</span>

        /**
         * Gets the x coordinate of the node.
         *
         * @return the x coordinate
         */
        public int getX() {
<span class="nc" id="L420">            return x;</span>
        }

        /**
         * Gets the y coordinate of the node.
         *
         * @return the y coordinate
         */
        public int getY() {
<span class="nc" id="L429">            return y;</span>
        }

        /**
         * Gets the z coordinate of the node.
         *
         * @return the z coordinate
         */
        public int getZ() {
<span class="nc" id="L438">            return z;</span>
        }

        /**
         * Compares a node to this node.
         *
         * @param node the node to compare
         * @return zero if the x and y coordinates are equal, otherwise the result of integer
         *     comparison for x and y
         */
        public int compareTo(Node node) {
<span class="nc" id="L449">            int xComp = Integer.compare(x, node.getX());</span>
<span class="nc" id="L450">            int yComp = Integer.compare(y, node.getY());</span>

<span class="nc bnc" id="L452" title="All 2 branches missed.">            if (xComp == 0) {</span>
<span class="nc" id="L453">                return yComp;</span>
            } else {
<span class="nc" id="L455">                return xComp;</span>
            }
        }

        /**
         * Creates a duplicate node with the same coordinates.
         *
         * @return a {@code Node} copy
         */
        public abstract Node duplicate();

        /**
         * Updates the position of this {@code Node} with coordinate from given {@code Node}.
         *
         * @param node the {@code Node} with coordinates to update with
         */
        public void update(Node node) {
<span class="nc" id="L472">            this.x = node.x;</span>
<span class="nc" id="L473">            this.y = node.y;</span>
<span class="nc" id="L474">            this.z = node.z;</span>
<span class="nc" id="L475">        }</span>

        /**
         * Specifies object hashing based on coordinates.
         *
         * @return a hash based on coordinates
         */
        public final int hashCode() {
<span class="nc" id="L483">            return x + y &lt;&lt; 8 + z &lt;&lt; 16;</span>
        }

        /**
         * Checks if two nodes are equal based on coordinates.
         *
         * @param obj the object to check
         * @return {@code true} if coordinates match, {@code false} otherwise
         */
        public final boolean equals(Object obj) {
<span class="nc bnc" id="L493" title="All 2 branches missed.">            if (obj instanceof Node) {</span>
<span class="nc" id="L494">                Node node = (Node) obj;</span>
<span class="nc bnc" id="L495" title="All 6 branches missed.">                return node.x == x &amp;&amp; node.y == y &amp;&amp; node.z == z;</span>
            }
<span class="nc" id="L497">            return false;</span>
        }

        /**
         * Formats node as a string.
         *
         * @return a string representation of the node
         */
        public String toString() {
<span class="nc" id="L506">            return &quot;(&quot; + x + &quot;,&quot; + y + &quot;,&quot; + z + &quot;)&quot;;</span>
        }
    }

    /**
     * Nested class representing a graph edge.
     *
     * &lt;p&gt;The edge tracks its corresponding nodes as well as the edges into the FROM node and out of
     * the TO node.
     */
    public abstract static class Edge {
        /** Node this edge points to. */
        protected Node to;

        /** Node this edge points from. */
        protected Node from;

        /** List of edges that point into the node this edge points from. */
        private final ArrayList&lt;Edge&gt; edgesIn;

        /** List of edges that point out of the node this edge points to. */
        private final ArrayList&lt;Edge&gt; edgesOut;

        /**
         * Creates an {@code Edge} between two {@link Node} objects.
         *
         * @param from the node the edge is from
         * @param to the node the edge is to
         */
<span class="nc" id="L535">        public Edge(Node from, Node to) {</span>
<span class="nc" id="L536">            this.from = from.duplicate();</span>
<span class="nc" id="L537">            this.to = to.duplicate();</span>
<span class="nc" id="L538">            edgesIn = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L539">            edgesOut = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L540">        }</span>

        /**
         * Gets the node the edge points from.
         *
         * @return the node the edge points from
         */
        public Node getFrom() {
<span class="nc" id="L548">            return from;</span>
        }

        /**
         * Gets the node the edge points to.
         *
         * @return the node the edge points to
         */
        public Node getTo() {
<span class="nc" id="L557">            return to;</span>
        }

        /**
         * Sets the node the edge points to.
         *
         * @param to the node the edge points to
         */
        public void setTo(Node to) {
<span class="nc" id="L566">            this.to = to;</span>
<span class="nc" id="L567">        }</span>

        /**
         * Sets the node the edge points from.
         *
         * @param from the node the edge points from
         */
        public void setFrom(Node from) {
<span class="nc" id="L575">            this.from = from;</span>
<span class="nc" id="L576">        }</span>

        /**
         * Gets list of edges that point into the node this edge points from.
         *
         * @return the list of edges
         */
        public ArrayList&lt;Edge&gt; getEdgesIn() {
<span class="nc" id="L584">            return edgesIn;</span>
        }

        /**
         * Gets list of edges that point out of the node this edge points to.
         *
         * @return the list of edges
         */
        public ArrayList&lt;Edge&gt; getEdgesOut() {
<span class="nc" id="L593">            return edgesOut;</span>
        }

        /**
         * Reverses the edge by swapping the nodes.
         *
         * @return the reversed edge
         */
        Edge reverse() {
<span class="nc" id="L602">            Node tempTo = to;</span>
<span class="nc" id="L603">            Node tempFrom = from;</span>
<span class="nc" id="L604">            to = tempFrom;</span>
<span class="nc" id="L605">            from = tempTo;</span>
<span class="nc" id="L606">            return this;</span>
        }

        /** Removes the linked edges. */
        public void clear() {
<span class="nc" id="L611">            edgesIn.clear();</span>
<span class="nc" id="L612">            edgesOut.clear();</span>
<span class="nc" id="L613">        }</span>

        /**
         * Formats edge as a string.
         *
         * @return a string representation of the edge
         */
        public String toString() {
<span class="nc" id="L621">            return &quot;[&quot; + from.toString() + &quot;~&quot; + to.toString() + &quot;]&quot;;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>